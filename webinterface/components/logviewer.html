<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>FFAStrans Workflow</title>
<link rel="stylesheet" href="/alternate-server/css/override.css"></link>
<script src="/socket.io/socket.io.js"></script>
<!-- Sets the basepath for the library if not in same directory -->
<script type="text/javascript">
    mxBasePath = '../dependencies/mxgraph/406/javascript/src';
</script>
<script src="../dependencies/jquery/jquery.js"></script>
<script src="../dependencies/moment/moment.js"></script>
<!-- Loads and initializes the library -->
<!--    <script type="text/javascript" src="../dependencies/mxgraph/javascript/src/js/mxClient.js"></script>-->
<script type="text/javascript" src="../dependencies/mxgraph/406/javascript/mxClient.min.js"></script>

<!-- Grid dependency -->
<script src="../dependencies/fancytree/modules/colResizable-1.6.min.js"></script>
<link href="../dependencies/fancytree/skin-custom-1/ui.fancytree.css" rel="stylesheet"></link>
<script src="../dependencies/fancytree/modules/jquery.fancytree.ui-deps.js"></script>
<!--<script src="../dependencies/fancytree/modules/jquery.fancytree.js" type="text/javascript"></script>-->
<script src="../dependencies/fancytree/jquery.fancytree-all-deps.min.js"></script>
<script src="../dependencies/fancytree/modules/jquery.fancytree.dnd.js" type="text/javascript"></script>
<script src="../dependencies/fancytree/modules/jquery.fancytree.filter.js" type="text/javascript"></script>
<script src="../dependencies/fancytree/modules/jquery.fancytree.edit.js" type="text/javascript"></script>
<script src="../dependencies/fancytree/modules/jquery.fancytree.gridnav.js" type="text/javascript"></script>
<script src="../dependencies/fancytree/modules/jquery.fancytree.table.js" type="text/javascript"></script>
<script src="../dependencies/fancytree/modules/jquery.fancytree.multi.js"></script>
<script src="../dependencies/fancytree/modules/jquery.fancytree.fixed.js"></script>

<script src="../dependencies/json.human.js-master/src/json.human.js"></script>
<!--    <script src="../dependencies/json.human.js-master/lib/codemirror_min.js"></script>
    <script src="../dependencies/json.human.js-master/lib/codemirror_mode.js"></script>
    <script src="../dependencies/json.human.js-master/lib/require.js"></script>
    <link rel="stylesheet" href="../dependencies/json.human.js-master/lib/codemirror.css" type="text/css">
    -->
    
<!-- google chart timeline - cannot be used offline due to license restrictions -->
<script type='text/javascript' src='https://www.google.com/jsapi'></script>

<link rel="stylesheet" href="../dependencies/json.human.js-master/css/json.human.css" type="text/css"></link>

<!-- FONTAWESOME -->
<link rel="stylesheet" href="../dependencies/fontawesome/css/all.css" ></link>

<!-- MATERIALDESIGN ICONS -->
<link href="../dependencies/MaterialDesign-Webfont-7.2.96/css/materialdesignicons.min.css" media="all" rel="stylesheet" type="text/css" />

<!-- DHTMLX dependencies -->
<script src="../dependencies/dhtmlx/dhtmlx.js"></script>
<link rel="stylesheet" href="../dependencies/dhtmlx/dhtmlx.css" id="theme_loader" type="text/css">

<script src="../dependencies/dhtmlx/8.4.5/suite.umd.js"></script>
<link rel="stylesheet" href="../dependencies/dhtmlx/8.4.5/suite.min.css" type="text/css"></link>



<style type="text/css" id="customstyle">
    /* it's important to set width/height to 100% for full-screen init */
    html, body {
        width: 100%;
        height: 100%;
        margin: 0px;
        overflow: hidden;
        color: #333;
        font: 14px;
        font-family: var(--dhx-font-family);
        line-height: 18px;
    }

    th{
        font-weight: normal;
    }

    #graphContainer {
        /*background: url('../images/canvas_background.png');*/
        position: absolute;
        white-space: nowrap;
        font-family: Arial;
        font-size: 8pt;
        display: block;
        width: 100%;
        height: 100%;
        background-color:#E7E7E7;
    }

    /* svg {
            min-width: unset !important;
            min-height: unset !important;
    } */
        
    .exec_count {
        background: #555555;
        border-radius: 0.9em;
        -moz-border-radius: 0.9em;
        -webkit-border-radius: 0.9em;
        color: #FFFFEE;
        display: inline-block;
        line-height: 1.7em;
        position: absolute;
        left: -30px;
        top: -30px;
        text-align: center;
        width: 1.7em;
    }

    table, th, td {
        border: 1px solid black;
        table-layout:fixed;
        white-space:nowrap;
        vertical-align: top;
        overflow:hidden;
    }

    #treetable_log {
        overflow:unset!important;
        table-layout:fixed;
        white-space:nowrap;
        vertical-align: top;
        border-collapse: separate !important; /* Don't collapse */
        border-spacing: 0;
    }

    :root {
        --canvas-font-size-processor: 4em;
        --canvas-font-size-sub-wf-ctrl: 20px;
    }

    .table_ffastrans_processor_enabled {
        overflow: hidden;
        font-size: var(--canvas-font-size-processor); /*wf description as font size 8, header has 15*/
        font-family: Calibri;
        border: 3px rgb(85,85,85);
        background-color: rgb(184,184,184);
    }

    .table_ffastrans_processor_disabled {
        overflow: hidden;
        font-size: var(--canvas-font-size-processor);
        font-family: Calibri;
        border: 3px rgb(85,85,85);
        background-color: rgb(184,184,184);
        opacity: .4
    }

    .sub_wf_ctrl_icons{
        display:inline-flex;
        float:right;
        /* position:absolute;
        float:right;
        margin-right:var(--canvas-font-size-sub-wf-ctrl); */
        font-size: var(--canvas-font-size-sub-wf-ctrl);
    }

    .sub_wf_ctrl_icons > span{
        border:1px solid;
        margin:2px;
    }

    .sub_wf_ctrl_icons .mdi:hover {
        display:inline-block;
        transform: scale(1.1);
        cursor:pointer;
    }

    .overflow_auto{
        overflow:auto;
    }
    .overflow_hidden{
        overflow:hidden;
    }

    .tr_ffastrans_processor_desc{
        font-size: 4em;
        
    }
    .tr_ffastrans_processor_top {
        background-color: rgb(119,119,119);
        height: 30%;
        color: white;
    }

    .jh-key, .jh-value {
        margin: 0;
        padding: 0 5px 0 5px !important;
        /* padding: 0.2em;*/
        font-weight: lighter;
        font-size: var(--dhx-font-size-normal);
    }

    div.gridbox {
        overflow: initial;
        
    }
    div.gridbox table.obj td{
        user-select: text !important;
    }

    .dhx_cell_cont_wins {
        overflow: scroll !important;
    }


    /*three dots on text overflow*/
    .celltext {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        user-select: text;
        margin-left: 6px;
        font-size: var(--dhx-font-size-normal);
        color: var(--dhx-font-color-primary);
        font-family: var(--dhx-font-family);
    }

    .blinking-progress {
        /* NAME | TIME | ITERATION */
        -webkit-animation: changeShadowProgress 0.5s infinite alternate;
        -moz-animation: changeShadowProgress 0.5s infinite alternate;
        animation: changeShadowProgress 0.5s infinite alternate;
    }

    .blinking-selected {
        border-bottom: calc(var(--canvas-font-size-processor)/2) solid #0000ff78
    }
    
    /* todo: we could use a variable for the sizes in order to support changing the base resolution of the graph (the real processor pixel width) 
        but as the real processor pixel width is not changed dynamically, we can leave it hardcoded.
    */
    @keyframes changeShadowProgress {
        from {
            box-shadow: 0 0 50px 10px #93ce99;
        }
        to {
            box-shadow: 0 0 50px 10px #269922;
        }
    }

    .blinking-error {
        /* NAME | TIME | ITERATION */
        -webkit-animation: changeShadowError 0.5s infinite alternate;
        -moz-animation: changeShadowError 0.5s infinite alternate;
        animation: changeShadowError 0.5s infinite alternate;
    }

    @keyframes changeShadowError {
        from {
            box-shadow: 0 0 50px 10px #a21a1a;
        }

        to {
            box-shadow: 0 0 50px 10px #a21a1a;
        }
    }

    .sticky{
        position:sticky;
        top:0;
    }
</style>

<script>
    //theme changeer disabled for jobviewer
    if (localStorage.global_skin_dark == "1"){
        try{
            document.querySelector("#theme_loader").href = document.querySelector("#theme_loader").href.replace("dhtmlx.css","dhtmlx_benjamin.css")
        }catch(ex){}
        try{
            dhx.setTheme("dark");
        }catch(ex){}
        try{
            dhx8.dhx.setTheme("dark");
        }catch(ex){}
    }
</script>

<script type="text/javascript">


//madatory url parameter: workflowid
//request job from server
var m_debuggraph = {};

var m_workflowdata = {}; //deprecated, we got multiple workflows now
var m_workflows = []; //deprecated, we got multiple workflows now

var m_jobobject = {};
var m_unique_nodes = {}; //filled by logparse method, contains all unique nodes
var m_graph;
var m_graphs_by_container_id = {};
var m_serverconfig;
var mainLayout;
var m_timelineobject =  [];
var m_userpermissions;
let m_subWorkflows = {node_id:"workflow_id"}
let m_branchGrid;


/** Support closing the dhtmlx window in parent window, when this is loaded as iframe 
* Parent window must set m_closefunc to the function that closes the dhx win
*/

var m_closefunc = function(){}//must be set by parent window
function hotKey(event){
	if (event.isComposing || event.keyCode === 27){//esc
		m_closefunc();
	} 
}
window.addEventListener("keydown", hotKey);

/*load config from server*/
function loadserverconfig() {
    
$.ajax({
    url: ("/getuserpermissions" + "?" + Math.random()),
    type: "GET",
    success: function(response) {

        m_userpermissions = JSON.parse(response);
        //load serverconfig and initialize page
            $.ajax({
                url: ("/getserverconfig" + "?" + Math.random()),
                type: "GET",
                success: function(response) {
                    m_serverconfig = JSON.parse(response);
                    init();
                },
                error: function(xhr, status) {
                    dhtmlx.message("Fatal error, could not load serverconfig. ");
                    document.body.innerHTML = "Fatal error, could not load serverconfig. " + xhr.responseText;
                }
            });
        },
        error: function(xhr, status) {
            dhtmlx.message("Fatal error, could not load serverconfig. ");
            document.body.innerHTML = "Fatal error, could not load serverconfig. " + xhr.responseText;
        }

    });
}

/**
 * checks if there is one parent element containing the class
*/
function checkParentsForClass(element, targetClass, maxDepth = 10) {
    let currentElement = element;
    let depth = 0;

    while (currentElement && depth < maxDepth) {
        if (currentElement.classList && currentElement.classList.contains(targetClass)) {
            return true; // Found a parent with the target class
        }
        currentElement = currentElement.parentNode; // Move to the parent node
        depth++;
    }

    return false; // No parent with the class found within the depth limit
}

/*MAIN ENTRY POINT*/
function init() {
    /* 
        global overriden events using MutationObserver
    */

    document.body.addEventListener('wheel', function(e){ 
        /* disables scrolling inside processors, prevents subworkflow odd scrollbar behaviour */
        let hoveredEle = document.elementFromPoint(e.clientX, e.clientY).parentNode.parentNode;
        let disablescroll = checkParentsForClass(hoveredEle,"div_ffastrans_processor_container",10);
        if (disablescroll){
            // console.log("forced disable scroll because parent class div_ffastrans_processor_container" )
            e.preventDefault(); 
        }
            
    }, { passive: false });


    /*
        build everything
    */
    buildMainLayout();

    buildLogGridGrid();
    initNodeGrid();
    console.log("Getting Job Details of " + getQueryVariable("job_id"))
    get_all_job_details(getQueryVariable("job_id"));

}

function buildMainLayout() {
    mainLayout = new dhtmlXLayoutObject({
        // mainLayout = headerLayout.cells("b").attachLayout({
        parent: document.body,
        pattern: "3L"
    });

    mainMenu = mainLayout.attachMenu();
    
    var menuButtonLabels = [
                            "Close",
                            "New Tab",
                            "Load latest Job",
                            "Resubmit Job",
                            "Refresh this page",
                           
                            
                        ];
    var menuButtonHtml = [  
                            '<button class="btn logviewer_menu" style="float:left"><span class="mdi mdi-close"></span> Close</button>',
                            '<button class="btn logviewer_menu"><span class="mdi mdi-open-in-new"></span> New Tab</button>',
                            '<button title="Load log from latest Finished Job" class="btn logviewer_menu"><span class="mdi mdi-rss"></span> Latest Finished Job</button>',
                            '<button class="btn logviewer_menu"><span class="mdi mdi-repeat"></span> Resubmit Job</button>',
                            '<button class="btn logviewer_menu"><span class="mdi mdi-refresh"></span> Refresh this page</button>',
                           
                            
                            ];
                            
    var _filter = _getObjectByValue(m_userpermissions,"FILTER_JOBSTATUS_BUTTONS");
    if (_filter.length > 0){
        
        var regex = new RegExp( _filter[0]["value"]["filter"], 'gi' );
        console.log("Displaying filtered list of buttons, regex: ", regex);
        
        //add filtered btns to Running jobgrid
        for (let _id=0;_id<menuButtonLabels.length;_id++){
            if (menuButtonLabels[_id].match(regex)){
                _appendtext(menuButtonLabels[_id],menuButtonHtml[_id])
            }
        }
        
    }else{
        //just render all btns
        console.log("Displaying unfiltered list of menu buttons" )
        for (let _id=0;_id<menuButtonLabels.length;_id++){
            _appendtext(menuButtonLabels[_id],menuButtonHtml[_id])
        }
    }
    
    function _appendtext (label, html){//helper
        mainMenu.addNewSibling(null, label, html);
    }

    mainMenu.attachEvent("onClick", function (id) {
            if (id == "Close"){
                m_closefunc();
            }
            if (id == "New Tab"){
                window.open(window.location.href,'_blank');
                // document.getElementById("nav-questions").setAttribute(window.location.href, "_blank");
                // document.getElementById("nav-questions").click();
                // document.getElementById("nav-questions").setAttribute("target", "_blank");

                // document.getElementById("nav-questions").dispatchEvent((function(e){
                // e.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0,
                //                     false, false, false, false, 0, null);
                // return e
                // }(document.createEvent('MouseEvents'))));
            }
            if (id == "Refresh this page"){
                window.location.href = window.location.href;
            }
            if (id == "Load latest Job") {
            var url = "/gethistoryjobsajax_treegrid?count=1"
                $.ajax({
                    url: url,
                    type: "GET",
                    crossDomain: true,
                    dataType: "json",
                    success: function (response) {
                        if (response["data"]) {
                            var jid = response["data"][0]["job_id"];
                            window.location.href = window.location.href.replace(/[\?#].*|$/, "?job_id=") + jid;
                        }
                    },
                    error: function (xhr, status) {
                        alert("ERROR getting latest job please check FFAStrans Path in Admin settings on the left.. ");
                    }
                });
            }
        
            if (id == "Resubmit Job"){
                console.log("resubmitting job", m_jobobject)
                
                var postBody = {};
                postBody.start_proc = "";
                postBody.wf_id = m_jobobject["workflow"]["id"];
                postBody.inputfile = m_jobobject["sources"]["original_file"];
                postBody.variables = m_jobobject["variables"];
                postBody.system = "FFAStrans Web Interface";
                    $.ajax({
                    url: build_new_api_url("/jobs"),
                    type: "POST",
                    contentType: 'application/json;charset=UTF-8',
                    crossDomain: true,
                    data: JSON.stringify(postBody),
                    success: function(response) {
                        console.log("Job Resubmit response:",response);
                        try{
                            if (["job_id"] in response){
                                dhtmlx.alert({
                                        type:"confirm",
                                        text:"Success, Window will reload to display the resubmitted job in 3 seconds, you cannot prevent this anymore",
                                        title:"Reload Pending!",
                                        ok:"OK"
                                });
                                window.setTimeout(function(){
                                    window.location.href = window.location.href.replace(/[\?#].*|$/, "?job_id=") + response["job_id"];
                                },3000);
                            }else{
                                
                            }
                        }catch(ex){
                            console.log(ex)
                            alert("Error resubmitting job, contact developer\n\n" + ex)
                        }
                    },
                    error: function(xhr, status) {
                        dhtmlx.alert("Error submitting job: " + xhr.responseText);
                    }
                });
            }


    });


    mainLayout.cells("b").setText('<span style="margin-right:15px;font-size:13px" >Canvas</span> \
                        <button class="btn icon-logviewer-menu" name="b_zoomin" onclick="m_graph.zoomIn()"><span class="mdi mdi-plus"></span></button> \
                        <button class="btn icon-logviewer-menu" name="b_zoomout" onclick="m_graph.zoomOut()"><span class="mdi mdi-minus"></span></button> \
                        <button class="btn icon-logviewer-menu" name="b_fit" onclick="m_graph.fit()" title="Center"><span class="mdi mdi-arrow-collapse-all"></span></button> \
                        <button class="btn icon-logviewer-menu"  name="b_image" onclick="export_StyledSVG()" title="Download"><span class="mdi mdi-download"></button> ');
    mainLayout.cells("b").attachHTMLString('<div id="graphContainer" style="position:relative;overflow:hidden;cursor:default;float:left"></div>'
    //+'<div id="graphContainer2" style="position:relative;overflow:hidden;cursor:default;background-color:#E7E7E7"></div>'
    );
    mainLayout.cells("c").setText('<span style="margin-right:15px;font-size:13px" >Log</span> \
                        <input placeholder="Filter" style="width:150px;height:18px;" type="search" name="log_filter" incremental autocomplete="off">\
                        <button style="width:30px;height:18px;" id="timeline" onclick="open_timeline()" class="icon-logviewer-menu"><span class="mdi mdi-history"></span></button>\
                        <input type="checkbox" name="toggle_hide_all" onclick="toggle_hide_all(this)" checked=true>All\
                        <button class="btn icon-logviewer-menu" style="float: right;margin-top:4px" name="b_undock" onclick="toggleLogViewerDock()"><span class="mdi mdi-eject"></span></button> \
                        ');
    //mainLayout.cells("c").showInnerScroll();
    mainLayout.cells("c").attachObject("log_div"); //for json_to_table
    //todo: on btnclick, hide minfo und ffprobe: set height 10px und display:inline-block
    mainLayout.cells("a").setWidth(400);
    mainLayout.cells("a").setText('Info');

    //SIZES
    mainLayout.cells("b").setWidth($(document).width() / 2);
    //mainLayout.cells("c").setText("Finished");
    mainLayout.cells("a").setHeight($(document).height() / 2);
    restoreLayoutSizes(mainLayout, "mainLayout");
    mainLayout.attachEvent("onPanelResizeFinish", function () {
        saveLayoutSizes(mainLayout, "mainLayout");
    });

    /* undock logviewer stuff*/
    window.toggleLogViewerDock = toggleLogViewerDock;
    function toggleLogViewerDock(){
        if (window._undockedWin){
                delete window._undockedWin;
                mainLayout.cells('c').dock();
                document.getElementById("log_div").style.overflow = "scroll";
                return;
        }
        mainLayout.cells("c").undock();
    }
    mainLayout.attachEvent("onUndock", function (name) {
        document.getElementById("log_div").style.overflow = "unset"; //logdiv needs scroll when docked but not when undocked
        window._undockedWin = mainLayout.dhxWins.window(name);
        _undockedWin.setDimension($(document).width() / 1.2, $(document).height() / 1.2);
        _undockedWin.center();
    });

    /* contineue layout init */
    // var autoSizes = mainLayout.listAutoSizes();
    // console.log("Layout autosizes",autoSizes);
    
    //Left Layout
    
    let info_layout = mainLayout.cells("a").attachLayout("3E");
    info_layout.cells("a").setText('<button class="btn icon-logviewer-menu" style="float: right;margin-top:4px" name="b_undock" onclick="toggleGeneralDock()"><span class="mdi mdi-eject"></span></button>' +
        "<span id='general_text'>General</span>");
    info_layout.cells("a").attachHTMLString('<div id="general_div" style="height:100%;width:100%"/>');
    info_layout.cells("a").showInnerScroll();

    info_layout.cells("c").setText("Nodes");
    info_layout.cells("c").attachObject("node_div"); 
    info_layout.cells("c").showInnerScroll();   

    info_layout.cells("b").setText("Branches");
    info_layout.cells("b").attachHTMLString('<div id="branch_div" style=""/>');
    info_layout.cells("b").showInnerScroll();


    initBranchGrid();
    
    info_layout.attachEvent("onPanelResizeFinish", function () {
        saveLayoutSizes(info_layout, "info_layout");
    });
    restoreLayoutSizes(info_layout, "info_layout", true);
    
    info_layout.attachEvent("onUndock", function (name) {
        window._undockedGeneralWin = info_layout.dhxWins.window(name);
        _undockedGeneralWin.setDimension($(document).width() / 1.2, $(document).height() / 1.2);
        _undockedGeneralWin.center();
    });
    window.toggleGeneralDock = toggleGeneralDock;
    function toggleGeneralDock(){
        if (window._undockedGeneralWin){
                delete window._undockedGeneralWin;
                info_layout.cells('a').dock();
                return;
        }
        info_layout.cells("a").undock();
    }
}




async function refreshBranches(){
    //until job is finished, update list
    const response = await fetch(build_new_api_url("/getbranchlog?jobid=" + getQueryVariable("job_id")));
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    let data = await response.json(); // Assuming the response is JSON
    m_branchGrid.data.parse(data.branches);
    
}

function initBranchGrid(){
    //build grid and kick off data loading
    const columns = [
        {
            id: "name",
            header: [{ text: "ID" }],
            resizable: true,
            
        },
        {
            id: "object",
            header: [{ text: "Outcome" },],
            template: function(o_branch){
                let to_display = o_branch.result;
                to_display = o_branch.result.replaceAll(/\r|\n/g,"");
                return to_display
            },
           
        }
    ];

    //to add dhx8 grid to dhx5 layout, we trick a little, layout does not add any id that we can use for attaching grid, just create it:
    //document.getElementById("branch_div").parentElement.id = "attach_grid_here";
    //document.getElementById("branch_div").parentElement.style.width = "100%"
    m_branchGrid = new dhx8.dhx.Grid("branch_div", {
        columns,
        css: "alternate_row",
        keyNavigation: true,
        autoWidth:true,
        selection: "row",
        rowHeight: 20,
        headerRowHeight: 30,
        eventHandlers: {
            onclick: {
                
            },
        },
    });

    m_branchGrid.selection.events.on("AfterSelect", branchGridSelect);
    refreshBranches();
}

function getSelectedGridRows(grid){/*helper to find all selected rows*/
    let selcel = grid.selection.getCells();
    if (selcel.length == 0){
        let singlecel = grid.selection.getCell();
        if (!singlecel)
            return []
        selcel = [singlecel];//we dont use col
    }
    if (selcel)
        return selcel;
    else
        return []
}

async function branchGridSelect(row,col){
    let selcel = getSelectedGridRows(m_branchGrid);
    //put ticket to every option for later use in onclick
    let branchid = selcel[0].row.object.split_id;
    const response = await fetch(build_new_api_url("/getbranchlog?list_only=false&jobid=" + getQueryVariable("job_id") + "&branchid=" + branchid ));
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    let branchjson = await response.json(); // Assuming the response is JSON
    console.log("branch json downloaded:",branchjson);    
    
    //rebuild graph with empty cells could be optimized by reset existing graph
    m_unique_nodes = [];
    m_graph.destroy();
    document.getElementById('graphContainer').innerHTML = "";
    m_graph = null;
    buildMxGraph(document.getElementById('graphContainer'),m_workflowdata,false);

    //reload job log filtered by split_id, could be optimized by loading only branch log
    let a_nodeids = branchjson.branches[0].object.path.map(o=>{return o.id});
    let a_branchids = branchjson.branches[0].object.path.map(o=>{return o.split});
    get_job_log(getQueryVariable("job_id"),0,a_nodeids,a_branchids); 
}

google.load('visualization', '1.1', { packages: ['timeline'] }); //must be called before open_timeline() is called
function open_timeline() {
        /* log message frequency, only useful for steinar mostly */
    var myWins= new dhtmlXWindows();
    var win = myWins.createWindow("Timeline", 50, 50,  window.innerWidth - 50, 600);
    win.setText("Timeline");
    win.attachHTMLString('<div id="div_timeline"></div>');
    //google.setOnLoadCallback(open_timeline);
    //window.onresize = open_timeline;
    
            
        var container = document.getElementById('div_timeline');
        var chart = new google.visualization.Timeline(container);
        var data = new google.visualization.DataTable();
        
        data.addColumn({ type: 'string', id: 'RowLabel' });
        data.addColumn({ type: 'string', id: 'BarLabel' });
        data.addColumn({ type: 'string', role: 'tooltip', 'p': { 'html': true } });
        data.addColumn({ type: 'date', id: 'Start' });
        data.addColumn({ type: 'date', id: 'End' });
        console.log(m_timelineobject)
        data.addRows(m_timelineobject);

        // Hack from Stack Overflow to try and re-size the vertical extents of the chart to
        // avoid vertical scrolling. See http://stackoverflow.com/questions/18640818/google-charts-timeline-dynamic-height-with-scalebar-position
        // set a padding value to cover the height of title and axis values
        var paddingHeight = 40;
        // set the height to be covered by the rows
        var rowHeight = data.getNumberOfRows() * 45;
        // set the total chart height
        var estimatedHeight = rowHeight + paddingHeight;

        var options = {
            timeline: {
                showRowLabels: true,
                colorByRowLabel: true,
                rowLabelStyle: { fontName: 'Arial', color: '#FFFFFF' },
                barLabelStyle: { fontName: 'Arial' /* bar label color cannot be set viat the API */ }
            },
            backgroundColor: '#999999',
            avoidOverlappingGridLines: true,
            height: estimatedHeight,
            hAxis: {
                format: 'hh:mm:ss'
                },
        };

        chart.draw(data, options);
    

}

function toggle_hide_all(chkbox){
//show/hide content of log entry
    if (chkbox.checked){
        $( ".togglecontentvisible" ).prop("checked", true).trigger("change");
    }else{
        $( ".togglecontentvisible" ).prop("checked", false).trigger("change");
    }
}

function buildMxGraph(container,workflow_json,panning = true) { //panning allows dragging/moving the graph
    console.log("Graph conatiner id:",container.id)
    //set default box sizes as defined by ffastrans.au3
    var i_multiply = 4
    var i_BOX_WIDTH = 115 * i_multiply;
    var i_BOX_HEIGHT = i_BOX_WIDTH / 1.6;
    var i_POS_FACTOR = 1;
    console.log("workflow_json",workflow_json)
    if (workflow_json.variable) {
        //current zoom level stored in workflow.json
        if (workflow_json.variable.wf_size) {
            //i_BOX_WIDTH = (m_workflowdata["variable"]["wf_size"]);
            
            //at wf_size 115, the box width has to be 115, any other wf_size 
            i_POS_FACTOR = (workflow_json.variable.wf_size / 115 ) / i_multiply ;
        }
    }


    // Checks if the browser is supported
    if (!mxClient.isBrowserSupported()) {
        // Displays an error message if the browser is not supported.
        mxUtils.error('Browser is not supported!', 200, false);
    } else {
        // Disables the built-in context menu
        mxEvent.disableContextMenu(container);

        // Creates the graph inside the given container
        var graph = new mxGraph(container);
        graph.autoExtend=true;
        graph.border = 50;
        //graph.resizeContainer=true;
        m_graphs_by_container_id[container.id] = graph;
        if (!m_graph) //first graph becomes main graph, html buttons work with it...
            m_graph = graph; 

        graph.setHtmlLabels(true);
        graph.panningHandler.ignoreCell = true; //disables selection of a single cell but instead allow moving the whole graph
        graph.setPanning(panning); 
        if (!panning)
            graph.useScrollbarsForPanning = true;
        //     evt.preventDefault();
        //     evt.consume();
        // });

        
        //mxPanningHandler(graph);
        graph.setCellsMovable(false)
        graph.setCellsSelectable(false)
        //trackColor = new mxCellTracker(graph, "#666");
        
        graph.getLabel = function (cell) { //takes care of the table styling and inserts ffastrans values into the cells
            if (this.getModel().isVertex(cell) && cell.ffastransobj) {
                if (cell.value == "zoom"){
                    return "";
                }
                //calculate the text to display on canvas
                var FF_NODE_TITLE   = escapeXml(cell.ffastransobj["name"] || cell.ffastransobj["type"]);
                var FF_NODE_DESC    = escapeXml(cell.ffastransobj["description"] || "");
                var FF_NODE_ID      = cell.ffastransobj["id"].toUpperCase();
                var FF_NODE_TYPE    = cell.ffastransobj["type"];

                //create the cell style
                if (this.isCellCollapsed(cell))//we dont support collapsing
                    return;
                
                window.subWfCtrlBtnClick = function(evt,clickedEle){
                    //onmousedown="event.preventDefault();event.stopPropagation();onmouseup="event.preventDefault();event.stopPropagation();";ondblclick="event.preventDefault();event.stopPropagation();"
                    event.preventDefault();
                    event.stopPropagation();
                    let graphid = clickedEle.dataset.wfContainer;
                    let action  = clickedEle.attributes.name.value;
                    if (action == "undock"){
                        //emit dblclick on parent triggers dhxwindow open
                        const event = new MouseEvent('dblclick', {bubbles: true,cancelable: true});
                        clickedEle.parentElement.dispatchEvent(event);
                    }
                    else{
                        m_graphs_by_container_id[graphid][action]();
                    }

                }
                //base cell obj
                let sub_wf_btns = `<div class="sub_wf_ctrl_icons">`+
                        `<span onclick="subWfCtrlBtnClick(event,this)" ondblclick="event.stopPropagation();" data-wf-container="${FF_NODE_ID}_description_container" class="mdi mdi-plus"               name="zoomIn"></span>`+
                        `<span onclick="subWfCtrlBtnClick(event,this)" ondblclick="event.stopPropagation();" data-wf-container="${FF_NODE_ID}_description_container" class="mdi mdi-minus"              name="zoomOut"></span>`+
                        `<span onclick="subWfCtrlBtnClick(event,this)" ondblclick="event.stopPropagation();" data-wf-container="${FF_NODE_ID}_description_container" class="mdi mdi-arrow-collapse-all" name="fit"></span>` + 
                        `<span onclick="subWfCtrlBtnClick(event,this)" ondblclick="event.stopPropagation();" data-wf-container="${FF_NODE_ID}_description_container" class="mdi mdi-dock-window"        name="undock"></span>` + 
                    `</div>`;
                if (FF_NODE_TYPE != "sub_wf")
                    sub_wf_btns = "";
                
                var tbl = '<div class="div_ffastrans_processor_container" style="overflow:hidden;width:' + i_BOX_WIDTH + 'px;height:' + i_BOX_HEIGHT + 'px;max-height:' + i_BOX_HEIGHT + 'px">' +
                            '<table name="gui_node" style="table-layout:fixed;width:' + i_BOX_WIDTH + 'px;height:' + i_BOX_HEIGHT + 'px" ' +
                            'class="table_ffastrans_processor_disabled" id = "' + FF_NODE_ID + '" > ' +
                            '<tr class="tr_ffastrans_processor_top" >' +
                                `<th width="100%" title="'${FF_NODE_TITLE}'"><span id="${FF_NODE_ID}_exec_count" class="exec_count" title="Execution Counter">0</span><div><span>` + FF_NODE_TITLE + "</span>" +
                                        '</div>' + sub_wf_btns + '</th>'+
                            '</tr>' +
                            `<tr style="font-size:8px" title="${FF_NODE_DESC}" id="${FF_NODE_ID}_tr_container">`+
                                `<th class="tr_ffastrans_processor_desc" id="${FF_NODE_ID}_body">` + 
                                //this div is needed to control sub-workflow scrolling/overflow
                                `<div id="${FF_NODE_ID}_description_container" class="div_ffastrans_processor_desc overflow_auto" style="max-height:${i_BOX_HEIGHT/100*72}px;width:100%;">`+
                                    FF_NODE_DESC +
                                '</div>' +
                                
                                    //here goes the sub-workflow canvas svg(or processor desc)
                                
                            '</th></tr>' 
                            
                            

                            
                            '</table></div>';
                    
                return tbl;
                
            } else {
                return '';
            }
        };
        

        graph.addListener(mxEvent.DOUBLE_CLICK, async function (sender, evt) {
            //window for sub-wf
            console.log("sender",sender)
            var cell = evt.getProperty("cell"); // cell may be null
            if (cell == null) return
            if (!cell.ffastransobj) return
            if (!cell.ffastransobj.type == "sub_wf") return
            if (!cell.ffastransobj.properties.workflow_id) return
            evt.consume(); //mxgraph stuff
            //we get a reference to graph object of the currently selected sub_wf this way:
            let currentGraph = m_graphs_by_container_id[cell.ffastransobj.id.toUpperCase() + "_description_container"];
            currentGraph.fit();
            let swf_id = cell.ffastransobj.properties.workflow_id;
            
            const dhxWindow = new dhx8.dhx.Window({
                width: 640,
                height: 420,
                title: cell.ffastransobj.name,
                modal: false,
                closable: true,
                movable: true,
                resizable:true
            });

            const windowHTML = "<div id='window_"+swf_id+"' style='width:100%;height:100%'></div>";
            dhxWindow.attachHTML(windowHTML);
            dhxWindow.header.data.add({icon: "mdi mdi-plus", id: "plus"}, 2);
            dhxWindow.header.data.add({icon: "mdi mdi-minus", id: "minus"}, 3);
            dhxWindow.header.data.add({icon: "mdi mdi-arrow-collapse-all", id: "center"}, 4);
            dhxWindow.show();

            console.log("Doubleclick evt",cell.ffastransobj);
            await dhx8.dhx.awaitRedraw();
            let sub_wf_json = m_workflows.filter(wf => wf.wf_id == swf_id);
            let subwf_element = document.getElementById("window_"+swf_id);  
            console.log("subwf_element",subwf_element);
            
            //move sub-wf graph from processor to window
            let original_container = document.getElementById(cell.ffastransobj.id.toUpperCase() + "_body");
            let sub_wf_graph_ele = original_container.firstChild;
            let newParent = document.getElementById("window_"+swf_id);  
            newParent.appendChild(sub_wf_graph_ele); // Moves the element to the new container
            
            //must reset max-height prop 
            let original_height = sub_wf_graph_ele.style.maxHeight;
            sub_wf_graph_ele.style.maxHeight = "100%";
            sub_wf_graph_ele.classList.toggle('overflow_auto');
            sub_wf_graph_ele.classList.toggle('overflow_hidden');
            
            let isFullScreen;
            //window control icon click
            dhxWindow.header.events.on("click", function (id) {
                if (id === "plus") 
                    currentGraph.zoomIn();
                if (id === "minus") 
                    currentGraph.zoomOut();      
                if (id === "center") 
                    currentGraph.fit();                  
            });
            
            //window close
            dhxWindow.events.on("beforeHide", function(position, events){
                //bring back the canvas from window into processor description body
                original_container.appendChild(sub_wf_graph_ele);
                sub_wf_graph_ele.style.maxHeight = original_height;
                sub_wf_graph_ele.classList.toggle('overflow_auto');
                sub_wf_graph_ele.classList.toggle('overflow_hidden');
                return true;
            });

        });

        graph.addListener(mxEvent.CLICK, mxUtils.bind(graph, function (sender, evt) { 
            if (evt.properties.event.defaultPrevented)//it was a drag
                return;
            var cell = evt.getProperty("cell");

            if (!cell){ //click on canvas
                filterLogByNodeId();
                return;
            }

            console.log("detected mouseclick on cell",cell)
            if (cell.ffastransobj.type == "sub_wf")
                return // if click on node in sub-wf, prevents that we show log only of workflow proc
            let nodeId = cell["ffastransobj"]["id"].toUpperCase();
            
            filterLogByNodeId(nodeId);

            evt.consume();
        }));

        //BUILD THE GRAPH
        // Gets the default parent for inserting new cells. This
        // is normally the first child of the root (ie. layer 0).
        var parent = graph.getDefaultParent();
        // Adds cells to the model in a single step
        graph.getModel().beginUpdate();
        try {
            var style = graph.getStylesheet().getDefaultVertexStyle()
            style[mxConstants.STYLE_FONTSIZE] = '10';
            style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
            mxConstants["CURSOR_MOVABLE_VERTEX"] =  "pointer";
            mxConstants["CURSOR_MOVABLE_EDGE"] =  "auto";

            //var estyle = graph.getStylesheet().getDefaultEdgeStyle();
            //estyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.SegmentConnector; //OrthConnector,SegmentConnector

            var connections = []; //build an object used to create the connections between the nodes
            //parse ffastrans workflow json
            var nodes = workflow_json["nodes"];
            var wf_size = workflow_json["variable"]["wf_size"];
            
            for (var key in nodes) {
                var x = nodes[key]["pos_x"] / i_POS_FACTOR;
                var y = nodes[key]["pos_y"] / i_POS_FACTOR;
                //i_BOX_WIDTH


                /*width and heigth are defined in ffastrans as 115 and 1.6 aspect ratio. Fontsize as $i_BOX_WIDTH / 15 */
                var v1 = graph.insertVertex(parent, nodes[key]["id"].toUpperCase(), '', x, y, i_BOX_WIDTH, i_BOX_HEIGHT, 'strokeColor=rgb(85,85,85,0);fillColor=rgb(184,184,184,0)');
                nodes[key].originalname = key; //expand ffastrans properties by name of processor
                v1.ffastransobj = nodes[key];
                v1.data = new CustomData('v1'); //TODO: fill with useful data?
                connections.push({
                    "from": nodes[key]["id"].toUpperCase(),
                    "to": nodes[key].outbounds || []
                })

            }
            
            //create node connections

            for (let i = 0; i < connections.length; i++) {
                var from_id = (connections[i]["from"]);
                var from_cell = graph.getModel().getCell(from_id);
                var to_array = connections[i]["to"];
                for (let t = 0; t < to_array.length; t++) {
                    //for each target, create connection arrow
                    try {
                        var to_cell = graph.getModel().getCell(to_array[t]["id"].toUpperCase());
                        console.log(to_cell.ffastransobj["execute_on"])
                        if (to_cell.ffastransobj["execute_on"] == "success") {
                            var color = "rgb(0,200,0)"; //execute_on success color
                        }
                        if (to_cell.ffastransobj["execute_on"] == "error") {
                            color = "rgb(200,0,0)"; //execute_on error color
                        }
                        if (to_cell.ffastransobj["execute_on"] == "any") {
                            color = "rgb(255,200,0)"; //execute_on always color
                        }
                    } catch (ex) {
                        dhtmlx.message("Could not create connection for node " + to_array[t]["id"]);
                        console.log("Could not create connection for node " + to_array[t]["id"]);

                    }
                    //INSERT ARROW; ARROW STYLE
                    var edge = graph.insertEdge(parent, null, '', from_cell, to_cell, "strokeOpacity=45;fillOpacity=45;strokeColor=" + color + ";strokeWidth=2");
                }
            }
        }
        finally {
            // Updates the display, fullscreen zoom graph
            graph.getModel().endUpdate();

            graph.fit(); //(	border,keepOrigin,margin,enabled,ignoreWidth,ignoreHeight,maxHeight	)

            //on initial workflow show, zoom out but only if not sub-wf
            
            //graph.zoomOut();

            //mxutils.bind passes the current graph instance to the event function as "this". Needed to check which graph is scrolled
            mxEvent.addMouseWheelListener(mxUtils.bind(graph, function(evt, up)
            {   //zoom on mousewheel event
                //this scroll event is fired whenever the user scrolls on the page even outside the graph or over another graph
                //that means the event is fired multiple times when the user scrolls. With this method we find out if the scroll "target" is part of the graph that has been stored as this by mxUtils.bind

                let graph  = this;

                if (this.container && !this.container.contains(evt.target)){ //if ! graph container contains a child scroll matching event target
                    return
                }

                if (mxEvent.isConsumed(evt)) {
                    return;
                }

                var gridEnabled = graph.gridEnabled;
                // disable snapping
                graph.gridEnabled = false;
                var p1 = graph.getPointForEvent(evt, false);
                if (up) {
                    graph.zoomIn();
                } else {
                    graph.zoomOut();
                }
                var p2 = graph.getPointForEvent(evt, false);
                var deltaX = p2.x - p1.x;
                var deltaY = p2.y - p1.y;
                var view = graph.view;
                view.setTranslate(view.translate.x + deltaX, view.translate.y + deltaY);
                graph.gridEnabled = gridEnabled;
                mxEvent.consume(evt);
                
                return;
                
            }))
        }
    }
};


function filterLogByNodeId(nodeId){
    /* visually filters log  */
    var tree = $("#treetable_log").fancytree('getTree');
    toggleNodeSelected(nodeId);

    if (!nodeId){
        tree.clearFilter();
        return;
    }

    tree.filterNodes(function (node) {
        if (node["data"]["node"]["id"]){
            
            if (node["data"]["node"]["id"].toUpperCase().match(nodeId)) {
                //node.titleWithHighlight = "<mark>" + node.title + "</mark>";
                return true;
            }else{
                return false;
            }
        }
    }, {
        mode: "hide"
    });
}
            

function CustomData(value) {
    this.value = value;
}

function copy_style_for_svg(ParentNode, OrigData){
    var Children = ParentNode.childNodes;
    var OrigChildDat = OrigData.childNodes;     
    var ContainerElements = ["svg","g"];
    
    for (var cd = 0; cd < Children.length; cd++){
        var Child = Children[cd];

        var TagName = Child.tagName;
        if (ContainerElements.indexOf(TagName) != -1){
            copy_style_for_svg(Child, OrigChildDat[cd])
        } else if (TagName){
            var StyleDef = window.getComputedStyle(OrigChildDat[cd]);
            var StyleString = "";
            for (var st = 0; st < StyleDef.length; st++){
                StyleString += StyleDef[st] + ":" + StyleDef.getPropertyValue(StyleDef[st]) + "; ";
            }
            Child.setAttribute("style",StyleString);
            copy_style_for_svg(Child, OrigChildDat[cd])
        }
    }
}

function export_StyledSVG(){
    var SVGElem = document.getElementsByTagName("svg")[0];
    var exportname = (m_workflowdata["wf_name"] + "_" + m_jobobject["id"] + ".svg");
    var oDOM = SVGElem.cloneNode(true)
    copy_style_for_svg(oDOM, SVGElem);
    var data = new XMLSerializer().serializeToString(oDOM);
    var svg = new Blob([data], { type: "data:application/octet-stream;charset=utf-8" });
    var url = URL.createObjectURL(svg);
    var link = document.createElement("a");
    link.setAttribute('download', exportname);
    var Text = document.createTextNode("Export");
    link.appendChild(Text);
    link.href=url;
    document.body.appendChild(link);
    link.click();
}
 
async function parseJobLog(lines) {
    var a_log_per_node = {};
    var id_pid_mapping = {};
    var sub_workflow_is_loading = false;

    for (var i = 0; i < lines.length; i++) {
        var _proc_id;
        var line = lines[i];
        try {
            //m_timelineobject = [];
            //['Group1', 'Item1', 'this is a tooltip for Item1.cpp', new Date(1485183398349.28) /* 2017-01-23 14:56:38.349 */, new Date(1485183403210.01) /* 2017-01-23 14:56:43.210 */],
            try{
                var timeline_entry = [line["event"],line["node"]["type"],"",new Date(Date.parse(line["created"].replace(/..\.00$/,"00:00"))),new Date(Date.parse(line["created"].replace(/..\.00$/,"00:00")) +1 )];
                //var timeline_entry = ['Group1', 'Item1',"",new Date(1485183398349.28),new Date(1485183398359.28)];
                
                m_timelineobject.push(timeline_entry)
            }catch(ex){
                console.log("error parsing log line for timeline")
            }
            
            //start of new node log

            //handle sub-wf

            if (line["node"]["type"] == "sub_wf" && line['data'] != null ){
                
                if (m_subWorkflows[line["node"]["id"]]){
                    continue;
                }

                console.log("Sub wf detected, loadinhg json");
                if (line['data']['wf_id']){
                    m_subWorkflows[line["node"]["id"]] = line['data']['wf_id'];
                    var _subwfdiv = document.getElementById(line["node"]["id"].toUpperCase()+"_body").firstChild;
                    _subwfdiv.style.backgroundColor ="white";
                    
                    //refresh job infos by ajaxing getjobdetails, the new sub-workflow should be already there
                    //load current sub-workflows
                    var _url = "/getjobdetails?jobid=" + getQueryVariable("job_id");
                    
                    sub_workflow_is_loading = true;
                    $.ajax({
                        url: build_new_api_url(_url),
                        type: "GET",
                        crossDomain: true,
                        dataType: "json",
                        context: this,
                        beforeSend:function( jqXHR ){
                            jqXHR.wf_id = line['data']['wf_id'];
                        },
                        success: function (response,status,jqXHR) {
                            try{
                                console.log("Sub wf json ready")
                                jqXHR["wf_id"];
                                var sub_wf_json = response['workflows'][jqXHR["wf_id"]];
                                m_workflows.push(sub_wf_json);
                                buildMxGraph(_subwfdiv,sub_wf_json,false);
                                
                                //buildMxGraph(document.getElementById("graphContainer2"),sub_wf_json,true);
                                
                            }catch(ex){
                                alert("There was a problem getting subworkflow data, contact developers");
                            }
                            sub_workflow_is_loading = false;

                        },
                        error: function (xhr, status) {
                            sub_workflow_is_loading = false;
                            alert("ERROR getting workflow of job " + getQueryVariable("job_id") + ", please check FFAStrans Path in Admin settings on the left.. ");
                        }
                    }); 
                }
            }
            
            //wait until sub-wf is drawn in order to guarantee the nodes are already there
            while (sub_workflow_is_loading){
                await asyncsleep(1000)
            }
                                
            //check if node is unique for nodegrid
            var new_key = line["node"]["id"] + line["split_id"]
            _proc_id = line["node"]["id"].toUpperCase();
            id_pid_mapping[line["pid"]] = _proc_id;

            //show processor as enabled on ui
            a_log_per_node[_proc_id] = [];
            $("#" + _proc_id).removeClass("table_ffastrans_processor_disabled");
            $("#" + _proc_id).addClass("table_ffastrans_processor_enabled");
            
            //check processor error state and count
            if (!m_unique_nodes[new_key]) {//this is the first log line with this processor on this branch
                m_unique_nodes[new_key] = (line);
                m_unique_nodes[new_key]["state"] = "running";
                //raise proc count on gui
                var _o_counter = $("#" + _proc_id + "_exec_count");//execution count
                
                console.log("_o_counter","#" + _proc_id + "_exec_count",_o_counter);
                _o_counter.html(parseInt(_o_counter[0].innerHTML) + 1)

                //progress-circle
                $("#" + _proc_id).parent().addClass("blinking-progress");

            }
            
            //check for processor end and state
            if (line["event"] == "node end") {
                m_unique_nodes[new_key]["date_end"] = line["created"];
                m_unique_nodes[new_key]["state"] = "success";
                $("#" + _proc_id).parent().removeClass("blinking-progress");

                //red border for errored nodes
                if (line["data"] != null) { //when this exists, we have a node in error
                    $("#" + _proc_id).parent().addClass("blinking-error");
                } 
            }

        } catch (ex) { }
        //sort the current line as accurate as possible
        if (line["pid"] != "undefined") { //we have a pid, perfect
            var id_from_pid = id_pid_mapping[line["pid"]];
            try{
                a_log_per_node[id_from_pid].push(line);
            }catch(ex){
                debug = true;
            }
        } else {
            //did not get pid, so cannot guarantee that this line belongs to the proc but it is the best we can do...
            a_log_per_node[_proc_id].push(line);
        }
    }
}

function buildLogGridGrid() {

    $("#treetable_log").fancytree({
        extensions: [ "filter","table",  "gridnav", "multi"],
        quicksearch: true,
        filter: {
            autoExpand: true, // Expand all branches that contain matches while filtered
            fuzzy: false,      // Match single characters in order, e.g. 'fb' will match 'FooBar'
            hideExpandedCounter: true,  // Hide counter badge if parent is expanded
            hideExpanders: false,       // Hide expanders if all child nodes are hidden by filter
            highlight: true,   // Highlight matches by wrapping inside <mark> tags
            leavesOnly: false, // Match end nodes only
            nodata: true,      // Display a 'no data' status node if result is empty
            mode: "dimm"       // Grayout unmatched nodes (pass "hide" to remove unmatched node instead)
        },
        icon: false,
        checkbox: false,
        titlesTabbable: true, // Add all node titles to TAB chain
        quicksearch: true,
        focusOnSelect: false,
        autoScroll: false,
        autoActivate: false,
        unselectable: true,
        activeVisible: false,
        multi: { //multiselct
            mode: "",
        },
        init: function (event, data) {
            $("input[name=log_filter]").keyup(function (e) {
                var n, tree = $("#treetable_log").fancytree('getTree');
                var match = $(this).val();
                n = tree.filterNodes(match, { mode: "hide" });
                opts = {}, filterFunc = tree.filterNodes;
                if (e && e.which === $.ui.keyCode.ESCAPE || $.trim(match) === "") {
                    tree.clearFilter();
                    return;
                }
                // Pass a string to perform case insensitive matching
                n = filterFunc.call(tree, match, opts);
            })
            //ENABLE RESIZE COLUMNS
            /*
            $("#treetable_log").colResizable({
                resizeMode: 'fit',
                hoverCursor: "col-resize",
                dragCursor: "col-resize",
                postbackSafe: true,
                useLocalStorage: true,
                minWidth: 10,
                liveDrag: true,
            });*/
        },
        modifyChild: function (event, data) {
            //reset all odd even row colors
            var rootNode = $("#treetable_log").fancytree("getRootNode");
            var oldnodes = rootNode.children;
            for (let i = 0; i < oldnodes.length; i++) {
                if (i % 2 == 0) {
                    oldnodes[i].toggleClass("ev_dhx_skyblue", true)
                    oldnodes[i].toggleClass("odd_dhx_skyblue", false)
                } else {
                    oldnodes[i].toggleClass("odd_dhx_skyblue", true)
                    oldnodes[i].toggleClass("ev_dhx_skyblue", false)
                }
            }
        },
        renderColumns: function (event, data) {
            
            var node = data.node;

            //style
            if (data.node.getIndex() % 2 == 0) {
                node.removeClass("odd_dhx_skyblue"); //apply dthmlx style to node
                node.addClass("ev_dhx_skyblue"); //apply dthmlx style to node
            } else {
                node.removeClass("ev_dhx_skyblue"); //apply dthmlx style to node
                node.addClass("odd_dhx_skyblue"); //apply dthmlx style to node
            }
            
            if ("node" in node["data"] == false){
                node["data"]["node"] = {}
                node["data"]["node"]["id"] = node["data"]["context"];
                
            }
            if (! "id" in node.data["node"]){
                return false;
            }

            var nodeid = node.data["node"]["id"];
            
            var nodename = getNodeNameById(nodeid);
            var created = node.data["created"];
            created = moment.parseZone(created.replace(/.00$/, ":00"))
            created = created.format("YYYY-MM-DD HH:mm:ss");

            $tdList = $(node.tr).find(">td");
            $tdList.eq(0).html("<div class='celltext'>" + nodename + "</div>");
            $tdList.eq(1).html("<div class='celltext'>" + created + "</div>");
            $tdList.eq(2).html("<div class='celltext'>" + node.data["host"] + "</div>");
            $tdList.eq(3).html("<div class='celltext'>" + node.data["split_id"] + "</div>");
            var evt_id = Math.random(1000000000);
            if (node.data["event"] == "_IPS_SRV_FFMon"){
                $tdList.eq(4).html("<div class='celltext' id='"+evt_id+"'><b>" + node.data["event"] + "</b></div>");
            }else{
                $tdList.eq(4).html("<div class='celltext' id='"+evt_id+"'>" + node.data["event"] + "</div>");
            }
            
            var table = (JsonHuman.format(data.node.data["_data"]));
            table.name = "bla"
            $tdList.eq(5).html(table);
            
            //create show/hide checkbox
            var xid = Math.random(100000000);
            var x = document.createElement("INPUT");
            x.setAttribute("type", "checkbox");
            x.setAttribute("checked", "true");
            x.setAttribute("class", "togglecontentvisible");
            x.style.float = "left";
            x.id = xid;
            x.name = node.data["event"];
            document.getElementById(evt_id).parentElement.insertBefore(x,document.getElementById(evt_id));
            x.onchange = function () { 
                            if (this.checked){
                                this.parentElement.nextElementSibling.style.display = ""
                            }else{
                                this.parentElement.nextElementSibling.style.display = "none"
                            }
                        
                        };
        },
        gridnav: {
            autofocusInput: false,
            handleCursorKeys: true
        },
        beforeSelect: function (event, data) { },

    });

    //search
    $("input[name=search]").on("change search", function (e) {
        if (e.type === "change" && e.target.onsearch !== undefined) {
            // We fall back to handling the change event only if the search event is not supported.
            return;
        }
        var n;
        var tree = $("#treetable_log").fancytree('getTree');
        match = $.trim($(this).val());
        // Pass a string to perform case insensitive matching
        var re = new RegExp(match, "i");

        tree.filterNodes(function (node) {
            if (JSON.stringify((node["data"]["_data"])).match(re)) {
                node.titleWithHighlight = "<mark>" + node.title + "</mark>";
                return true;
            }
        }, {
            mode: "hide"
        });
        // This will adjust the start value in case the filtered row set
        // is not inside the current viewport
        // tree.setViewport();
    });

}

function toggleNodeSelected(nodeid){
    //there can be only one node selected at a time. 
    $(".blinking-selected").removeClass("blinking-selected");
    if (nodeid)
        $("#" + nodeid).parent().addClass("blinking-selected");
}

function initNodeGrid() {
    console.log("initNodeGrid");
    
    const columns = [
        { id: "state",   header: [{ text: "State" }],       width:100 },
        { id: "name",    header: [{ text: "Name" }],                    },
        { id: "start",   header: [{ text: "Start" }],       width:100},
        { id: "duration",   header: [{ text: "Duration" }], width:100},
        { id: "host",    header: [{ text: "Host" }],   },
        { id: "branch",  header: [{ text: "Branch" }], },
        { id: "node_id",     header: [{ text: "ID" }], },
    ];

    const nodeGrid = new dhx8.dhx.Grid("node_div", {
        columns,
        css: "alternate_row",
        resizable: true,
        keyNavigation: true,
        autoWidth:true,
        adjust: true,
        selection: "row",
        rowHeight: 20,
        headerRowHeight: 30,
        eventHandlers: {
            onclick: {
              
            },
        },
    });
    nodeGrid.selection.events.on("AfterSelect", nodeGridSelect);

    function nodeGridSelect(data) {
        console.log("data",data);
        
        filterLogByNodeId(data.node_id.toUpperCase());
        toggleNodeSelected(data.node_id.toUpperCase());

        //check which graph contains the cell and center it
        Object.keys(m_graphs_by_container_id).forEach( key => {
            let g = m_graphs_by_container_id[key];
            let c = g.getModel().getCell(data.node_id.toUpperCase());
            if (c){
                g.scrollCellToVisible(c, true);
            }
            //todo: if this is a sub_wf, iterate back over all containing graphs and center the topmost one
        })
        
    }

    window.refreshNodeGrid = function(data){
        //transform data for dhxgrid easy loading, return obj state, node, start, host, branch
        data = data.map(o=>{
            let returnobj= {};
            returnobj.data    = o;
            returnobj.node_id    = o.node.id;
            returnobj.state = o.state;
            returnobj.name  = function(){
                if (o.node.name)
                    return o.node.name;
                else{
                    //try finding node name in workflow 
                    let _filt = m_workflowdata.nodes.filter(n=>{return n.id==o.node.id});
                    if (_filt.length > 0)
                        return _filt[0].name;
                    
                    return o.node.type;
                }
            }()
            returnobj.host  = o.host;
            returnobj.branch = o.split_id;
            try {
                let created = moment.parseZone(o["created"].replace(/.00$/, ":00"))
                let end = moment.parseZone(o["date_end"].replace(/.00$/, ":00"))
                returnobj.start     = created.format("HH:mm:ss");
                returnobj.duration  = end.diff(created, "seconds");
            } catch (ex) { }
            return returnobj;
        })

        console.log("refresNodeGrid",data);
        console.log("refresNodeGrid workflowdata",m_workflowdata);
        
        nodeGrid.data.parse(data);
    }

}



function getNodeNameById(id) {
    if (!id){
        return "SystemAA";
    }
    for (var _wf of m_workflows){
        var n = _wf.nodes.filter(function (obj) { return obj.id.toUpperCase() == id.toUpperCase(); });
        if (n.length != 1) { continue; }
        nodename = n[0].name || n[0].type;
        return nodename;
    }
    return "System";
}

function appendLogLines(proc_id, a_lines) {
    //checks if lines already exists (for running jobs) and updates log data of node
    graph.getModel().getCell(to_array[t]["id"])

}

function get_job_log(job_id, start=0, a_nodeid_filter, a_branchid_filter) { //branch_path is path field from finished branch json, array of node objects, they have id field which we filter
    start = typeof start !== 'undefined' ? start : 0;
    console.log("getjoblog START: " + start );
    //get all workflows from server  start main with the workflow of interest
    var _url = "/getjoblog?jobid=" + job_id+ "&start="+ start ;
    $.ajax({
        url: build_new_api_url(_url),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        success: async function (response,status,request) {
        
            //PARSE JOB LOG

            for (var a in response) {
                response[a]["_data"] = response[a]["data"];
            }

            if (a_nodeid_filter){
                //filter the log by nodeids specified
                response = response.filter(logline => a_nodeid_filter.indexOf(logline.node?.id) != -1);
            }
            if (a_branchid_filter){
                //filter log by branchid specified
                response = response.filter(logline => a_branchid_filter.indexOf(logline.split_id) != -1);
            }
            await parseJobLog(response);
            console.log("<<<parseJobLog")
            
            var type = request.getResponseHeader('ffastrans_log_type');
            if (type == "partial") {
                //if partial, set up another get_job_log call
                var _start = request.getResponseHeader('ffastrans_log_last_endpos');
                
                console.log("Job still running, getting next log lines from start: " + _start);
                window.setTimeout(function () { get_job_log(job_id, _start)}, 3000);
                var rootNode = $("#treetable_log").fancytree("getRootNode");
                rootNode.addChildren(response);
                $("#log_div").css("visibility", "visible");
            } else {
                //full log received
                var rootNode = $("#treetable_log").fancytree("getRootNode");
                rootNode.removeChildren();
                rootNode.addChildren(response); //code blocks here until tree is rendered. m_unique_nodes is filled by rendercolumns method of tree
                console.log("full log",response);
                $("#log_div").css("visibility", "visible");
            }


            //load data into node grid
            //var rootNode = $("#treetable_nodes").fancytree("getRootNode");
            

            //var nodetree = $("#treetable_nodes").fancytree("getTree");
            //rootNode.removeChildren();
            //turn m_unique_nodes to array
            var result = Object.keys(m_unique_nodes).map(function (key) {
                m_unique_nodes[key]["key"] = key;
                return m_unique_nodes[key];
            });
            /*result = result.filter(function (el) {
                return el != null;//filters empty entries from map function
            });*/
            
            //add nodegrid rows
            //rootNode.addChildren(result);
            //$("#node_div").css("visibility", "visible");
            refreshNodeGrid(result);

        },
        error: function (xhr, status) {
            alert("Did not get Log for job " + job_id);
        }
    });
}

function get_all_job_details(job_id) {
    //get all workflows from server and start main with the workflow of interest
    var _url = "/getjobdetails?jobid=" + job_id;
    $.ajax({
        url: build_new_api_url(_url),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        success: function (response) {
            if (response['wf_object'].length == 0) {
                alert("Did not get any workflows from FFASTRANS API");
            } else {
                m_jobobject = response;
                m_workflowdata = response['wf_object'];
                m_workflows.push(response['wf_object']);
                //populate top left data
                var copy = JSON.stringify(response);
                copy = JSON.parse(copy); //copy the whole object to be able to delete wf_object for display in general_div
                delete copy["wf_object"]; 
                delete copy["nodes"];
                delete copy["workflows"];
                delete copy["variables"];
                delete copy["finished"];
                //sort
                
                var table = (JsonHuman.format(copy));
                //render
                document.getElementById("general_div").appendChild(table);
                $("#general_text").text("General [" + response["workflow"]["name"] + "]");
                
                //populate workflow canvas
                buildMxGraph(document.getElementById('graphContainer'),m_workflowdata,false);//disable panning because we cannot determine if the drag happened outer or inner graph
                get_job_log(getQueryVariable("job_id")); //kicks off job log parsing on success
            }
        },
        error: function (xhr, status) {
            alert("ERROR getting workflow of job " + getQueryVariable("job_id") + ", please check FFAStrans Path in Admin settings on the left.. ");
        }
    });

}

/* SECTION HELPERS */
function getQueryVariable(variable) {
    var query = window.location.search.substring(1);
    var vars = query.split("&");
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split("=");
        if (pair[0] == variable) {
            return decodeURIComponent(pair[1]);
        }
    }
}

function asyncsleep(time) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve();
    }, time);
  });
}

function escapeXml(unsafe) {
    return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case '\'': return '&apos;';
            case '"': return '&quot;';
        }
    });
}

function _getObjectByValue(object, value) { //helper
    var to_return = [];
    for (var _idx in object){
        var _v =  object[_idx]["key"];
        if (_v == value){
        to_return.push(object[_idx]);
        }
    }
    return to_return;
}

function build_new_api_url(what) {
    if (JSON.parse(m_serverconfig['STATIC_USE_PROXY_URL'])) {
        return "/new_proxy" + what;
    } else {
        var protocol = m_serverconfig.STATIC_WEBSERVER_ENABLE_HTTPS == "true" ? "https://" : "http://";
        var _url = protocol + m_serverconfig['STATIC_API_HOST'] + ":" + m_serverconfig['STATIC_API_NEW_PORT'] + what;
        return _url;
    }
}

function saveLayoutSizes(dhxLayout, name) {
    //store layout cells height and with into html5 storage (in percentage of document height)
    var aw = (dhxLayout.cells("a").getWidth() / document.body.scrollWidth);
    var ah = (dhxLayout.cells("a").getHeight() / document.body.scrollHeight);
    var bw = (dhxLayout.cells("b").getWidth() / document.body.scrollWidth);
    var bh = (dhxLayout.cells("b").getHeight() / document.body.scrollHeight);
    localStorage.setItem(name + "_aw", aw);
    localStorage.setItem(name + "_ah", ah);
    localStorage.setItem(name + "_bw", bw);
    localStorage.setItem(name + "_bh", bh);

}

function restoreLayoutSizes(dhxLayout, name, ignore_width) {
    return; //TODO: disabled because usually the resize ended up in foobar
    if (localStorage.getItem(name + "_aw")) {
        console.log("restoring layout sizes, all stored values: ",localStorage)
        var aw = localStorage.getItem(name + "_aw");
        var ah = localStorage.getItem(name + "_ah");
        var bw = localStorage.getItem(name + "_bw");
        var bh = localStorage.getItem(name + "_bh");
        if (!ignore_width) {
            if (aw > 0.01 && aw < 0.9){
                dhxLayout.cells("a").setWidth(aw * document.body.scrollWidth);
                console.log("width restored cell a:", aw);
            }else{
                console.log("Width not restored, stored value was too low or too high: ", aw)
            }
            if (bw < 0.8){
                dhxLayout.cells("b").setWidth(bw * document.body.scrollWidth);
                console.log("width restored cell b:", bw);
            }
        }
        dhxLayout.cells("a").setHeight(ah * document.body.scrollHeight);
        dhxLayout.cells("b").setHeight(bh * document.body.scrollHeight);
        console.log("height restored")
    }
}

function buildUrl(what) {
    if (JSON.parse(m_serverconfig['STATIC_USE_PROXY_URL'])) {
        return "/proxy" + what;
    } else {
        var _url = "http://" + m_serverconfig['STATIC_API_HOST'] + ":" + m_serverconfig['STATIC_API_PORT'] + what;
        return _url;
    }
    //old, delete at next iteration
}

</script>
</head>

<!-- Page passes the container for the graph to the program -->
<body onload="loadserverconfig()">
<!-- <div style="max-width:20px;max-height:20px;height:20px;width:20px" id="parentofdeleteme" > -->
<!-- <div style="height:20px;width:20px" id="deleteme"/> -->
</div>
    <!-- THIS DIV Is just a template for log table design, it will be attached to dhtmlx layout at runtime -->
    <div id="log_div" style="visibility:visible;height:100%;overflow:scroll" class="gridbox_dhx_skyblue gridbox">
        <table id="treetable_log"  class="obj">
            <colgroup>
                <col width="7%"></col>
                <col width="10%"></col>
                <col width="10%"></col>
                <col width="10%"></col>
                <col width="15%"></col>
                <col width="50%"></col>
            </colgroup>
            <thead class="sticky " style="border:none">
                <tr class="">
                    <th class="sticky" style="font-weight:normal">Node</th>
                    <th class="sticky" style="font-weight:normal">Time</th>
                    <th class="sticky" style="font-weight:normal">Host</th>
                    <th class="sticky" style="font-weight:normal">Branch</th>
                    <th class="sticky" style="font-weight:normal">Event</th>
                    <th class="sticky" style="font-weight:normal">Data</th>
                </tr>
            </thead>
        </table>
    </div>

    <div id="node_div" style="border:none !important" class="gridbox_dhx_skyblue gridbox">
        <!-- <table id="treetable_nodes" class="obj">

            <thead class="sticky dhtmlxMenu_dhx_skyblue_Middle" style="height:20px;color: var(--dhx-font-color-primary);font-family: var(--dhx-font-family);font-weight:normal!important">
                <tr class="">
                    <th >State</th>
                    <th >Node</th>
                    <th >Duration</th>
                    <th >Start</th>
                    <th >Host</th>
                    <th >Branch</th>
                </tr>
            </thead>
        </table> -->
    </div>
<canvas id="invisible_export_helper"  style="display:none;width:1920px;height:1080px"></canvas>
</body>
</html>
