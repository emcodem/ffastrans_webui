{"version":3,"sources":["webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts","webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///./public/app/plugins/datasource/influxdb/types.ts","webpack:///./public/app/plugins/datasource/influxdb/components/FluxQueryEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VariableQueryEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/module.ts"],"names":["InfluxSeries","options","this","series","alias","annotation","meta","refId","i","j","output","length","_","each","columns","tags","map","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","target","index","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","list","titleCol","timeCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","title","flatten","filter","t","text","table","TableModel","seriesIndex","type","FieldType","keys","reordered","hasOwnProperty","rows","categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","QueryPart","register","QueryPartDef","category","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","functionRenderer","partCount","suffixRenderer","quote","renderMode","create","getCategories","replaceAggregationAdd","InfluxQueryModel","templateSrv","scopedVars","policy","resultFormat","orderByTime","groupBy","select","updateProjection","queryPart","groupByParts","find","g","stringParts","typePart","arg","s","modelsIndex","partIndex","updatePersistedParts","interpolate","str","operator","condition","test","measurement","variable","defaultFormatFn","multi","includeAll","kbn","regexEscape","rawQuery","interpolateQueryStr","y","selectText","render","getMeasurementAndPolicy","conditions","renderTagCondition","groupBySection","fill","limit","slimit","tz","filters","ResponseParser","results","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","serie","isArray","addUnique","undefined","toString","arr","InfluxVersion","InfluxQueryBuilder","database","withKey","withMeasurementFilter","whereConditions","reduce","memo","samples","label","description","FluxQueryEditor","onFluxQueryChange","props","onChange","onRunQuery","onSampleChange","val","forceUpdate","getSuggestions","sugs","kind","CodeEditorSuggestionItemKind","Property","detail","getTemplateSrv","getVariables","forEach","Text","editorDidMountCallbackHack","editor","setTimeout","layout","helpTooltip","height","language","onBlur","onSave","showMiniMap","showLineNumbers","onEditorDidMount","className","cx","css","icon","variant","href","width","tooltip","PureComponent","coreModule","directive","reactDirective","InfluxDatasource","instanceSettings","urls","url","trim","username","password","basicAuth","withCredentials","settingsData","jsonData","interval","timeInterval","httpMode","responseParser","isFlux","version","Flux","annotations","QueryEditor","request","classicQuery","timeFilter","getTimeFilter","targets","cloneDeep","queryTargets","allQueries","hide","__interval","acc","current","of","adhocFilters","getAdhocFilters","renderAdhocFilters","_seriesQuery","pipe","seriesList","result","executedQueryString","influxSeries","preferredVisualisationType","getTable","timeSeries","getTimeSeries","Promise","reject","rangeRaw","timezone","dashboard","toPromise","then","getAnnotations","param","variableExists","queries","expandedQueries","expandedQuery","datasource","rsp","frameToMetricFindValue","interpolated","resp","parse","queryBuilder","buildExploreQuery","metricFindQuery","range","_influxRequest","q","epoch","encodeURIComponent","requestId","id","uuidv4","dashboardId","panelId","intervalMs","maxDataPoints","from","dateTime","to","state","LoadingState","Done","console","error","status","first","catch","err","get","method","currentUrl","shift","u","p","db","has","extend","omit","serializeParams","pick","req","precision","inspect","paramSerializer","headers","Authorization","getBackendSrv","fetch","errors","elem","catchError","cancelled","throwError","handleErrors","Number","isInteger","config","statusText","getInfluxTime","until","fromIsAbsolute","date","roundUp","isString","exec","dateMath","valueOf","DataSourceWithBackend","InfluxQueryCtrl","$scope","$injector","uiSegmentSrv","panelCtrl","refresh","queryModel","panel","groupBySegment","newPlusButton","resultFormats","policySegment","newSegment","measurementSegment","newSelectMeasurement","tagSegments","newCondition","newKey","newOperator","newKeyValue","fixTagSegments","buildSelectMenu","removeTagFilterSegment","fake","selectMenu","cat","menu","submenu","item","hasFill","hasGroupByTime","handleQueryError","bind","addGroupBy","plusButton","html","subitem","addSelectPart","evt","fieldsQuery","transformToSegments","removeSelectPart","resolve","tagsQuery","removeGroupByPart","count","lastSegment","max","policiesQuery","measurementFilter","addTemplateVars","segment","expandable","unshift","nextValue","newOperators","angular","copy","newFake","cssClass","rebuildTargetTagConditions","tagIndex","tagOperator","segment2","getTagValueOperator","tagValue","QueryCtrl","templateUrl","CHEAT_SHEET_ITEMS","InfluxCheatSheet","InfluxStartPage","onClickExample","Select","LegacyForms","Input","SecretFormField","httpModes","versions","InfluxQL","ConfigEditor","maxSeries","onResetPassword","updateDatasourcePluginResetOption","onResetToken","onVersionChanged","selected","onOptionsChange","access","user","secureJsonFields","secureJsonData","organization","onUpdateDatasourceJsonDataOption","isConfigured","token","labelWidth","inputWidth","onReset","onUpdateDatasourceSecureJsonDataOption","placeholder","defaultBucket","onUpdateDatasourceOption","defaultValue","onUpdateDatasourceJsonDataOptionSelect","showAccessOptions","dataSourceConfig","defaultUrl","renderInflux2x","renderInflux1x","event","setState","currentTarget","updateDatasourcePluginJsonDataOption","isFinite","VariableQueryEditor","onRefresh","v","e","InfluxAnnotationsQueryCtrl","plugin","DataSourcePlugin","setConfigEditor","setQueryCtrl","setAnnotationQueryCtrl","setVariableQueryEditor","setQueryEditorHelp"],"mappings":"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","file":"influxdbPlugin.63a9c1d648180e457252.js","sourcesContent":["import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { FieldType, QueryResultMeta, TimeSeries, TableData } from '@grafana/data';\n\nexport default class InfluxSeries {\n  refId?: string;\n  series: any;\n  alias: any;\n  annotation: any;\n  meta?: QueryResultMeta;\n\n  constructor(options: { series: any; alias?: any; annotation?: any; meta?: QueryResultMeta; refId?: string }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n    this.meta = options.meta;\n    this.refId = options.refId;\n  }\n\n  getTimeSeries(): TimeSeries[] {\n    const output: TimeSeries[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    _.each(this.series, (series) => {\n      const columns = series.columns.length;\n      const tags = _.map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints, meta: this.meta, refId: this.refId });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    _.each(this.series, (series) => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      _.each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      _.each(series.values, (value) => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: _.flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable(): TableData {\n    const table = new TableModel();\n    let i, j;\n\n    table.refId = this.refId;\n    table.meta = this.meta;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    _.each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        j = 0;\n        // Check that the first column is indeed 'time'\n        if (series.columns[0] === 'time') {\n          // Push this now before the tags and with the right type\n          table.columns.push({ text: 'Time', type: FieldType.time });\n          j++;\n        }\n        _.each(_.keys(series.tags), (key) => {\n          table.columns.push({ text: key });\n        });\n        for (; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import _ from 'lodash';\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = _.map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: _.clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import _ from 'lodash';\nimport queryPart from './query_part';\nimport kbn from 'app/core/utils/kbn';\nimport { InfluxQuery, InfluxQueryTag } from './types';\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId?: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [\n      { type: 'time', params: ['$__interval'] },\n      { type: 'fill', params: ['null'] },\n    ];\n    target.select = target.select || [\n      [\n        { type: 'field', params: ['value'] },\n        { type: 'mean', params: [] },\n      ],\n    ];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = _.map(this.target.select, (parts: any) => {\n      return _.map(parts, queryPart.create);\n    });\n    this.groupByParts = _.map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = _.map(this.selectModels, (selectParts) => {\n      return _.map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    let stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n\n    if (!stringParts || !this.target.groupBy) {\n      return;\n    }\n\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = _.filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = _.map(this.target.select, (s: any) => {\n        return _.filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = _.indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = _.indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate?: boolean) {\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = _.map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = _.map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = _.map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import _ from 'lodash';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = {};\n    _.each(influxResults.series, (serie) => {\n      _.each(serie.values, (value) => {\n        if (_.isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versions—first).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // @ts-ignore problems with typings for this _.map only accepts [] but this needs to be object\n    return _.map(res, (value) => {\n      // @ts-ignore\n      return { text: value.toString() };\n    });\n  }\n}\n\nfunction addUnique(arr: { [x: string]: any }, value: string | number) {\n  arr[value] = value;\n}\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string): string {\n    let query = '';\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        query += ' WITH MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = _.reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n\n          // value operators not supported in these types of queries\n          if (tag.operator === '>' || tag.operator === '<') {\n            return memo;\n          }\n\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        [] as string[]\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n\n    return query;\n  }\n}\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\n\nexport enum InfluxVersion {\n  InfluxQL = 'InfluxQL',\n  Flux = 'Flux',\n}\n\nexport interface InfluxOptions extends DataSourceJsonData {\n  version?: InfluxVersion;\n\n  timeInterval: string;\n  httpMode: string;\n\n  // With Flux\n  organization?: string;\n  defaultBucket?: string;\n  maxSeries?: number;\n}\n\nexport interface InfluxSecureJsonData {\n  // For Flux\n  token?: string;\n\n  // In 1x a different password can be sent than then HTTP auth\n  password?: string;\n}\n\nexport interface InfluxQueryPart {\n  type: string;\n  params?: string[];\n  interval?: string;\n}\n\nexport interface InfluxQueryTag {\n  key: string;\n  operator?: string;\n  condition?: string;\n  value: string;\n}\n\nexport interface InfluxQuery extends DataQuery {\n  policy?: string;\n  measurement?: string;\n  resultFormat?: 'time_series' | 'table';\n  orderByTime?: string;\n  tags?: InfluxQueryTag[];\n  groupBy?: InfluxQueryPart[];\n  select?: InfluxQueryPart[][];\n  limit?: string;\n  slimit?: string;\n  tz?: string;\n  fill?: string;\n  rawQuery?: boolean;\n  query?: string;\n}\n","import React, { PureComponent } from 'react';\nimport coreModule from 'app/core/core_module';\nimport { InfluxQuery } from '../types';\nimport { SelectableValue, QueryEditorProps } from '@grafana/data';\nimport { cx, css } from 'emotion';\nimport {\n  InlineFormLabel,\n  LinkButton,\n  Segment,\n  CodeEditor,\n  CodeEditorSuggestionItem,\n  CodeEditorSuggestionItemKind,\n} from '@grafana/ui';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport InfluxDatasource from '../datasource';\n\n// @ts-ignore -- complicated since the datasource is not really reactified yet!\ntype Props = QueryEditorProps<InfluxDatasource, InfluxQuery>;\n\nconst samples: Array<SelectableValue<string>> = [\n  { label: 'Show buckets', description: 'List the available buckets (table)', value: 'buckets()' },\n  {\n    label: 'Simple query',\n    description: 'filter by measurement and field',\n    value: `from(bucket: \"db/rp\")\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> filter(fn: (r) =>\n    r._measurement == \"example-measurement\" and\n    r._field == \"example-field\"\n  )`,\n  },\n  {\n    label: 'Grouped Query',\n    description: 'Group by (min/max/sum/median)',\n    value: `// v.windowPeriod is a variable referring to the current optimized window period (currently: $interval)\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"measurement1\" or r[\"_measurement\"] =~ /^.*?regex.*$/)\n  |> filter(fn: (r) => r[\"_field\"] == \"field2\" or r[\"_field\"] =~ /^.*?regex.*$/)\n  |> aggregateWindow(every: v.windowPeriod, fn: mean|median|max|count|derivative|sum)\n  |> yield(name: \"some-name\")`,\n  },\n  {\n    label: 'Filter by value',\n    description: 'Results between a min/max',\n    value: `// v.bucket, v.timeRangeStart, and v.timeRange stop are all variables supported by the flux plugin and influxdb\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_value\"] >= 10 and r[\"_value\"] <= 20)`,\n  },\n  {\n    label: 'Schema Exploration: (measurements)',\n    description: 'Get a list of measurement using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.measurements(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (fields)',\n    description: 'Return every possible key in a single table',\n    value: `from(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> keys()\n  |> keep(columns: [\"_value\"])\n  |> group()\n  |> distinct()`,\n  },\n  {\n    label: 'Schema Exploration: (tag keys)',\n    description: 'Get a list of tag keys using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagKeys(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (tag values)',\n    description: 'Get a list of tag values using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagValues(\n    bucket: v.bucket,\n    tag: \"host\",\n    predicate: (r) => true,\n    start: -1d\n)`,\n  },\n];\n\nexport class FluxQueryEditor extends PureComponent<Props> {\n  onFluxQueryChange = (query: string) => {\n    this.props.onChange({ ...this.props.query, query });\n    this.props.onRunQuery();\n  };\n\n  onSampleChange = (val: SelectableValue<string>) => {\n    this.props.onChange({\n      ...this.props.query,\n      query: val.value!,\n    });\n\n    // Angular HACK: Since the target does not actually change!\n    this.forceUpdate();\n    this.props.onRunQuery();\n  };\n\n  getSuggestions = (): CodeEditorSuggestionItem[] => {\n    const sugs: CodeEditorSuggestionItem[] = [\n      {\n        label: 'v.timeRangeStart',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The start time',\n      },\n      {\n        label: 'v.timeRangeStop',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The stop time',\n      },\n      {\n        label: 'v.windowPeriod',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'based on max data points',\n      },\n      {\n        label: 'v.defaultBucket',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'bucket configured in the datsource',\n      },\n      {\n        label: 'v.organization',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'org configured for the datsource',\n      },\n    ];\n\n    const templateSrv = getTemplateSrv();\n    templateSrv.getVariables().forEach((variable) => {\n      const label = '${' + variable.name + '}';\n      let val = templateSrv.replace(label);\n      if (val === label) {\n        val = '';\n      }\n      sugs.push({\n        label,\n        kind: CodeEditorSuggestionItemKind.Text,\n        detail: `(Template Variable) ${val}`,\n      });\n    });\n\n    return sugs;\n  };\n\n  // For some reason in angular, when this component gets re-mounted, the width\n  // is not set properly.  This forces the layout shortly after mount so that it\n  // displays OK.  Note: this is not an issue when used directly in react\n  editorDidMountCallbackHack = (editor: any) => {\n    setTimeout(() => editor.layout(), 100);\n  };\n\n  render() {\n    const { query } = this.props;\n\n    const helpTooltip = (\n      <div>\n        Type: <i>ctrl+space</i> to show template variable suggestions <br />\n        Many queries can be copied from chronograph\n      </div>\n    );\n\n    return (\n      <>\n        <CodeEditor\n          height={'200px'}\n          language=\"sql\"\n          value={query.query || ''}\n          onBlur={this.onFluxQueryChange}\n          onSave={this.onFluxQueryChange}\n          showMiniMap={false}\n          showLineNumbers={true}\n          getSuggestions={this.getSuggestions}\n          onEditorDidMount={this.editorDidMountCallbackHack}\n        />\n        <div\n          className={cx(\n            'gf-form-inline',\n            css`\n              margin-top: 6px;\n            `\n          )}\n        >\n          <LinkButton\n            icon=\"external-link-alt\"\n            variant=\"secondary\"\n            target=\"blank\"\n            href=\"https://docs.influxdata.com/influxdb/latest/query-data/get-started/\"\n          >\n            Flux language syntax\n          </LinkButton>\n          <Segment options={samples} value=\"Sample Query\" onChange={this.onSampleChange} />\n          <div className=\"gf-form gf-form--grow\">\n            <div className=\"gf-form-label gf-form-label--grow\"></div>\n          </div>\n          <InlineFormLabel width={5} tooltip={helpTooltip}>\n            Help\n          </InlineFormLabel>\n        </div>\n      </>\n    );\n  }\n}\n\ncoreModule.directive('fluxQueryEditor', [\n  'reactDirective',\n  (reactDirective: any) => {\n    return reactDirective(FluxQueryEditor, ['query', 'onChange', 'onRunQuery']);\n  },\n]);\n","import _ from 'lodash';\n\nimport {\n  dateMath,\n  DataSourceInstanceSettings,\n  ScopedVars,\n  DataQueryRequest,\n  DataQueryResponse,\n  dateTime,\n  LoadingState,\n  QueryResultMeta,\n  MetricFindValue,\n  AnnotationQueryRequest,\n  AnnotationEvent,\n  DataQueryError,\n} from '@grafana/data';\nimport { v4 as uuidv4 } from 'uuid';\nimport InfluxSeries from './influx_series';\nimport InfluxQueryModel from './influx_query_model';\nimport ResponseParser from './response_parser';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { InfluxQuery, InfluxOptions, InfluxVersion } from './types';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { getBackendSrv, DataSourceWithBackend, frameToMetricFindValue } from '@grafana/runtime';\nimport { Observable, throwError, of } from 'rxjs';\nimport { FluxQueryEditor } from './components/FluxQueryEditor';\nimport { catchError, map } from 'rxjs/operators';\n\nexport default class InfluxDatasource extends DataSourceWithBackend<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: string[];\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n  isFlux: boolean;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n\n    this.type = 'influxdb';\n    this.urls = (instanceSettings.url ?? '').split(',').map((url) => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username ?? '';\n    this.password = instanceSettings.password ?? '';\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n    this.isFlux = settingsData.version === InfluxVersion.Flux;\n\n    if (this.isFlux) {\n      // When flux, use an annotation processor rather than the `annotationQuery` lifecycle\n      this.annotations = {\n        QueryEditor: FluxQueryEditor,\n      };\n    }\n  }\n\n  query(request: DataQueryRequest<InfluxQuery>): Observable<DataQueryResponse> {\n    if (this.isFlux) {\n      return super.query(request);\n    }\n\n    // Fallback to classic query support\n    return this.classicQuery(request);\n  }\n\n  getQueryDisplayText(query: InfluxQuery) {\n    if (this.isFlux) {\n      return query.query;\n    }\n    return new InfluxQueryModel(query).render(false);\n  }\n\n  /**\n   * Returns false if the query should be skipped\n   */\n  filterQuery(query: InfluxQuery): boolean {\n    if (this.isFlux) {\n      return !!query.query;\n    }\n    return true;\n  }\n\n  /**\n   * Only applied on flux queries\n   */\n  applyTemplateVariables(query: InfluxQuery, scopedVars: ScopedVars): Record<string, any> {\n    return {\n      ...query,\n      query: this.templateSrv.replace(query.query ?? '', scopedVars), // The raw query text\n    };\n  }\n\n  /**\n   * The unchanged pre 7.1 query implementation\n   */\n  classicQuery(options: any): Observable<DataQueryResponse> {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = _.cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n\n    let i, y;\n\n    let allQueries = _.map(targets, (target) => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      return new InfluxQueryModel(target, this.templateSrv, scopedVars).render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return of({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      const tmpQuery = new InfluxQueryModel({ refId: 'A' }, this.templateSrv, scopedVars);\n      timeFilter += ' AND ' + tmpQuery.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).pipe(\n      map((data: any) => {\n        if (!data || !data.results) {\n          return { data: [] };\n        }\n\n        const seriesList = [];\n        for (i = 0; i < data.results.length; i++) {\n          const result = data.results[i];\n          if (!result || !result.series) {\n            continue;\n          }\n\n          const target = queryTargets[i];\n          let alias = target.alias;\n          if (alias) {\n            alias = this.templateSrv.replace(target.alias, options.scopedVars);\n          }\n\n          const meta: QueryResultMeta = {\n            executedQueryString: data.executedQueryString,\n          };\n\n          const influxSeries = new InfluxSeries({\n            refId: target.refId,\n            series: data.results[i].series,\n            alias: alias,\n            meta,\n          });\n\n          switch (target.resultFormat) {\n            case 'logs':\n              meta.preferredVisualisationType = 'logs';\n            case 'table': {\n              seriesList.push(influxSeries.getTable());\n              break;\n            }\n            default: {\n              const timeSeries = influxSeries.getTimeSeries();\n              for (y = 0; y < timeSeries.length; y++) {\n                seriesList.push(timeSeries[y]);\n              }\n              break;\n            }\n          }\n        }\n\n        return { data: seriesList };\n      })\n    );\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<any>): Promise<AnnotationEvent[]> {\n    if (this.isFlux) {\n      return Promise.reject({\n        message: 'Flux requires the standard annotation query',\n      });\n    }\n\n    // InfluxQL puts a query string on the annotation\n    if (!options.annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.dashboard.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, undefined, 'regex');\n\n    return this._seriesQuery(query, options)\n      .toPromise()\n      .then((data: any) => {\n        if (!data || !data.results || !data.results[0]) {\n          throw { message: 'No results in response from InfluxDB' };\n        }\n        return new InfluxSeries({\n          series: data.results[0].series,\n          annotation: options.annotation,\n        }).getAnnotations();\n      });\n  }\n\n  targetContainsTemplate(target: any) {\n    for (const group of target.groupBy) {\n      for (const param of group.params) {\n        if (this.templateSrv.variableExists(param)) {\n          return true;\n        }\n      }\n    }\n\n    for (const i in target.tags) {\n      if (this.templateSrv.variableExists(target.tags[i].value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map((query) => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          measurement: this.templateSrv.replace(query.measurement ?? '', scopedVars, 'regex'),\n          policy: this.templateSrv.replace(query.policy ?? '', scopedVars, 'regex'),\n        };\n\n        if (query.rawQuery) {\n          expandedQuery.query = this.templateSrv.replace(query.query ?? '', scopedVars, 'regex');\n        }\n\n        if (query.tags) {\n          expandedQuery.tags = query.tags.map((tag) => {\n            return {\n              ...tag,\n              value: this.templateSrv.replace(tag.value, undefined, 'regex'),\n            };\n          });\n        }\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  async metricFindQuery(query: string, options?: any): Promise<MetricFindValue[]> {\n    if (this.isFlux) {\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        query,\n      };\n      return super\n        .query({\n          ...options, // includes 'range'\n          targets: [target],\n        } as DataQueryRequest)\n        .toPromise()\n        .then((rsp) => {\n          if (rsp.data?.length) {\n            return frameToMetricFindValue(rsp.data[0]);\n          }\n          return [];\n        });\n    }\n\n    const interpolated = this.templateSrv.replace(query, undefined, 'regex');\n\n    return this._seriesQuery(interpolated, options)\n      .toPromise()\n      .then((resp) => {\n        return this.responseParser.parse(query, resp);\n      });\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return of({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return _.reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      [] as string[]\n    ).join('&');\n  }\n\n  testDatasource() {\n    if (this.isFlux) {\n      // TODO: eventually use the real /health endpoint\n      const request: DataQueryRequest<InfluxQuery> = {\n        targets: [{ refId: 'test', query: 'buckets()' }],\n        requestId: `${this.id}-health-${uuidv4()}`,\n        dashboardId: 0,\n        panelId: 0,\n        interval: '1m',\n        intervalMs: 60000,\n        maxDataPoints: 423,\n        range: {\n          from: dateTime(1000),\n          to: dateTime(2000),\n        },\n      } as DataQueryRequest<InfluxQuery>;\n\n      return super\n        .query(request)\n        .toPromise()\n        .then((res: DataQueryResponse) => {\n          if (!res || !res.data || res.state !== LoadingState.Done) {\n            console.error('InfluxDB Error', res);\n            return { status: 'error', message: 'Error reading InfluxDB' };\n          }\n          const first = res.data[0];\n          if (first && first.length) {\n            return { status: 'success', message: `${first.length} buckets found` };\n          }\n          console.error('InfluxDB Error', res);\n          return { status: 'error', message: 'Error reading buckets' };\n        })\n        .catch((err: any) => {\n          console.error('InfluxDB Error', err);\n          return { status: 'error', message: err.message };\n        });\n    }\n\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return this._seriesQuery(query)\n      .toPromise()\n      .then((res: any) => {\n        const error = _.get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift()!;\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    const { q } = data;\n\n    if (method === 'POST' && _.has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      _.extend(params, _.omit(data, ['q']));\n      data = this.serializeParams(_.pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      _.extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return getBackendSrv()\n      .fetch(req)\n      .pipe(\n        map((result: any) => {\n          const { data } = result;\n          if (data) {\n            data.executedQueryString = q;\n            if (data.results) {\n              const errors = result.data.results.filter((elem: any) => elem.error);\n\n              if (errors.length > 0) {\n                throw {\n                  message: 'InfluxDB Error: ' + errors[0].error,\n                  data,\n                };\n              }\n            }\n          }\n          return data;\n        }),\n        catchError((err) => {\n          if (err.cancelled) {\n            return of(err);\n          }\n\n          return throwError(this.handleErrors(err));\n        })\n      );\n  }\n\n  handleErrors(err: any) {\n    const error: DataQueryError = {\n      message:\n        (err && err.status) ||\n        (err && err.message) ||\n        'Unknown error during query transaction. Please check JS console logs.',\n    };\n\n    if ((Number.isInteger(err.status) && err.status !== 0) || err.status >= 300) {\n      if (err.data && err.data.error) {\n        error.message = 'InfluxDB Error: ' + err.data.error;\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      } else {\n        error.message = 'Network Error: ' + err.statusText + '(' + err.status + ')';\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      }\n    }\n\n    return error;\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n    const fromIsAbsolute = from[from.length - 1] === 'ms';\n\n    if (until === 'now()' && !fromIsAbsolute) {\n      return 'time >= ' + from;\n    }\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (_.isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n}\n","import angular, { auto } from 'angular';\nimport _ from 'lodash';\nimport { InfluxQueryBuilder } from './query_builder';\nimport InfluxQueryModel from './influx_query_model';\nimport queryPart from './query_part';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { TemplateSrv } from '@grafana/runtime';\nimport { InfluxQuery } from './types';\nimport InfluxDatasource from './datasource';\n\nexport class InfluxQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  datasource: InfluxDatasource;\n  queryModel: InfluxQueryModel;\n  queryBuilder: any;\n  groupBySegment: any;\n  resultFormats: any[];\n  orderByTime: any[];\n  policySegment: any;\n  tagSegments: any[];\n  selectMenu: any;\n  measurementSegment: any;\n  removeTagFilterSegment: any;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private templateSrv: TemplateSrv,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n    this.target = this.target;\n    this.queryModel = new InfluxQueryModel(this.target, templateSrv, this.panel.scopedVars);\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    this.resultFormats = [\n      { text: 'Time series', value: 'time_series' },\n      { text: 'Table', value: 'table' },\n      { text: 'Logs', value: 'logs' },\n    ];\n\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\n\n    if (!this.target.measurement) {\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\n    } else {\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\n    }\n\n    this.tagSegments = [];\n    for (const tag of this.target.tags) {\n      if (!tag.operator) {\n        if (/^\\/.*\\/$/.test(tag.value)) {\n          tag.operator = '=~';\n        } else {\n          tag.operator = '=';\n        }\n      }\n\n      if (tag.condition) {\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\n      }\n\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\n    }\n\n    this.fixTagSegments();\n    this.buildSelectMenu();\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\n      fake: true,\n      value: '-- remove tag filter --',\n    });\n  }\n\n  /**\n   * Only called for flux\n   */\n  onChange = (target: InfluxQuery) => {\n    this.target.query = target.query;\n  };\n\n  onRunQuery = () => {\n    this.panelCtrl.refresh();\n  };\n\n  removeOrderByTime() {\n    this.target.orderByTime = 'ASC';\n  }\n\n  buildSelectMenu() {\n    const categories = queryPart.getCategories();\n    this.selectMenu = _.reduce(\n      categories,\n      (memo, cat, key) => {\n        const menu = {\n          text: key,\n          submenu: cat.map((item: any) => {\n            return { text: item.type, value: item.type };\n          }),\n        };\n        memo.push(menu);\n        return memo;\n      },\n      [] as any\n    );\n  }\n\n  getGroupByOptions() {\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then((tags: any) => {\n        const options = [];\n        if (!this.queryModel.hasFill()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\n        }\n        if (!this.target.limit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\n        }\n        if (!this.target.slimit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\n        }\n        if (!this.target.tz) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tz' }));\n        }\n        if (this.target.orderByTime === 'ASC') {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\n        }\n        if (!this.queryModel.hasGroupByTime()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\n        }\n        for (const tag of tags) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\n        }\n        return options;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  groupByAction() {\n    switch (this.groupBySegment.value) {\n      case 'LIMIT': {\n        this.target.limit = 10;\n        break;\n      }\n      case 'SLIMIT': {\n        this.target.slimit = 10;\n        break;\n      }\n      case 'tz': {\n        this.target.tz = 'UTC';\n        break;\n      }\n      case 'ORDER BY time DESC': {\n        this.target.orderByTime = 'DESC';\n        break;\n      }\n      default: {\n        this.queryModel.addGroupBy(this.groupBySegment.value);\n      }\n    }\n\n    const plusButton = this.uiSegmentSrv.newPlusButton();\n    this.groupBySegment.value = plusButton.value;\n    this.groupBySegment.html = plusButton.html;\n    this.groupBySegment.fake = true;\n    this.panelCtrl.refresh();\n  }\n\n  addSelectPart(selectParts: any, cat: any, subitem: { value: any }) {\n    this.queryModel.addSelectPart(selectParts, subitem.value);\n    this.panelCtrl.refresh();\n  }\n\n  handleSelectPartEvent(selectParts: any, part: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n        return this.datasource\n          .metricFindQuery(fieldsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeSelectPart(selectParts, part);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  handleGroupByPartEvent(part: any, index: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n        return this.datasource\n          .metricFindQuery(tagsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeGroupByPart(part, index);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  fixTagSegments() {\n    const count = this.tagSegments.length;\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\n\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n    }\n  }\n\n  measurementChanged() {\n    this.target.measurement = this.measurementSegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  getPolicySegments() {\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\n    return this.datasource\n      .metricFindQuery(policiesQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  policyChanged() {\n    this.target.policy = this.policySegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  // Only valid for InfluxQL queries\n  toggleEditorMode() {\n    if (this.datasource.isFlux) {\n      return; // nothing\n    }\n\n    try {\n      this.target.query = this.queryModel.render(false);\n    } catch (err) {\n      console.error('query render error');\n    }\n    this.target.rawQuery = !this.target.rawQuery;\n  }\n\n  getMeasurements(measurementFilter: any) {\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(true))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n\n  transformToSegments(addTemplateVars: any) {\n    return (results: any) => {\n      const segments = _.map(results, (segment) => {\n        return this.uiSegmentSrv.newSegment({\n          value: segment.text,\n          expandable: segment.expandable,\n        });\n      });\n\n      if (addTemplateVars) {\n        for (const variable of this.templateSrv.getVariables()) {\n          segments.unshift(\n            this.uiSegmentSrv.newSegment({\n              type: 'value',\n              value: '/^$' + variable.name + '$/',\n              expandable: true,\n            })\n          );\n        }\n      }\n\n      return segments;\n    };\n  }\n\n  getTagsOrValues(segment: { type: string }, index: number) {\n    if (segment.type === 'condition') {\n      return Promise.resolve([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\n    }\n\n    if (segment.type === 'operator') {\n      const nextValue = this.tagSegments[index + 1].value;\n      if (/^\\/.*\\/$/.test(nextValue)) {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=~', '!~']));\n      } else {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\n      }\n    }\n\n    let query, addTemplateVars;\n    if (segment.type === 'key' || segment.type === 'plus-button') {\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n      addTemplateVars = false;\n    } else if (segment.type === 'value') {\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\n      addTemplateVars = true;\n    }\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(addTemplateVars))\n      .then((results: any) => {\n        if (segment.type === 'key') {\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\n        }\n        return results;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  getFieldSegments() {\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n    return this.datasource\n      .metricFindQuery(fieldsQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError);\n  }\n\n  tagSegmentUpdated(segment: { value: any; type: string; cssClass: string }, index: number) {\n    this.tagSegments[index] = segment;\n\n    // handle remove tag condition\n    if (segment.value === this.removeTagFilterSegment.value) {\n      this.tagSegments.splice(index, 3);\n      if (this.tagSegments.length === 0) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      } else if (this.tagSegments.length > 2) {\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n        }\n      }\n    } else {\n      if (segment.type === 'plus-button') {\n        if (index > 2) {\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\n        }\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\n        segment.type = 'key';\n        segment.cssClass = 'query-segment-key';\n      }\n\n      if (index + 1 === this.tagSegments.length) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      }\n    }\n\n    this.rebuildTargetTagConditions();\n  }\n\n  rebuildTargetTagConditions() {\n    const tags: any[] = [];\n    let tagIndex = 0;\n    let tagOperator: string | null = '';\n\n    _.each(this.tagSegments, (segment2, index) => {\n      if (segment2.type === 'key') {\n        if (tags.length === 0) {\n          tags.push({});\n        }\n        tags[tagIndex].key = segment2.value;\n      } else if (segment2.type === 'value') {\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\n        if (tagOperator) {\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\n          tags[tagIndex].operator = tagOperator;\n        }\n        tags[tagIndex].value = segment2.value;\n      } else if (segment2.type === 'condition') {\n        tags.push({ condition: segment2.value });\n        tagIndex += 1;\n      } else if (segment2.type === 'operator') {\n        tags[tagIndex].operator = segment2.value;\n      }\n    });\n\n    this.target.tags = tags;\n    this.panelCtrl.refresh();\n  }\n\n  getTagValueOperator(tagValue: string, tagOperator: string): string | null {\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\n      return '=~';\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\n      return '=';\n    }\n    return null;\n  }\n}\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nconst InfluxCheatSheet = (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item) => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n\nexport default InfluxCheatSheet;\n","import React, { PureComponent } from 'react';\nimport { QueryEditorHelpProps } from '@grafana/data';\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<QueryEditorHelpProps> {\n  render() {\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\n  }\n}\n","import React, { PureComponent } from 'react';\nimport {\n  DataSourcePluginOptionsEditorProps,\n  SelectableValue,\n  onUpdateDatasourceOption,\n  updateDatasourcePluginResetOption,\n  onUpdateDatasourceJsonDataOption,\n  onUpdateDatasourceJsonDataOptionSelect,\n  onUpdateDatasourceSecureJsonDataOption,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { DataSourceHttpSettings, InlineField, InlineFormLabel, LegacyForms } from '@grafana/ui';\nconst { Select, Input, SecretFormField } = LegacyForms;\nimport { InfluxOptions, InfluxSecureJsonData, InfluxVersion } from '../types';\n\nconst httpModes = [\n  { label: 'GET', value: 'GET' },\n  { label: 'POST', value: 'POST' },\n] as SelectableValue[];\n\nconst versions = [\n  {\n    label: 'InfluxQL',\n    value: InfluxVersion.InfluxQL,\n    description: 'The InfluxDB SQL-like query language.  Supported in InfluxDB 1.x',\n  },\n  {\n    label: 'Flux',\n    value: InfluxVersion.Flux,\n    description: 'Advanced data scripting and query language.  Supported in InfluxDB 2.x and 1.8+ (beta)',\n  },\n] as Array<SelectableValue<InfluxVersion>>;\n\nexport type Props = DataSourcePluginOptionsEditorProps<InfluxOptions>;\ntype State = {\n  maxSeries: string | undefined;\n};\n\nexport class ConfigEditor extends PureComponent<Props, State> {\n  state = {\n    maxSeries: '',\n  };\n\n  constructor(props: Props) {\n    super(props);\n    this.state.maxSeries = props.options.jsonData.maxSeries?.toString() || '';\n  }\n\n  // 1x\n  onResetPassword = () => {\n    updateDatasourcePluginResetOption(this.props, 'password');\n  };\n\n  // 2x\n  onResetToken = () => {\n    updateDatasourcePluginResetOption(this.props, 'token');\n  };\n\n  onVersionChanged = (selected: SelectableValue<InfluxVersion>) => {\n    const { options, onOptionsChange } = this.props;\n\n    const copy: any = {\n      ...options,\n      jsonData: {\n        ...options.jsonData,\n        version: selected.value,\n      },\n    };\n    if (selected.value === InfluxVersion.Flux) {\n      copy.access = 'proxy';\n      copy.basicAuth = true;\n      copy.jsonData.httpMode = 'POST';\n\n      // Remove old 1x configs\n      delete copy.user;\n      delete copy.database;\n    }\n\n    onOptionsChange(copy);\n  };\n\n  renderInflux2x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Organization</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                value={options.jsonData.organization || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'organization')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={(secureJsonFields && secureJsonFields.token) as boolean}\n              value={secureJsonData.token || ''}\n              label=\"Token\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetToken}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'token')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Default Bucket</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                placeholder=\"default bucket\"\n                value={options.jsonData.defaultBucket || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'defaultBucket')}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  renderInflux1x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <>\n        <div className=\"grafana-info-box\">\n          <h5>Database Access</h5>\n          <p>\n            Setting the database for this datasource does not deny access to other databases. The InfluxDB query syntax\n            allows switching the database in the query. For example:\n            <code>SHOW MEASUREMENTS ON _internal</code> or\n            <code>SELECT * FROM &quot;_internal&quot;..&quot;database&quot; LIMIT 10</code>\n            <br />\n            <br />\n            To support data isolation and security, make sure appropriate permissions are configured in InfluxDB.\n          </p>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Database</InlineFormLabel>\n            <div className=\"width-20\">\n              <Input\n                className=\"width-20\"\n                value={options.database || ''}\n                onChange={onUpdateDatasourceOption(this.props, 'database')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">User</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                value={options.user || ''}\n                onChange={onUpdateDatasourceOption(this.props, 'user')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={(secureJsonFields && secureJsonFields.password) as boolean}\n              value={secureJsonData.password || ''}\n              label=\"Password\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetPassword}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'password')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"You can use either GET or POST HTTP method to query your InfluxDB database. The POST\n          method allows you to perform heavy requests (with a lots of WHERE clause) while the GET method\n          will restrict you and return an error if the query is too large.\"\n            >\n              HTTP Method\n            </InlineFormLabel>\n            <Select\n              className=\"width-10\"\n              value={httpModes.find((httpMode) => httpMode.value === options.jsonData.httpMode)}\n              options={httpModes}\n              defaultValue={options.jsonData.httpMode}\n              onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'httpMode')}\n            />\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  render() {\n    const { options, onOptionsChange } = this.props;\n\n    return (\n      <>\n        <h3 className=\"page-heading\">Query Language</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <Select\n                className=\"width-30\"\n                value={options.jsonData.version === InfluxVersion.Flux ? versions[1] : versions[0]}\n                options={versions}\n                defaultValue={versions[0]}\n                onChange={this.onVersionChanged}\n              />\n            </div>\n          </div>\n        </div>\n\n        {options.jsonData.version === InfluxVersion.Flux && (\n          <div className=\"width-30 grafana-info-box\">\n            <h5>Support for Flux in Grafana is currently in beta</h5>\n            <p>\n              Please report any issues to: <br />\n              <a href=\"https://github.com/grafana/grafana/issues/new/choose\">\n                https://github.com/grafana/grafana/issues\n              </a>\n            </p>\n          </div>\n        )}\n\n        <DataSourceHttpSettings\n          showAccessOptions={true}\n          dataSourceConfig={options}\n          defaultUrl=\"http://localhost:8086\"\n          onChange={onOptionsChange}\n        />\n\n        <div className=\"gf-form-group\">\n          <div>\n            <h3 className=\"page-heading\">InfluxDB Details</h3>\n          </div>\n          {options.jsonData.version === InfluxVersion.Flux ? this.renderInflux2x() : this.renderInflux1x()}\n          <div className=\"gf-form-inline\">\n            <InlineField\n              labelWidth={20}\n              label=\"Max series\"\n              tooltip=\"Limit the number of series/tables that Grafana will process. Lower this number to prevent abuse, and increase it if you have lots of small time series and not all are shown. Defaults to 1000.\"\n            >\n              <Input\n                placeholder=\"1000\"\n                type=\"number\"\n                className=\"width-10\"\n                value={this.state.maxSeries}\n                onChange={(event) => {\n                  // We duplicate this state so that we allow to write freely inside the input. We don't have\n                  // any influence over saving so this seems to be only way to do this.\n                  this.setState({ maxSeries: event.currentTarget.value });\n                  const val = parseInt(event.currentTarget.value, 10);\n                  updateDatasourcePluginJsonDataOption(this.props, 'maxSeries', Number.isFinite(val) ? val : undefined);\n                }}\n              />\n            </InlineField>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default ConfigEditor;\n","import React, { PureComponent } from 'react';\nimport InfluxDatasource from '../datasource';\nimport { InlineFormLabel, TextArea } from '@grafana/ui';\nimport { FluxQueryEditor } from './FluxQueryEditor';\n\ninterface Props {\n  query: string; // before flux, it was always a string\n  onChange: (query?: string) => void;\n  datasource: InfluxDatasource;\n}\n\nexport default class VariableQueryEditor extends PureComponent<Props> {\n  onRefresh = () => {\n    // noop\n  };\n\n  render() {\n    let { query, datasource, onChange } = this.props;\n    if (datasource.isFlux) {\n      return (\n        <FluxQueryEditor\n          datasource={datasource}\n          query={{\n            refId: 'A',\n            query,\n          }}\n          onRunQuery={this.onRefresh}\n          onChange={(v) => onChange(v.query)}\n        />\n      );\n    }\n\n    return (\n      <div className=\"gf-form-inline\">\n        <InlineFormLabel width={10}>Query</InlineFormLabel>\n        <div className=\"gf-form-inline gf-form--grow\">\n          <TextArea\n            defaultValue={query || ''}\n            placeholder=\"metric name or tags query\"\n            rows={1}\n            className=\"gf-form-input\"\n            onBlur={(e) => onChange(e.currentTarget.value)}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n","import InfluxDatasource from './datasource';\nimport { InfluxQueryCtrl } from './query_ctrl';\nimport InfluxStartPage from './components/InfluxStartPage';\nimport { DataSourcePlugin } from '@grafana/data';\nimport ConfigEditor from './components/ConfigEditor';\nimport VariableQueryEditor from './components/VariableQueryEditor';\n\n// This adds a directive that is used in the query editor\nimport './components/FluxQueryEditor';\n\nclass InfluxAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryCtrl(InfluxQueryCtrl)\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\n  .setVariableQueryEditor(VariableQueryEditor)\n  .setQueryEditorHelp(InfluxStartPage);\n"],"sourceRoot":""}