{"version":3,"sources":["webpack:///./public/app/plugins/datasource/opentsdb/datasource.ts","webpack:///./public/app/plugins/datasource/opentsdb/query_ctrl.ts","webpack:///./public/app/plugins/datasource/opentsdb/components/OpenTsdbDetails.tsx","webpack:///./public/app/plugins/datasource/opentsdb/module.ts","webpack:///./public/app/plugins/datasource/opentsdb/components/ConfigEditor.tsx"],"names":["OpenTsDatasource","instanceSettings","templateSrv","getTemplateSrv","type","url","name","withCredentials","basicAuth","jsonData","tsdbVersion","tsdbResolution","lookupLimit","tagKeys","aggregatorsPromise","filterTypesPromise","options","start","this","convertToTSDBTime","range","raw","from","timezone","end","to","qs","_","each","targets","target","metric","push","convertTargetToQuery","queries","compact","isEmpty","of","data","groupByTags","query","filters","length","val","tagk","tags","key","filter","hide","performTimeSeriesQuery","pipe","map","response","metricToTargetMapping","mapMetricsToTargets","metricData","index","_saveTagKeys","transformMetricData","rangeRaw","eventList","aggregator","annotation","results","annotationObject","annotations","isGlobal","globalAnnotations","event","text","description","time","Math","floor","startTime","toPromise","i","variableExists","Object","keys","tagKey","msResolution","reqBody","showQuery","method","_addCredentialOptions","getBackendSrv","fetch","Promise","resolve","aggregateTags","tag","_get","q","max","result","keysArray","split","trim","keysQuery","splice","join","m","limit","tagvs","r","indexOf","tagks","tagv","relativeUrl","params","headers","Authorization","interpolated","replace","err","reject","responseTransform","value","metricsQuery","match","_performSuggestQuery","tagNamesQuery","_performMetricKeyLookup","tagValuesQuery","_performMetricKeyValueLookup","tagNamesSuggestQuery","tagValuesSuggestQuery","status","message","isArray","sort","md","metricLabel","createMetricLabel","dps","v","k","datapoints","alias","scopedVars","clone","label","tagData","toPairs","has","shouldComputeRate","rate","rateOptions","counter","isCounter","counterMax","parseInt","counterResetValue","resetValue","dropResets","ResetValue","disableDownsampling","interval","downsampleInterval","parseFloat","downsample","downsampleAggregator","downsampleFillPolicy","angular","copy","filterKey","explicitTags","metrics","interpolatedTagValue","arrTagV","findIndex","every","tagV","tagK","includes","date","roundUp","dateMath","parse","valueOf","DataSourceApi","OpenTsQueryCtrl","$scope","$injector","errors","validateTarget","aggregators","fillPolicies","filterTypes","datasource","getAggregators","then","aggs","getFilterTypes","suggestMetrics","callback","metricFindQuery","getTextValues","suggestTagKeys","suggestTagValues","refresh","metricFindResult","textUtil","escapeHtml","addTagMode","currentTagKey","currentTagValue","targetBlur","removeTag","addTag","size","addFilterMode","currentFilterType","currentFilterGroupBy","currentFilter","currentFilterKey","currentFilterValue","groupBy","fil","removeFilter","addFilter","errs","shouldDownsample","rangeUtil","describeInterval","QueryCtrl","templateUrl","Select","LegacyForms","Input","tsdbVersions","tsdbResolutions","OpenTsdbDetails","props","onChange","className","width","find","version","onSelectChangeHandler","resolution","onInputChangeHandler","newValue","currentTarget","AnnotationsQueryCtrl","plugin","DataSourcePlugin","setQueryCtrl","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","setAnnotationQueryCtrl"],"mappings":"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","file":"opentsdbPlugin.63a9c1d648180e457252.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { FetchResponse, getBackendSrv } from '@grafana/runtime';\nimport {\n  AnnotationEvent,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  dateMath,\n  ScopedVars,\n} from '@grafana/data';\n\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { OpenTsdbOptions, OpenTsdbQuery } from './types';\n\nexport default class OpenTsDatasource extends DataSourceApi<OpenTsdbQuery, OpenTsdbOptions> {\n  type: any;\n  url: any;\n  name: any;\n  withCredentials: any;\n  basicAuth: any;\n  tsdbVersion: any;\n  tsdbResolution: any;\n  lookupLimit: any;\n  tagKeys: any;\n\n  aggregatorsPromise: any;\n  filterTypesPromise: any;\n\n  constructor(instanceSettings: any, private readonly templateSrv: TemplateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n    this.type = 'opentsdb';\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\n    this.lookupLimit = instanceSettings.jsonData.lookupLimit || 1000;\n    this.tagKeys = {};\n\n    this.aggregatorsPromise = null;\n    this.filterTypesPromise = null;\n  }\n\n  // Called once per panel (graph)\n  query(options: DataQueryRequest<OpenTsdbQuery>): Observable<DataQueryResponse> {\n    const start = this.convertToTSDBTime(options.range.raw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.range.raw.to, true, options.timezone);\n    const qs: any[] = [];\n\n    _.each(options.targets, (target) => {\n      if (!target.metric) {\n        return;\n      }\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\n    });\n\n    const queries = _.compact(qs);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (_.isEmpty(queries)) {\n      return of({ data: [] });\n    }\n\n    const groupByTags: any = {};\n    _.each(queries, (query) => {\n      if (query.filters && query.filters.length > 0) {\n        _.each(query.filters, (val) => {\n          groupByTags[val.tagk] = true;\n        });\n      } else {\n        _.each(query.tags, (val, key) => {\n          groupByTags[key] = true;\n        });\n      }\n    });\n\n    options.targets = _.filter(options.targets, (query) => {\n      return query.hide !== true;\n    });\n\n    return this.performTimeSeriesQuery(queries, start, end).pipe(\n      map((response) => {\n        const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\n        const result = _.map(response.data, (metricData: any, index: number) => {\n          index = metricToTargetMapping[index];\n          if (index === -1) {\n            index = 0;\n          }\n          this._saveTagKeys(metricData);\n\n          return this.transformMetricData(\n            metricData,\n            groupByTags,\n            options.targets[index],\n            options,\n            this.tsdbResolution\n          );\n        });\n        return { data: result };\n      })\n    );\n  }\n\n  annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs = [];\n    const eventList: any[] = [];\n\n    qs.push({ aggregator: 'sum', metric: options.annotation.target });\n\n    const queries = _.compact(qs);\n\n    return this.performTimeSeriesQuery(queries, start, end)\n      .pipe(\n        map((results) => {\n          if (results.data[0]) {\n            let annotationObject = results.data[0].annotations;\n            if (options.annotation.isGlobal) {\n              annotationObject = results.data[0].globalAnnotations;\n            }\n            if (annotationObject) {\n              _.each(annotationObject, (annotation) => {\n                const event = {\n                  text: annotation.description,\n                  time: Math.floor(annotation.startTime) * 1000,\n                  annotation: options.annotation,\n                };\n\n                eventList.push(event);\n              });\n            }\n          }\n          return eventList;\n        })\n      )\n      .toPromise();\n  }\n\n  targetContainsTemplate(target: any) {\n    if (target.filters && target.filters.length > 0) {\n      for (let i = 0; i < target.filters.length; i++) {\n        if (this.templateSrv.variableExists(target.filters[i].filter)) {\n          return true;\n        }\n      }\n    }\n\n    if (target.tags && Object.keys(target.tags).length > 0) {\n      for (const tagKey in target.tags) {\n        if (this.templateSrv.variableExists(target.tags[tagKey])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  performTimeSeriesQuery(queries: any[], start: any, end: any): Observable<FetchResponse> {\n    let msResolution = false;\n    if (this.tsdbResolution === 2) {\n      msResolution = true;\n    }\n    const reqBody: any = {\n      start: start,\n      queries: queries,\n      msResolution: msResolution,\n      globalAnnotations: true,\n    };\n    if (this.tsdbVersion === 3) {\n      reqBody.showQuery = true;\n    }\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (end) {\n      reqBody.end = end;\n    }\n\n    const options = {\n      method: 'POST',\n      url: this.url + '/api/query',\n      data: reqBody,\n    };\n\n    this._addCredentialOptions(options);\n    return getBackendSrv().fetch(options);\n  }\n\n  suggestTagKeys(metric: string | number) {\n    return Promise.resolve(this.tagKeys[metric] || []);\n  }\n\n  _saveTagKeys(metricData: { tags: {}; aggregateTags: any; metric: string | number }) {\n    const tagKeys = Object.keys(metricData.tags);\n    _.each(metricData.aggregateTags, (tag) => {\n      tagKeys.push(tag);\n    });\n\n    this.tagKeys[metricData.metric] = tagKeys;\n  }\n\n  _performSuggestQuery(query: string, type: string): Observable<any> {\n    return this._get('/api/suggest', { type, q: query, max: this.lookupLimit }).pipe(\n      map((result: any) => {\n        return result.data;\n      })\n    );\n  }\n\n  _performMetricKeyValueLookup(metric: string, keys: any): Observable<any[]> {\n    if (!metric || !keys) {\n      return of([]);\n    }\n\n    const keysArray = keys.split(',').map((key: any) => {\n      return key.trim();\n    });\n    const key = keysArray[0];\n    let keysQuery = key + '=*';\n\n    if (keysArray.length > 1) {\n      keysQuery += ',' + keysArray.splice(1).join(',');\n    }\n\n    const m = metric + '{' + keysQuery + '}';\n\n    return this._get('/api/search/lookup', { m: m, limit: this.lookupLimit }).pipe(\n      map((result: any) => {\n        result = result.data.results;\n        const tagvs: any[] = [];\n        _.each(result, (r) => {\n          if (tagvs.indexOf(r.tags[key]) === -1) {\n            tagvs.push(r.tags[key]);\n          }\n        });\n        return tagvs;\n      })\n    );\n  }\n\n  _performMetricKeyLookup(metric: any): Observable<any[]> {\n    if (!metric) {\n      return of([]);\n    }\n\n    return this._get('/api/search/lookup', { m: metric, limit: 1000 }).pipe(\n      map((result: any) => {\n        result = result.data.results;\n        const tagks: any[] = [];\n        _.each(result, (r) => {\n          _.each(r.tags, (tagv, tagk) => {\n            if (tagks.indexOf(tagk) === -1) {\n              tagks.push(tagk);\n            }\n          });\n        });\n        return tagks;\n      })\n    );\n  }\n\n  _get(\n    relativeUrl: string,\n    params?: { type?: string; q?: string; max?: number; m?: any; limit?: number }\n  ): Observable<FetchResponse> {\n    const options = {\n      method: 'GET',\n      url: this.url + relativeUrl,\n      params: params,\n    };\n\n    this._addCredentialOptions(options);\n\n    return getBackendSrv().fetch(options);\n  }\n\n  _addCredentialOptions(options: any) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = { Authorization: this.basicAuth };\n    }\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    let interpolated;\n    try {\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    const responseTransform = (result: any) => {\n      return _.map(result, (value) => {\n        return { text: value };\n      });\n    };\n\n    const metricsRegex = /metrics\\((.*)\\)/;\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\n\n    const metricsQuery = interpolated.match(metricsRegex);\n    if (metricsQuery) {\n      return this._performSuggestQuery(metricsQuery[1], 'metrics').pipe(map(responseTransform)).toPromise();\n    }\n\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\n    if (tagNamesQuery) {\n      return this._performMetricKeyLookup(tagNamesQuery[1]).pipe(map(responseTransform)).toPromise();\n    }\n\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\n    if (tagValuesQuery) {\n      return this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2])\n        .pipe(map(responseTransform))\n        .toPromise();\n    }\n\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\n    if (tagNamesSuggestQuery) {\n      return this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').pipe(map(responseTransform)).toPromise();\n    }\n\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\n    if (tagValuesSuggestQuery) {\n      return this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').pipe(map(responseTransform)).toPromise();\n    }\n\n    return Promise.resolve([]);\n  }\n\n  testDatasource() {\n    return this._performSuggestQuery('cpu', 'metrics')\n      .pipe(\n        map(() => {\n          return { status: 'success', message: 'Data source is working' };\n        })\n      )\n      .toPromise();\n  }\n\n  getAggregators() {\n    if (this.aggregatorsPromise) {\n      return this.aggregatorsPromise;\n    }\n\n    this.aggregatorsPromise = this._get('/api/aggregators')\n      .pipe(\n        map((result: any) => {\n          if (result.data && _.isArray(result.data)) {\n            return result.data.sort();\n          }\n          return [];\n        })\n      )\n      .toPromise();\n    return this.aggregatorsPromise;\n  }\n\n  getFilterTypes() {\n    if (this.filterTypesPromise) {\n      return this.filterTypesPromise;\n    }\n\n    this.filterTypesPromise = this._get('/api/config/filters')\n      .pipe(\n        map((result: any) => {\n          if (result.data) {\n            return Object.keys(result.data).sort();\n          }\n          return [];\n        })\n      )\n      .toPromise();\n    return this.filterTypesPromise;\n  }\n\n  transformMetricData(md: { dps: any }, groupByTags: any, target: any, options: any, tsdbResolution: number) {\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\n    const dps: any[] = [];\n\n    // TSDB returns datapoints has a hash of ts => value.\n    // Can't use _.pairs(invert()) because it stringifies keys/values\n    _.each(md.dps, (v: any, k: number) => {\n      if (tsdbResolution === 2) {\n        dps.push([v, k * 1]);\n      } else {\n        dps.push([v, k * 1000]);\n      }\n    });\n\n    return { target: metricLabel, datapoints: dps };\n  }\n\n  createMetricLabel(\n    md: { dps?: any; tags?: any; metric?: any },\n    target: { alias: string },\n    groupByTags: any,\n    options: { scopedVars: any }\n  ) {\n    if (target.alias) {\n      const scopedVars = _.clone(options.scopedVars || {});\n      _.each(md.tags, (value, key) => {\n        scopedVars['tag_' + key] = { value: value };\n      });\n      return this.templateSrv.replace(target.alias, scopedVars);\n    }\n\n    let label = md.metric;\n    const tagData: any[] = [];\n\n    if (!_.isEmpty(md.tags)) {\n      _.each(_.toPairs(md.tags), (tag) => {\n        if (_.has(groupByTags, tag[0])) {\n          tagData.push(tag[0] + '=' + tag[1]);\n        }\n      });\n    }\n\n    if (!_.isEmpty(tagData)) {\n      label += '{' + tagData.join(', ') + '}';\n    }\n\n    return label;\n  }\n\n  convertTargetToQuery(target: any, options: any, tsdbVersion: number) {\n    if (!target.metric || target.hide) {\n      return null;\n    }\n\n    const query: any = {\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\n      aggregator: 'avg',\n    };\n\n    if (target.aggregator) {\n      query.aggregator = this.templateSrv.replace(target.aggregator);\n    }\n\n    if (target.shouldComputeRate) {\n      query.rate = true;\n      query.rateOptions = {\n        counter: !!target.isCounter,\n      };\n\n      if (target.counterMax && target.counterMax.length) {\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\n      }\n\n      if (target.counterResetValue && target.counterResetValue.length) {\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\n      }\n\n      if (tsdbVersion >= 2) {\n        query.rateOptions.dropResets =\n          !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\n      }\n    }\n\n    if (!target.disableDownsampling) {\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\n\n      if (interval.match(/\\.[0-9]+s/)) {\n        interval = parseFloat(interval) * 1000 + 'ms';\n      }\n\n      query.downsample = interval + '-' + target.downsampleAggregator;\n\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\n        query.downsample += '-' + target.downsampleFillPolicy;\n      }\n    }\n\n    if (target.filters && target.filters.length > 0) {\n      query.filters = angular.copy(target.filters);\n      if (query.filters) {\n        for (const filterKey in query.filters) {\n          query.filters[filterKey].filter = this.templateSrv.replace(\n            query.filters[filterKey].filter,\n            options.scopedVars,\n            'pipe'\n          );\n        }\n      }\n    } else {\n      query.tags = angular.copy(target.tags);\n      if (query.tags) {\n        for (const tagKey in query.tags) {\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\n        }\n      }\n    }\n\n    if (target.explicitTags) {\n      query.explicitTags = true;\n    }\n\n    return query;\n  }\n\n  mapMetricsToTargets(metrics: any, options: any, tsdbVersion: number) {\n    let interpolatedTagValue, arrTagV;\n    return _.map(metrics, (metricData) => {\n      if (tsdbVersion === 3) {\n        return metricData.query.index;\n      } else {\n        return _.findIndex(options.targets as any[], (target) => {\n          if (target.filters && target.filters.length > 0) {\n            return target.metric === metricData.metric;\n          } else {\n            return (\n              target.metric === metricData.metric &&\n              _.every(target.tags, (tagV, tagK) => {\n                interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\n                arrTagV = interpolatedTagValue.split('|');\n                return _.includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\n              })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  interpolateVariablesInQueries(queries: OpenTsdbQuery[], scopedVars: ScopedVars): OpenTsdbQuery[] {\n    if (!queries.length) {\n      return queries;\n    }\n\n    return queries.map((query) => ({\n      ...query,\n      metric: this.templateSrv.replace(query.metric, scopedVars),\n    }));\n  }\n\n  convertToTSDBTime(date: any, roundUp: any, timezone: any) {\n    if (date === 'now') {\n      return null;\n    }\n\n    date = dateMath.parse(date, roundUp, timezone);\n    return date.valueOf();\n  }\n}\n","import _ from 'lodash';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\nimport { textUtil, rangeUtil } from '@grafana/data';\n\nexport class OpenTsQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n  aggregators: any;\n  fillPolicies: any;\n  filterTypes: any;\n  tsdbVersion: any;\n  aggregator: any;\n  downsampleInterval: any;\n  downsampleAggregator: any;\n  downsampleFillPolicy: any;\n  errors: any;\n  suggestMetrics: any;\n  suggestTagKeys: any;\n  suggestTagValues: any;\n  addTagMode: boolean;\n  addFilterMode: boolean;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    super($scope, $injector);\n\n    this.errors = this.validateTarget();\n    this.aggregators = ['avg', 'sum', 'min', 'max', 'dev', 'zimsum', 'mimmin', 'mimmax'];\n    this.fillPolicies = ['none', 'nan', 'null', 'zero'];\n    this.filterTypes = [\n      'wildcard',\n      'iliteral_or',\n      'not_iliteral_or',\n      'not_literal_or',\n      'iwildcard',\n      'literal_or',\n      'regexp',\n    ];\n\n    this.tsdbVersion = this.datasource.tsdbVersion;\n\n    if (!this.target.aggregator) {\n      this.target.aggregator = 'sum';\n    }\n\n    if (!this.target.downsampleAggregator) {\n      this.target.downsampleAggregator = 'avg';\n    }\n\n    if (!this.target.downsampleFillPolicy) {\n      this.target.downsampleFillPolicy = 'none';\n    }\n\n    this.datasource.getAggregators().then((aggs: { length: number }) => {\n      if (aggs.length !== 0) {\n        this.aggregators = aggs;\n      }\n    });\n\n    this.datasource.getFilterTypes().then((filterTypes: { length: number }) => {\n      if (filterTypes.length !== 0) {\n        this.filterTypes = filterTypes;\n      }\n    });\n\n    // needs to be defined here as it is called from typeahead\n    this.suggestMetrics = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('metrics(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n\n    this.suggestTagKeys = (query: any, callback: any) => {\n      this.datasource.suggestTagKeys(this.target.metric).then(callback);\n    };\n\n    this.suggestTagValues = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('suggest_tagv(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n  }\n\n  targetBlur() {\n    this.errors = this.validateTarget();\n    this.refresh();\n  }\n\n  getTextValues(metricFindResult: any) {\n    return _.map(metricFindResult, (value) => {\n      return textUtil.escapeHtml(value.text);\n    });\n  }\n\n  addTag() {\n    if (this.target.filters && this.target.filters.length > 0) {\n      this.errors.tags = 'Please remove filters to use tags, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addTagMode) {\n      this.addTagMode = true;\n      return;\n    }\n\n    if (!this.target.tags) {\n      this.target.tags = {};\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.tags) {\n      this.target.tags[this.target.currentTagKey] = this.target.currentTagValue;\n      this.target.currentTagKey = '';\n      this.target.currentTagValue = '';\n      this.targetBlur();\n    }\n\n    this.addTagMode = false;\n  }\n\n  removeTag(key: string | number) {\n    delete this.target.tags[key];\n    this.targetBlur();\n  }\n\n  editTag(key: string | number, value: any) {\n    this.removeTag(key);\n    this.target.currentTagKey = key;\n    this.target.currentTagValue = value;\n    this.addTag();\n  }\n\n  closeAddTagMode() {\n    this.addTagMode = false;\n    return;\n  }\n\n  addFilter() {\n    if (this.target.tags && _.size(this.target.tags) > 0) {\n      this.errors.filters = 'Please remove tags to use filters, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addFilterMode) {\n      this.addFilterMode = true;\n      return;\n    }\n\n    if (!this.target.filters) {\n      this.target.filters = [];\n    }\n\n    if (!this.target.currentFilterType) {\n      this.target.currentFilterType = 'iliteral_or';\n    }\n\n    if (!this.target.currentFilterGroupBy) {\n      this.target.currentFilterGroupBy = false;\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.filters) {\n      const currentFilter = {\n        type: this.target.currentFilterType,\n        tagk: this.target.currentFilterKey,\n        filter: this.target.currentFilterValue,\n        groupBy: this.target.currentFilterGroupBy,\n      };\n      this.target.filters.push(currentFilter);\n      this.target.currentFilterType = 'literal_or';\n      this.target.currentFilterKey = '';\n      this.target.currentFilterValue = '';\n      this.target.currentFilterGroupBy = false;\n      this.targetBlur();\n    }\n\n    this.addFilterMode = false;\n  }\n\n  removeFilter(index: number) {\n    this.target.filters.splice(index, 1);\n    this.targetBlur();\n  }\n\n  editFilter(fil: { tagk: any; filter: any; type: any; groupBy: any }, index: number) {\n    this.removeFilter(index);\n    this.target.currentFilterKey = fil.tagk;\n    this.target.currentFilterValue = fil.filter;\n    this.target.currentFilterType = fil.type;\n    this.target.currentFilterGroupBy = fil.groupBy;\n    this.addFilter();\n  }\n\n  closeAddFilterMode() {\n    this.addFilterMode = false;\n    return;\n  }\n\n  validateTarget() {\n    const errs: any = {};\n\n    if (this.target.shouldDownsample) {\n      try {\n        if (this.target.downsampleInterval) {\n          rangeUtil.describeInterval(this.target.downsampleInterval);\n        } else {\n          errs.downsampleInterval = \"You must supply a downsample interval (e.g. '1m' or '1h').\";\n        }\n      } catch (err) {\n        errs.downsampleInterval = err.message;\n      }\n    }\n\n    if (this.target.tags && _.has(this.target.tags, this.target.currentTagKey)) {\n      errs.tags = \"Duplicate tag key '\" + this.target.currentTagKey + \"'.\";\n    }\n\n    return errs;\n  }\n}\n","import React, { SyntheticEvent } from 'react';\nimport { InlineFormLabel, LegacyForms } from '@grafana/ui';\nconst { Select, Input } = LegacyForms;\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\nimport { OpenTsdbOptions } from '../types';\n\nconst tsdbVersions = [\n  { label: '<=2.1', value: 1 },\n  { label: '==2.2', value: 2 },\n  { label: '==2.3', value: 3 },\n];\n\nconst tsdbResolutions = [\n  { label: 'second', value: 1 },\n  { label: 'millisecond', value: 2 },\n];\n\ninterface Props {\n  value: DataSourceSettings<OpenTsdbOptions>;\n  onChange: (value: DataSourceSettings<OpenTsdbOptions>) => void;\n}\n\nexport const OpenTsdbDetails = (props: Props) => {\n  const { onChange, value } = props;\n\n  return (\n    <>\n      <h5>OpenTSDB settings</h5>\n      <div className=\"gf-form\">\n        <InlineFormLabel width={7}>Version</InlineFormLabel>\n        <Select\n          options={tsdbVersions}\n          value={tsdbVersions.find((version) => version.value === value.jsonData.tsdbVersion) ?? tsdbVersions[0]}\n          onChange={onSelectChangeHandler('tsdbVersion', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <InlineFormLabel width={7}>Resolution</InlineFormLabel>\n        <Select\n          options={tsdbResolutions}\n          value={\n            tsdbResolutions.find((resolution) => resolution.value === value.jsonData.tsdbResolution) ??\n            tsdbResolutions[0]\n          }\n          onChange={onSelectChangeHandler('tsdbResolution', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <InlineFormLabel width={7}>Lookup Limit</InlineFormLabel>\n        <Input\n          type=\"number\"\n          value={value.jsonData.lookupLimit ?? 1000}\n          onChange={onInputChangeHandler('lookupLimit', value, onChange)}\n        />\n      </div>\n    </>\n  );\n};\n\nconst onSelectChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  newValue: SelectableValue\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: newValue.value,\n    },\n  });\n};\n\nconst onInputChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n","import OpenTsDatasource from './datasource';\nimport { OpenTsQueryCtrl } from './query_ctrl';\nimport { DataSourcePlugin } from '@grafana/data';\nimport { ConfigEditor } from './components/ConfigEditor';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(OpenTsDatasource)\n  .setQueryCtrl(OpenTsQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setAnnotationQueryCtrl(AnnotationsQueryCtrl);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { OpenTsdbDetails } from './OpenTsdbDetails';\nimport { OpenTsdbOptions } from '../types';\n\nexport const ConfigEditor = (props: DataSourcePluginOptionsEditorProps<OpenTsdbOptions>) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:4242\"\n        dataSourceConfig={options}\n        onChange={onOptionsChange}\n      />\n      <OpenTsdbDetails value={options} onChange={onOptionsChange} />\n    </>\n  );\n};\n"],"sourceRoot":""}