{"version":3,"sources":["webpack:///./public/app/plugins/datasource/jaeger/datasource.ts","webpack:///./public/app/plugins/datasource/jaeger/QueryField.tsx","webpack:///./public/app/plugins/datasource/jaeger/module.ts","webpack:///./public/app/plugins/datasource/jaeger/ConfigEditor.tsx","webpack:///./public/app/core/components/TraceToLogsSettings.tsx"],"names":["JaegerDatasource","instanceSettings","timeSrv","getTimeSrv","url","params","this","_request","hideFromInspector","toPromise","res","data","options","id","targets","query","encodeURIComponent","pipe","map","response","MutableDataFrame","fields","name","type","FieldType","trace","values","meta","preferredVisualisationType","of","length","status","message","catchError","err","statusText","JSON","stringify","range","timeRange","start","getTime","from","end","to","apiUrl","baseUrl","serializeParams","req","getBackendSrv","datasourceRequest","DataSourceApi","date","roundUp","dateMath","parse","valueOf","getLabelFromTrace","rootSpan","spans","find","s","references","operationName","duration","traceID","JaegerQueryField","props","context","onLoadOptions","selectedOptions","service","value","findOperations","operations","_isMounted","operationOptions","label","sort","operation","isLeaf","setState","state","serviceOptions","serviceOption","children","operationValue","findTraces","traces","traceOptions","operationOption","datasource","metadataRequest","appEvents","emit","AppEvents","alertError","getTimeRange","traceSearch","limit","lookback","maxDuration","minDuration","onSelectTrace","onChange","onRunQuery","getServices","services","cascaderOptions","noTracesFoundOptions","className","loadData","style","width","e","currentTarget","React","PureComponent","plugin","DataSourcePlugin","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","TraceToLogsSettings","setExploreQueryField","styles","useStyles","getStyles","infoText","tooltip","pluginId","current","jsonData","tracesToLogs","datasourceUid","noDefault","ds","updateDatasourcePluginJsonDataOption","uid","tags","theme","css","spacing","md","colors","textSemiWeak"],"mappings":"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","file":"jaegerPlugin.63a9c1d648180e457252.js","sourcesContent":["import {\n  dateMath,\n  DateTime,\n  MutableDataFrame,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQuery,\n  FieldType,\n} from '@grafana/data';\nimport { getBackendSrv, BackendSrvRequest } from '@grafana/runtime';\nimport { Observable, from, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { serializeParams } from 'app/core/utils/fetch';\n\nexport type JaegerQuery = {\n  query: string;\n} & DataQuery;\n\nexport class JaegerDatasource extends DataSourceApi<JaegerQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings, private readonly timeSrv: TimeSrv = getTimeSrv()) {\n    super(instanceSettings);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this._request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data.data;\n  }\n\n  query(options: DataQueryRequest<JaegerQuery>): Observable<DataQueryResponse> {\n    // At this moment we expect only one target. In case we somehow change the UI to be able to show multiple\n    // traces at one we need to change this.\n    const id = options.targets[0]?.query;\n    if (id) {\n      // TODO: this api is internal, used in jaeger ui. Officially they have gRPC api that should be used.\n      return this._request(`/api/traces/${encodeURIComponent(id)}`).pipe(\n        map((response) => {\n          return {\n            data: [\n              new MutableDataFrame({\n                fields: [\n                  {\n                    name: 'trace',\n                    type: FieldType.trace,\n                    values: response?.data?.data || [],\n                  },\n                ],\n                meta: {\n                  preferredVisualisationType: 'trace',\n                },\n              }),\n            ],\n          };\n        })\n      );\n    } else {\n      return of({\n        data: [\n          new MutableDataFrame({\n            fields: [\n              {\n                name: 'trace',\n                type: FieldType.trace,\n                values: [],\n              },\n            ],\n            meta: {\n              preferredVisualisationType: 'trace',\n            },\n          }),\n        ],\n      });\n    }\n  }\n\n  async testDatasource(): Promise<any> {\n    return this._request('/api/services')\n      .pipe(\n        map((res) => {\n          const values: any[] = res?.data?.data || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and services found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no services received. Verify that Jaeger is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Jaeger: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Jaeger';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${JSON.stringify(err.data)}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n      .toPromise();\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: getTime(range.from, false),\n      end: getTime(range.to, true),\n    };\n  }\n\n  getQueryDisplayText(query: JaegerQuery) {\n    return query.query;\n  }\n\n  private _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    // Hack for proxying metadata requests\n    const baseUrl = `/api/datasources/proxy/${this.instanceSettings.id}`;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return from(getBackendSrv().datasourceRequest(req));\n  }\n}\n\nfunction getTime(date: string | DateTime, roundUp: boolean) {\n  if (typeof date === 'string') {\n    date = dateMath.parse(date, roundUp)!;\n  }\n  return date.valueOf() * 1000;\n}\n","import React from 'react';\nimport { JaegerDatasource, JaegerQuery } from './datasource';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\n\nimport { AppEvents, ExploreQueryFieldProps, TraceSpan, TraceData } from '@grafana/data';\nimport { appEvents } from '../../../core/core';\n\nconst ALL_OPERATIONS_KEY = '__ALL__';\nconst NO_TRACES_KEY = '__NO_TRACES__';\n\ntype Props = ExploreQueryFieldProps<JaegerDatasource, JaegerQuery>;\ninterface State {\n  serviceOptions: CascaderOption[];\n}\n\nfunction findRootSpan(spans: TraceSpan[]): TraceSpan | undefined {\n  return spans.find((s) => !s.references?.length);\n}\n\nfunction getLabelFromTrace(trace: TraceData & { spans: TraceSpan[] }): string {\n  const rootSpan = findRootSpan(trace.spans);\n  if (rootSpan) {\n    return `${rootSpan.operationName} [${rootSpan.duration / 1000} ms]`;\n  }\n  return trace.traceID;\n}\n\nexport class JaegerQueryField extends React.PureComponent<Props, State> {\n  private _isMounted: boolean;\n\n  constructor(props: Props, context: React.Context<any>) {\n    super(props, context);\n    this.state = {\n      serviceOptions: [],\n    };\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n    // We should probably call this periodically to get new services after mount.\n    this.getServices();\n  }\n\n  componentWillUnmount(): void {\n    this._isMounted = false;\n  }\n\n  async getServices() {\n    const url = '/api/services';\n    const { datasource } = this.props;\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (!this._isMounted) {\n        return;\n      }\n\n      if (services) {\n        const serviceOptions: CascaderOption[] = services.sort().map((service) => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n        this.setState({ serviceOptions });\n      }\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load services from Jaeger', error]);\n    }\n  }\n\n  onLoadOptions = async (selectedOptions: CascaderOption[]) => {\n    const service = selectedOptions[0].value;\n    if (selectedOptions.length === 1) {\n      // Load operations\n      const operations: string[] = await this.findOperations(service);\n      if (!this._isMounted) {\n        return;\n      }\n\n      const allOperationsOption: CascaderOption = {\n        label: '[ALL]',\n        value: ALL_OPERATIONS_KEY,\n      };\n      const operationOptions: CascaderOption[] = [\n        allOperationsOption,\n        ...operations.sort().map((operation) => ({\n          label: operation,\n          value: operation,\n          isLeaf: false,\n        })),\n      ];\n      this.setState((state) => {\n        const serviceOptions = state.serviceOptions.map((serviceOption) => {\n          if (serviceOption.value === service) {\n            return {\n              ...serviceOption,\n              children: operationOptions,\n            };\n          }\n          return serviceOption;\n        });\n        return { serviceOptions };\n      });\n    } else if (selectedOptions.length === 2) {\n      // Load traces\n      const operationValue = selectedOptions[1].value;\n      const operation = operationValue === ALL_OPERATIONS_KEY ? '' : operationValue;\n      const traces: any[] = await this.findTraces(service, operation);\n      if (!this._isMounted) {\n        return;\n      }\n\n      let traceOptions: CascaderOption[] = traces.map((trace) => ({\n        label: getLabelFromTrace(trace),\n        value: trace.traceID,\n      }));\n      if (traceOptions.length === 0) {\n        traceOptions = [\n          {\n            label: '[No traces in time range]',\n            value: NO_TRACES_KEY,\n          },\n        ];\n      }\n      this.setState((state) => {\n        // Place new traces into the correct service/operation sub-tree\n        const serviceOptions = state.serviceOptions.map((serviceOption) => {\n          if (serviceOption.value === service && serviceOption.children) {\n            const operationOptions = serviceOption.children.map((operationOption) => {\n              if (operationOption.value === operationValue) {\n                return {\n                  ...operationOption,\n                  children: traceOptions,\n                };\n              }\n              return operationOption;\n            });\n            return {\n              ...serviceOption,\n              children: operationOptions,\n            };\n          }\n          return serviceOption;\n        });\n        return { serviceOptions };\n      });\n    }\n  };\n\n  findOperations = async (service: string) => {\n    const { datasource } = this.props;\n    const url = `/api/services/${encodeURIComponent(service)}/operations`;\n    try {\n      return await datasource.metadataRequest(url);\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load operations from Jaeger', error]);\n    }\n    return [];\n  };\n\n  findTraces = async (service: string, operation?: string) => {\n    const { datasource } = this.props;\n    const { start, end } = datasource.getTimeRange();\n\n    const traceSearch = {\n      start,\n      end,\n      service,\n      operation,\n      limit: 10,\n      lookback: '1h',\n      maxDuration: '',\n      minDuration: '',\n    };\n    const url = '/api/traces';\n    try {\n      return await datasource.metadataRequest(url, traceSearch);\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load traces from Jaeger', error]);\n    }\n    return [];\n  };\n\n  onSelectTrace = (values: string[], selectedOptions: CascaderOption[]) => {\n    const { query, onChange, onRunQuery } = this.props;\n    if (selectedOptions.length === 3) {\n      const traceID = selectedOptions[2].value;\n      onChange({ ...query, query: traceID });\n      onRunQuery();\n    }\n  };\n\n  render() {\n    const { query, onChange } = this.props;\n    const { serviceOptions } = this.state;\n    const cascaderOptions = serviceOptions && serviceOptions.length ? serviceOptions : noTracesFoundOptions;\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--nowrap\">\n          <div className=\"gf-form flex-shrink-0\">\n            <ButtonCascader options={cascaderOptions} onChange={this.onSelectTrace} loadData={this.onLoadOptions}>\n              Traces\n            </ButtonCascader>\n          </div>\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\n            <div className={'slate-query-field__wrapper'}>\n              <div className=\"slate-query-field\">\n                <input\n                  style={{ width: '100%' }}\n                  value={query.query || ''}\n                  onChange={(e) =>\n                    onChange({\n                      ...query,\n                      query: e.currentTarget.value,\n                    })\n                  }\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nexport default JaegerQueryField;\n","import { DataSourcePlugin } from '@grafana/data';\nimport { JaegerDatasource } from './datasource';\nimport { JaegerQueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(JaegerDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(JaegerQueryField);\n","import { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { TraceToLogsSettings } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:16686\"\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <TraceToLogsSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","import {\n  DataSourceJsonData,\n  DataSourcePluginOptionsEditorProps,\n  GrafanaTheme,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { InlineFormLabel, TagsInput, useStyles } from '@grafana/ui';\nimport { css } from 'emotion';\nimport React from 'react';\nimport { DataSourcePicker } from './Select/DataSourcePicker';\n\nexport interface TraceToLogsOptions {\n  datasourceUid?: string;\n  tags?: string[];\n}\n\nexport interface TraceToLogsData extends DataSourceJsonData {\n  tracesToLogs?: TraceToLogsOptions;\n}\n\ninterface Props extends DataSourcePluginOptionsEditorProps<TraceToLogsData> {}\n\nexport function TraceToLogsSettings({ options, onOptionsChange }: Props) {\n  const styles = useStyles(getStyles);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Trace to logs</h3>\n\n      <div className={styles.infoText}>\n        Trace to logs let&apos;s you navigate from a trace span to the selected data source&apos;s log.\n      </div>\n\n      <div className=\"gf-form\">\n        <InlineFormLabel tooltip=\"The data source the trace is going to navigate to\">Data source</InlineFormLabel>\n        <DataSourcePicker\n          pluginId=\"loki\"\n          current={options.jsonData.tracesToLogs?.datasourceUid}\n          noDefault={true}\n          onChange={(ds) =>\n            updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n              datasourceUid: ds.uid,\n              tags: options.jsonData.tracesToLogs?.tags,\n            })\n          }\n        />\n      </div>\n\n      <div className=\"gf-form\">\n        <InlineFormLabel tooltip=\"Tags that will be used in the Loki query. Default tags: 'cluster', 'hostname', 'namespace', 'pod'\">\n          Tags\n        </InlineFormLabel>\n        <TagsInput\n          tags={options.jsonData.tracesToLogs?.tags}\n          onChange={(tags) =>\n            updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n              datasourceUid: options.jsonData.tracesToLogs?.datasourceUid,\n              tags: tags,\n            })\n          }\n        />\n      </div>\n    </>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textSemiWeak};\n  `,\n});\n"],"sourceRoot":""}