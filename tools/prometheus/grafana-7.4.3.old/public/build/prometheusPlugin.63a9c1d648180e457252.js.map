{"version":3,"sources":["webpack:///./public/app/plugins/datasource/prometheus/query_hints.ts","webpack:///./public/app/plugins/datasource/prometheus/types.ts","webpack:///./public/app/plugins/datasource/prometheus/result_transformer.ts","webpack:///./public/app/plugins/datasource/prometheus/metric_find_query.ts","webpack:///./public/app/plugins/datasource/prometheus/variables.ts","webpack:///./public/app/plugins/datasource/prometheus/datasource.ts","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromLink.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/configuration/ExemplarSetting.tsx","webpack:///./public/app/plugins/datasource/prometheus/configuration/ExemplarsSettings.tsx","webpack:///./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx","webpack:///./public/app/plugins/datasource/prometheus/module.ts","webpack:///./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx","webpack:///./public/app/core/utils/CancelablePromise.ts"],"names":["getQueryHints","query","series","datasource","hints","trim","match","push","type","label","fix","action","indexOf","nameMatch","counterNameMetric","metricsMetadata","languageProvider","metricMetadataKeys","Object","keys","certain","length","find","metricName","toLowerCase","metricRegex","RegExp","simpleMetric","verb","ruleMappings","mapping","mappingForQuery","reduce","acc","ruleName","search","_","size","preventSubmit","isFetchErrorResponse","response","isMatrixData","result","transform","transformOptions","options","format","target","step","legendFormat","start","end","expr","responseListLength","scopedVars","refId","valueWithRefId","meta","preferredVisualisationType","getPreferredVisualisationType","instant","mixedQueries","prometheusResult","data","Array","isArray","events","forEach","exemplarData","exemplars","map","exemplar","TIME_SERIES_TIME_FIELD_NAME","timestamp","TIME_SERIES_VALUE_FIELD_NAME","value","labels","seriesLabels","sampledExemplars","bucketedExemplars","values","alignedTs","String","Math","floor","standardDeviation","deviation","sampledBuckets","sort","ts","exemplarsInBucket","sampledBucketValues","ex","descending","curr","prev","sampleExemplars","dataFrame","ArrayDataFrame","dataTopic","DataTopic","Annotations","exemplarTraceIdDestinations","exemplarTraceIdDestination","traceIDField","fields","field","name","links","dataLinks","datasourceUid","dsSettings","getDataSourceSrv","getInstanceSettings","title","url","internal","queryType","datasourceName","targetBlank","getDataLinks","config","resultType","getTimeField","getValueField","md","valueText","timeField","metricFields","metric","filterable","FieldType","number","string","ArrayVector","valueField","valueName","d","val","add","metricField","getLabelValue","parseSampleValue","transformMetricDataToTable","renderTemplate","getTemplateSrv","replace","__name__","labelsWithoutName","labelPart","formatLabels","createLabelInfo","stepMs","NaN","baseTimestamp","dps","dpValue","isNaN","t","endTimestamp","parseValue","displayNameFromDS","transformToDataFrame","sortSeriesByLabel","seriesList","i","topSeries","s","bottomSeries","Error","j","bottomPoint","get","toArray","transformToHistogramOverTime","isInstantQuery","undefined","hasOwnProperty","isMs","time","display","getDisplayProcessor","aliasPattern","aliasData","_match","g1","s1","s2","le1","le2","err","console","error","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","parseFloat","PrometheusMetricFindQuery","this","range","getTimeSrv","timeRange","labelNamesQuery","labelValuesQuery","metricNamesQuery","metricNameQuery","queryResultQuery","toPromise","metricNameAndLabelsQuery","getPrometheusTime","from","to","params","URLSearchParams","toString","metadataRequest","then","text","_labels","filter","uniq","expandable","metricFilterPattern","chain","test","matchedMetricName","instantQuery","performInstantQuery","pipe","metricData","v","k","join","self","getOriginalMetricName","PrometheusVariableSupport","templateSrv","timeSrv","bind","request","targets","of","__interval","interval","__interval_ms","rangeUtil","intervalToMs","getRangeScopedVars","interpolated","interpolateQueryExpr","metricFindQuery","process","results","StandardVariableSupport","PrometheusDatasource","instanceSettings","metricsNameCache","LRU","init","loadRules","prepareTargets","queries","activeTargets","hide","requestId","panelId","app","CoreApp","Explore","instantTarget","cloneDeep","maxDataPoints","rangeTarget","exemplarTarget","createQuery","handleErrors","message","statusText","safeStringifyValue","status","createAnnotationQueryOptions","annotation","editorSrc","basicAuth","withCredentials","jsonData","timeInterval","queryTimeout","httpMethod","directUrl","PrometheusLanguageProvider","lookupsDisabled","disableMetricsLookup","customQueryParameters","variables","httpOptions","headers","dashboardId","overrides","defaults","method","entries","encodeURIComponent","Authorization","getBackendSrv","fetch","key","_request","hideFromInspector","variable","multi","includeAll","prometheusRegularEscape","prometheusSpecialRegexEscape","escapedValues","variableExists","exploreQuery","panelsQuery","state","LoadingState","Done","runningQueriesCount","some","subQueries","index","filterAndMapResponse","tap","cancelled","Loading","getExemplars","performTimeSeriesQuery","merge","observables","forkJoin","current","hinting","ceil","intervalToSeconds","minInterval","scrapeInterval","intervalFactor","adjustedInterval","adjustInterval","getRateIntervalScopedVariable","assign","getAdhocFilters","operator","addLabelToQuery","adjusted","utcOffsetSec","alignedEnd","alignedStart","alignRange","utcOffset","_addTracingHeaders","rateInterval","max","__rate_interval","safeInterval","catchError","throwError","Promise","resolve","msRange","diff","sRange","round","__range_ms","__range_s","__range","tagKeys","titleFormat","textFormat","queryOptions","queryModel","eventList","splitKeys","split","tags","includes","timestampValue","useValueForTime","activeValuesTimestamps","latestEvent","timeEnd","now","Date","getTime","expandedQueries","res","groups","extractRuleMappingFromGroups","log","expression","expandRecordingRules","date","roundUp","dateMath","parse","valueOf","labelData","DataSourceApi","group","rules","rule","HISTOGRAM_GROUP","willApplySuggestion","suggestion","typeaheadContext","typeaheadText","nextChar","DOMUtil","getNextCharacter","PromQueryField","props","context","refreshHint","isDataFrame","toLegacyResponseData","hint","setState","refreshMetrics","languageProviderInitializationPromise","makePromiseCancelable","promise","remainingTasks","all","onUpdateLanguage","isCanceled","onChangeMetrics","selectedOptions","selectedOption","children","prefix","onChangeQuery","override","onChange","onRunQuery","onClickHintFix","modifyQuery","histogramMetrics","metrics","metricsByPrefix","metadata","ruleRegex","ruleNames","rulesOption","slice","metricsOptions","groupBy","metricsForPrefix","m","option","help","toUpperCase","addMetricsMetadata","sortBy","groupMetricsByPrefix","histogramOptions","hm","isLeaf","syntaxLoaded","onTypeahead","typeahead","suggestions","history","wrapperClasses","labelKey","provideCompletionItems","plugins","BracesPlugin","SlatePrism","onlyIn","node","getSyntax","prismLanguages","promql","syntax","cancel","prevProps","changedRangeToRefresh","rangeChangedToRefresh","prevRange","sameMinuteFrom","roundMsToMin","sameMinuteTo","metricsLookupDisabled","hasSyntax","ExtraFieldElement","cleanText","chooserText","buttonDisabled","className","disabled","additionalPlugins","onWillApplySuggestion","onBlur","placeholder","portalOrigin","onClick","React","PureComponent","memo","panelData","useState","href","setHref","useEffect","rangeDiff","endTime","utc","args","getExternalLink","rel","onExemplarsChange","e","checked","PromExemplarField","labelWidth","Switch","LegacyForms","FORMAT_OPTIONS","INTERVAL_FACTOR_OPTIONS","PromQueryEditor","onFieldChange","onFormatChange","formatOption","onInstantChange","onIntervalChange","currentTarget","onIntervalFactorChange","intervalFactorOption","onLegendChange","Boolean","width","tooltip","isSearchable","CHEAT_SHEET_ITEMS","PromCheatSheet","item","onClickExample","PromExploreExtraField","stepValue","onStepChange","onQueryTypeChange","onKeyDownFunc","aria-label","data-testid","cx","css","onKeyDown","onChangeQueryStep","shiftKey","ctrlKey","ExemplarSetting","onDelete","isInternalLink","setIsInternalLink","ev","variant","icon","event","preventDefault","DataSourcePicker","tracing","noDefault","ds","uid","spellCheck","ExemplarsSettings","newField","newOptions","splice","Select","Input","FormField","PromSettings","onOptionsChange","inputEl","onChangeHandler","validationEvents","promSettingsValidationEvents","o","labelClass","onUpdateDatasourceJsonDataOptionChecked","exemplarOptions","updateDatasourcePluginJsonDataOption","EventsWithValidation","regexValidation","getValueFromEventItem","eventItem","PrometheusAnnotationsQueryCtrl","stepDefaultValuePlaceholder","templateUrl","plugin","DataSourcePlugin","setQueryEditor","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","sigV4AuthToggleEnabled","sigV4AuthEnabled","setExploreMetricsQueryField","PromExploreQueryEditor","setAnnotationQueryCtrl","setQueryEditorHelp","hasCanceled_","reject","catch"],"mappings":"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","file":"prometheusPlugin.63a9c1d648180e457252.js","sourcesContent":["import _ from 'lodash';\nimport { QueryHint, QueryFix } from '@grafana/data';\nimport { PrometheusDatasource } from './datasource';\n\n/**\n * Number of time series results needed before starting to suggest sum aggregation hints\n */\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\n\nexport function getQueryHints(query: string, series?: any[], datasource?: PrometheusDatasource): QueryHint[] {\n  const hints = [];\n\n  // ..._bucket metric needs a histogram_quantile()\n  const histogramMetric = query.trim().match(/^\\w+_bucket$/);\n  if (histogramMetric) {\n    const label = 'Time series has buckets, you probably wanted a histogram.';\n    hints.push({\n      type: 'HISTOGRAM_QUANTILE',\n      label,\n      fix: {\n        label: 'Fix by adding histogram_quantile().',\n        action: {\n          type: 'ADD_HISTOGRAM_QUANTILE',\n          query,\n        },\n      } as QueryFix,\n    });\n  }\n\n  // Check for need of rate()\n  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {\n    // Use metric metadata for exact types\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\n    const metricsMetadata = datasource?.languageProvider?.metricsMetadata ?? {};\n    const metricMetadataKeys = Object.keys(metricsMetadata);\n    let certain = false;\n\n    if (metricMetadataKeys.length > 0) {\n      counterNameMetric =\n        metricMetadataKeys.find((metricName) => {\n          // Only considering first type information, could be non-deterministic\n          const metadata = metricsMetadata[metricName][0];\n          if (metadata.type.toLowerCase() === 'counter') {\n            const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\n            if (query.match(metricRegex)) {\n              certain = true;\n              return true;\n            }\n          }\n          return false;\n        }) ?? '';\n    }\n\n    if (counterNameMetric) {\n      const simpleMetric = query.trim().match(/^\\w+$/);\n      const verb = certain ? 'is' : 'looks like';\n      let label = `Metric ${counterNameMetric} ${verb} a counter.`;\n      let fix: QueryFix | undefined;\n\n      if (simpleMetric) {\n        fix = {\n          label: 'Fix by adding rate().',\n          action: {\n            type: 'ADD_RATE',\n            query,\n          },\n        };\n      } else {\n        label = `${label} Try applying a rate() function.`;\n      }\n\n      hints.push({\n        type: 'APPLY_RATE',\n        label,\n        fix,\n      });\n    }\n  }\n\n  // Check for recording rules expansion\n  if (datasource && datasource.ruleMappings) {\n    const mapping = datasource.ruleMappings;\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\n      if (query.search(ruleName) > -1) {\n        return {\n          ...acc,\n          [ruleName]: mapping[ruleName],\n        };\n      }\n      return acc;\n    }, {});\n    if (_.size(mappingForQuery) > 0) {\n      const label = 'Query contains recording rules.';\n      hints.push({\n        type: 'EXPAND_RULES',\n        label,\n        fix: ({\n          label: 'Expand rules',\n          action: {\n            type: 'EXPAND_RULES',\n            query,\n            mapping: mappingForQuery,\n          },\n        } as any) as QueryFix,\n      });\n    }\n  }\n\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\n    const simpleMetric = query.trim().match(/^\\w+$/);\n    if (simpleMetric) {\n      hints.push({\n        type: 'ADD_SUM',\n        label: 'Many time series results returned.',\n        fix: {\n          label: 'Consider aggregating with sum().',\n          action: {\n            type: 'ADD_SUM',\n            query: query,\n            preventSubmit: true,\n          },\n        } as QueryFix,\n      });\n    }\n  }\n\n  return hints;\n}\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\nimport { FetchError } from '@grafana/runtime';\n\nexport interface PromQuery extends DataQuery {\n  expr: string;\n  format?: string;\n  instant?: boolean;\n  range?: boolean;\n  exemplar?: boolean;\n  hinting?: boolean;\n  interval?: string;\n  intervalFactor?: number;\n  legendFormat?: string;\n  valueWithRefId?: boolean;\n  requestId?: string;\n  showingGraph?: boolean;\n  showingTable?: boolean;\n}\n\nexport interface PromOptions extends DataSourceJsonData {\n  timeInterval: string;\n  queryTimeout: string;\n  httpMethod: string;\n  directUrl: string;\n  customQueryParameters?: string;\n  disableMetricsLookup?: boolean;\n  exemplarTraceIdDestinations?: ExemplarTraceIdDestination[];\n}\n\nexport type ExemplarTraceIdDestination = {\n  name: string;\n  url?: string;\n  datasourceUid?: string;\n};\n\nexport interface PromQueryRequest extends PromQuery {\n  step?: number;\n  requestId?: string;\n  start: number;\n  end: number;\n  headers?: any;\n}\n\nexport interface PromMetricsMetadataItem {\n  type: string;\n  help: string;\n  unit?: string;\n}\n\nexport interface PromMetricsMetadata {\n  [metric: string]: PromMetricsMetadataItem[];\n}\n\nexport interface PromDataSuccessResponse<T = PromData> {\n  status: 'success';\n  data: T;\n}\n\nexport interface PromDataErrorResponse<T = PromData> {\n  status: 'error';\n  errorType: string;\n  error: string;\n  data: T;\n}\n\nexport type PromData = PromMatrixData | PromVectorData | PromScalarData | PromExemplarData[] | null;\n\nexport interface Labels {\n  [index: string]: any;\n}\n\nexport interface Exemplar {\n  labels: Labels;\n  value: number;\n  timestamp: number;\n}\n\nexport interface PromExemplarData {\n  seriesLabels: PromMetric;\n  exemplars: Exemplar[];\n}\n\nexport interface PromVectorData {\n  resultType: 'vector';\n  result: Array<{\n    metric: PromMetric;\n    value: PromValue;\n  }>;\n}\n\nexport interface PromMatrixData {\n  resultType: 'matrix';\n  result: Array<{\n    metric: PromMetric;\n    values: PromValue[];\n  }>;\n}\n\nexport interface PromScalarData {\n  resultType: 'scalar';\n  result: PromValue;\n}\n\nexport type PromValue = [number, any];\n\nexport interface PromMetric {\n  __name__?: string;\n  [index: string]: any;\n}\n\nexport function isFetchErrorResponse(response: any): response is FetchError {\n  return 'cancelled' in response;\n}\n\nexport function isMatrixData(result: MatrixOrVectorResult): result is PromMatrixData['result'][0] {\n  return 'values' in result;\n}\n\nexport function isExemplarData(result: PromData): result is PromExemplarData[] {\n  if (result == null || !Array.isArray(result)) {\n    return false;\n  }\n  return 'exemplars' in result[0];\n}\n\nexport type MatrixOrVectorResult = PromMatrixData['result'][0] | PromVectorData['result'][0];\n\nexport interface TransformOptions {\n  format?: string;\n  step?: number;\n  legendFormat?: string;\n  start: number;\n  end: number;\n  query: string;\n  responseListLength: number;\n  scopedVars?: ScopedVars;\n  refId: string;\n  valueWithRefId?: boolean;\n  meta: QueryResultMeta;\n}\n\nexport interface PromLabelQueryResponse {\n  data: {\n    status: string;\n    data: string[];\n  };\n  cancelled?: boolean;\n}\n","import {\n  ArrayDataFrame,\n  ArrayVector,\n  DataFrame,\n  DataLink,\n  DataTopic,\n  Field,\n  FieldType,\n  formatLabels,\n  getDisplayProcessor,\n  Labels,\n  MutableField,\n  ScopedVars,\n  TIME_SERIES_TIME_FIELD_NAME,\n  TIME_SERIES_VALUE_FIELD_NAME,\n} from '@grafana/data';\nimport { FetchResponse, getDataSourceSrv, getTemplateSrv } from '@grafana/runtime';\nimport { descending, deviation } from 'd3';\nimport {\n  ExemplarTraceIdDestination,\n  isExemplarData,\n  isMatrixData,\n  MatrixOrVectorResult,\n  PromDataSuccessResponse,\n  PromMetric,\n  PromQuery,\n  PromQueryRequest,\n  PromValue,\n  TransformOptions,\n} from './types';\n\nconst POSITIVE_INFINITY_SAMPLE_VALUE = '+Inf';\nconst NEGATIVE_INFINITY_SAMPLE_VALUE = '-Inf';\n\ninterface TimeAndValue {\n  [TIME_SERIES_TIME_FIELD_NAME]: number;\n  [TIME_SERIES_VALUE_FIELD_NAME]: number;\n}\n\nexport function transform(\n  response: FetchResponse<PromDataSuccessResponse>,\n  transformOptions: {\n    query: PromQueryRequest;\n    exemplarTraceIdDestinations?: ExemplarTraceIdDestination[];\n    target: PromQuery;\n    responseListLength: number;\n    scopedVars?: ScopedVars;\n    mixedQueries?: boolean;\n  }\n) {\n  // Create options object from transformOptions\n  const options: TransformOptions = {\n    format: transformOptions.target.format,\n    step: transformOptions.query.step,\n    legendFormat: transformOptions.target.legendFormat,\n    start: transformOptions.query.start,\n    end: transformOptions.query.end,\n    query: transformOptions.query.expr,\n    responseListLength: transformOptions.responseListLength,\n    scopedVars: transformOptions.scopedVars,\n    refId: transformOptions.target.refId,\n    valueWithRefId: transformOptions.target.valueWithRefId,\n    meta: {\n      /**\n       * Fix for showing of Prometheus results in Explore table.\n       * We want to show result of instant query always in table and result of range query based on target.runAll;\n       */\n      preferredVisualisationType: getPreferredVisualisationType(\n        transformOptions.query.instant,\n        transformOptions.mixedQueries\n      ),\n    },\n  };\n  const prometheusResult = response.data.data;\n\n  if (isExemplarData(prometheusResult)) {\n    const events: TimeAndValue[] = [];\n    prometheusResult.forEach((exemplarData) => {\n      const data = exemplarData.exemplars.map((exemplar) => {\n        return {\n          [TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,\n          [TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value,\n          ...exemplar.labels,\n          ...exemplarData.seriesLabels,\n        };\n      });\n      events.push(...data);\n    });\n\n    // Grouping exemplars by step\n    const sampledExemplars = sampleExemplars(events, options);\n\n    const dataFrame = new ArrayDataFrame(sampledExemplars);\n    dataFrame.meta = { dataTopic: DataTopic.Annotations };\n\n    // Add data links if configured\n    if (transformOptions.exemplarTraceIdDestinations?.length) {\n      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {\n        const traceIDField = dataFrame.fields.find((field) => field.name === exemplarTraceIdDestination!.name);\n        if (traceIDField) {\n          const links = getDataLinks(exemplarTraceIdDestination);\n          traceIDField.config.links = traceIDField.config.links?.length\n            ? [...traceIDField.config.links, ...links]\n            : links;\n        }\n      }\n    }\n    return [dataFrame];\n  }\n\n  if (!prometheusResult?.result) {\n    return [];\n  }\n\n  // Return early if result type is scalar\n  if (prometheusResult.resultType === 'scalar') {\n    return [\n      {\n        meta: options.meta,\n        refId: options.refId,\n        length: 1,\n        fields: [getTimeField([prometheusResult.result]), getValueField({ data: [prometheusResult.result] })],\n      },\n    ];\n  }\n\n  // Return early again if the format is table, this needs special transformation.\n  if (options.format === 'table') {\n    const tableData = transformMetricDataToTable(prometheusResult.result, options);\n    return [tableData];\n  }\n\n  // Process matrix and vector results to DataFrame\n  const dataFrame: DataFrame[] = [];\n  prometheusResult.result.forEach((data: MatrixOrVectorResult) => dataFrame.push(transformToDataFrame(data, options)));\n\n  // When format is heatmap use the already created data frames and transform it more\n  if (options.format === 'heatmap') {\n    dataFrame.sort(sortSeriesByLabel);\n    const seriesList = transformToHistogramOverTime(dataFrame);\n    return seriesList;\n  }\n\n  // Return matrix or vector result as DataFrame[]\n  return dataFrame;\n}\n\nfunction getDataLinks(options: ExemplarTraceIdDestination): DataLink[] {\n  const dataLinks: DataLink[] = [];\n\n  if (options.datasourceUid) {\n    const dataSourceSrv = getDataSourceSrv();\n    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid);\n\n    dataLinks.push({\n      title: `Query with ${dsSettings?.name}`,\n      url: '',\n      internal: {\n        query: { query: '${__value.raw}', queryType: 'getTrace' },\n        datasourceUid: options.datasourceUid,\n        datasourceName: dsSettings?.name ?? 'Data source not found',\n      },\n    });\n  }\n\n  if (options.url) {\n    dataLinks.push({\n      title: `Go to ${options.url}`,\n      url: options.url,\n      targetBlank: true,\n    });\n  }\n  return dataLinks;\n}\n\n/**\n * Reduce the density of the exemplars by making sure that the highest value exemplar is included\n * and then only the ones that are 2 times the standard deviation of the all the values.\n * This makes sure not to show too many dots near each other.\n */\nfunction sampleExemplars(events: TimeAndValue[], options: TransformOptions) {\n  const step = options.step || 15;\n  const bucketedExemplars: { [ts: string]: TimeAndValue[] } = {};\n  const values: number[] = [];\n  for (const exemplar of events) {\n    // Align exemplar timestamp to nearest step second\n    const alignedTs = String(Math.floor(exemplar[TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);\n    if (!bucketedExemplars[alignedTs]) {\n      // New bucket found\n      bucketedExemplars[alignedTs] = [];\n    }\n    bucketedExemplars[alignedTs].push(exemplar);\n    values.push(exemplar[TIME_SERIES_VALUE_FIELD_NAME]);\n  }\n\n  // Getting exemplars from each bucket\n  const standardDeviation = deviation(values);\n  const sampledBuckets = Object.keys(bucketedExemplars).sort();\n  const sampledExemplars = [];\n  for (const ts of sampledBuckets) {\n    const exemplarsInBucket = bucketedExemplars[ts];\n    if (exemplarsInBucket.length === 1) {\n      sampledExemplars.push(exemplarsInBucket[0]);\n    } else {\n      // Choose which values to sample\n      const bucketValues = exemplarsInBucket.map((ex) => ex[TIME_SERIES_VALUE_FIELD_NAME]).sort(descending);\n      const sampledBucketValues = bucketValues.reduce((acc: number[], curr) => {\n        if (acc.length === 0) {\n          // First value is max and is always added\n          acc.push(curr);\n        } else {\n          // Then take values only when at least 2 standard deviation distance to previously taken value\n          const prev = acc[acc.length - 1];\n          if (standardDeviation && prev - curr >= 2 * standardDeviation) {\n            acc.push(curr);\n          }\n        }\n        return acc;\n      }, []);\n      // Find the exemplars for the sampled values\n      sampledExemplars.push(\n        ...sampledBucketValues.map(\n          (value) => exemplarsInBucket.find((ex) => ex[TIME_SERIES_VALUE_FIELD_NAME] === value)!\n        )\n      );\n    }\n  }\n  return sampledExemplars;\n}\n\nfunction getPreferredVisualisationType(isInstantQuery?: boolean, mixedQueries?: boolean) {\n  if (isInstantQuery) {\n    return 'table';\n  }\n\n  return mixedQueries ? 'graph' : undefined;\n}\n\n/**\n * Transforms matrix and vector result from Prometheus result to DataFrame\n */\nfunction transformToDataFrame(data: MatrixOrVectorResult, options: TransformOptions): DataFrame {\n  const { name, labels } = createLabelInfo(data.metric, options);\n\n  const fields: Field[] = [];\n\n  if (isMatrixData(data)) {\n    const stepMs = options.step ? options.step * 1000 : NaN;\n    let baseTimestamp = options.start * 1000;\n    const dps: PromValue[] = [];\n\n    for (const value of data.values) {\n      let dpValue: number | null = parseSampleValue(value[1]);\n\n      if (isNaN(dpValue)) {\n        dpValue = null;\n      }\n\n      const timestamp = value[0] * 1000;\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\n        dps.push([t, null]);\n      }\n      baseTimestamp = timestamp + stepMs;\n      dps.push([timestamp, dpValue]);\n    }\n\n    const endTimestamp = options.end * 1000;\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\n      dps.push([t, null]);\n    }\n    fields.push(getTimeField(dps, true));\n    fields.push(getValueField({ data: dps, parseValue: false, labels, displayNameFromDS: name }));\n  } else {\n    fields.push(getTimeField([data.value]));\n    fields.push(getValueField({ data: [data.value], labels, displayNameFromDS: name }));\n  }\n\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: fields[0].values.length,\n    fields,\n    name,\n  };\n}\n\nfunction transformMetricDataToTable(md: MatrixOrVectorResult[], options: TransformOptions): DataFrame {\n  if (!md || md.length === 0) {\n    return {\n      meta: options.meta,\n      refId: options.refId,\n      length: 0,\n      fields: [],\n    };\n  }\n\n  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';\n\n  const timeField = getTimeField([]);\n  const metricFields = Object.keys(md.reduce((acc, series) => ({ ...acc, ...series.metric }), {}))\n    .sort()\n    .map((label) => {\n      // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results\n      // Only \"le\" label has a number field type\n      const numberField = label === 'le';\n      return {\n        name: label,\n        config: { filterable: true },\n        type: numberField ? FieldType.number : FieldType.string,\n        values: new ArrayVector(),\n      };\n    });\n  const valueField = getValueField({ data: [], valueName: valueText });\n\n  md.forEach((d) => {\n    if (isMatrixData(d)) {\n      d.values.forEach((val) => {\n        timeField.values.add(val[0] * 1000);\n        metricFields.forEach((metricField) => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n        valueField.values.add(parseSampleValue(val[1]));\n      });\n    } else {\n      timeField.values.add(d.value[0] * 1000);\n      metricFields.forEach((metricField) => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n      valueField.values.add(parseSampleValue(d.value[1]));\n    }\n  });\n\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: timeField.values.length,\n    fields: [timeField, ...metricFields, valueField],\n  };\n}\n\nfunction getLabelValue(metric: PromMetric, label: string): string | number {\n  if (metric.hasOwnProperty(label)) {\n    if (label === 'le') {\n      return parseSampleValue(metric[label]);\n    }\n    return metric[label];\n  }\n  return '';\n}\n\nfunction getTimeField(data: PromValue[], isMs = false): MutableField {\n  return {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector<number>(data.map((val) => (isMs ? val[0] : val[0] * 1000))),\n  };\n}\ntype ValueFieldOptions = {\n  data: PromValue[];\n  valueName?: string;\n  parseValue?: boolean;\n  labels?: Labels;\n  displayNameFromDS?: string;\n};\n\nfunction getValueField({\n  data,\n  valueName = TIME_SERIES_VALUE_FIELD_NAME,\n  parseValue = true,\n  labels,\n  displayNameFromDS,\n}: ValueFieldOptions): MutableField {\n  return {\n    name: valueName,\n    type: FieldType.number,\n    display: getDisplayProcessor(),\n    config: {\n      displayNameFromDS,\n    },\n    labels,\n    values: new ArrayVector<number | null>(data.map((val) => (parseValue ? parseSampleValue(val[1]) : val[1]))),\n  };\n}\n\nfunction createLabelInfo(labels: { [key: string]: string }, options: TransformOptions) {\n  if (options?.legendFormat) {\n    const title = renderTemplate(getTemplateSrv().replace(options.legendFormat, options?.scopedVars), labels);\n    return { name: title, labels };\n  }\n\n  const { __name__, ...labelsWithoutName } = labels;\n  const labelPart = formatLabels(labelsWithoutName);\n  let title = `${__name__ ?? ''}${labelPart}`;\n\n  if (!title) {\n    title = options.query;\n  }\n\n  return { name: title, labels: labelsWithoutName };\n}\n\nexport function getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map((label) => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nexport function renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_match, g1) => {\n    if (aliasData[g1]) {\n      return aliasData[g1];\n    }\n    return '';\n  });\n}\n\nfunction transformToHistogramOverTime(seriesList: DataFrame[]) {\n  /*      t1 = timestamp1, t2 = timestamp2 etc.\n            t1  t2  t3          t1  t2  t3\n    le10    10  10  0     =>    10  10  0\n    le20    20  10  30    =>    10  0   30\n    le30    30  10  35    =>    10  0   5\n    */\n  for (let i = seriesList.length - 1; i > 0; i--) {\n    const topSeries = seriesList[i].fields.find((s) => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n    const bottomSeries = seriesList[i - 1].fields.find((s) => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n    if (!topSeries || !bottomSeries) {\n      throw new Error('Prometheus heatmap transform error: data should be a time series');\n    }\n\n    for (let j = 0; j < topSeries.values.length; j++) {\n      const bottomPoint = bottomSeries.values.get(j) || [0];\n      topSeries.values.toArray()[j] -= bottomPoint;\n    }\n  }\n\n  return seriesList;\n}\n\nfunction sortSeriesByLabel(s1: DataFrame, s2: DataFrame): number {\n  let le1, le2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    le1 = parseSampleValue(s1.name ?? '');\n    le2 = parseSampleValue(s2.name ?? '');\n  } catch (err) {\n    console.error(err);\n    return 0;\n  }\n\n  if (le1 > le2) {\n    return 1;\n  }\n\n  if (le1 < le2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseSampleValue(value: string): number {\n  switch (value) {\n    case POSITIVE_INFINITY_SAMPLE_VALUE:\n      return Number.POSITIVE_INFINITY;\n    case NEGATIVE_INFINITY_SAMPLE_VALUE:\n      return Number.NEGATIVE_INFINITY;\n    default:\n      return parseFloat(value);\n  }\n}\n","import _ from 'lodash';\nimport { map } from 'rxjs/operators';\nimport { MetricFindValue, TimeRange } from '@grafana/data';\nimport { PrometheusDatasource } from './datasource';\nimport { PromQueryRequest } from './types';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\n\nexport default class PrometheusMetricFindQuery {\n  range: TimeRange;\n\n  constructor(private datasource: PrometheusDatasource, private query: string) {\n    this.datasource = datasource;\n    this.query = query;\n    this.range = getTimeSrv().timeRange();\n  }\n\n  process(): Promise<MetricFindValue[]> {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n    const metricNamesRegex = /^metrics\\((.+)\\)\\s*$/;\n    const queryResultRegex = /^query_result\\((.+)\\)\\s*$/;\n    const labelNamesQuery = this.query.match(labelNamesRegex);\n    if (labelNamesQuery) {\n      return this.labelNamesQuery();\n    }\n\n    const labelValuesQuery = this.query.match(labelValuesRegex);\n    if (labelValuesQuery) {\n      if (labelValuesQuery[1]) {\n        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);\n      } else {\n        return this.labelValuesQuery(labelValuesQuery[2]);\n      }\n    }\n\n    const metricNamesQuery = this.query.match(metricNamesRegex);\n    if (metricNamesQuery) {\n      return this.metricNameQuery(metricNamesQuery[1]);\n    }\n\n    const queryResultQuery = this.query.match(queryResultRegex);\n    if (queryResultQuery) {\n      return this.queryResultQuery(queryResultQuery[1]).toPromise();\n    }\n\n    // if query contains full metric name, return metric name and label list\n    return this.metricNameAndLabelsQuery(this.query);\n  }\n\n  labelNamesQuery() {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      start: start.toString(),\n      end: end.toString(),\n    });\n\n    const url = `/api/v1/labels?${params.toString()}`;\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, (value) => {\n        return { text: value };\n      });\n    });\n  }\n\n  labelValuesQuery(label: string, metric?: string) {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n\n    let url: string;\n\n    if (!metric) {\n      const params = new URLSearchParams({\n        start: start.toString(),\n        end: end.toString(),\n      });\n      // return label values globally\n      url = `/api/v1/label/${label}/values?${params.toString()}`;\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        return _.map(result.data.data, (value) => {\n          return { text: value };\n        });\n      });\n    } else {\n      const params = new URLSearchParams({\n        'match[]': metric,\n        start: start.toString(),\n        end: end.toString(),\n      });\n      url = `/api/v1/series?${params.toString()}`;\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        const _labels = _.map(result.data.data, (metric) => {\n          return metric[label] || '';\n        }).filter((label) => {\n          return label !== '';\n        });\n\n        return _.uniq(_labels).map((metric) => {\n          return {\n            text: metric,\n            expandable: true,\n          };\n        });\n      });\n    }\n  }\n\n  metricNameQuery(metricFilterPattern: string) {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      start: start.toString(),\n      end: end.toString(),\n    });\n    const url = `/api/v1/label/__name__/values?${params.toString()}`;\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.chain(result.data.data)\n        .filter((metricName) => {\n          const r = new RegExp(metricFilterPattern);\n          return r.test(metricName);\n        })\n        .map((matchedMetricName) => {\n          return {\n            text: matchedMetricName,\n            expandable: true,\n          };\n        })\n        .value();\n    });\n  }\n\n  queryResultQuery(query: string) {\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const instantQuery: PromQueryRequest = { expr: query } as PromQueryRequest;\n    return this.datasource.performInstantQuery(instantQuery, end).pipe(\n      map((result) => {\n        return _.map(result.data.data.result, (metricData) => {\n          let text = metricData.metric.__name__ || '';\n          delete metricData.metric.__name__;\n          text +=\n            '{' +\n            _.map(metricData.metric, (v, k) => {\n              return k + '=\"' + v + '\"';\n            }).join(',') +\n            '}';\n          text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;\n\n          return {\n            text: text,\n            expandable: true,\n          };\n        });\n      })\n    );\n  }\n\n  metricNameAndLabelsQuery(query: string): Promise<MetricFindValue[]> {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      'match[]': query,\n      start: start.toString(),\n      end: end.toString(),\n    });\n\n    const url = `/api/v1/series?${params.toString()}`;\n    const self = this;\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, (metric: { [key: string]: string }) => {\n        return {\n          text: self.datasource.getOriginalMetricName(metric),\n          expandable: true,\n        };\n      });\n    });\n  }\n}\n","import { from, Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport {\n  DataQueryRequest,\n  DataQueryResponse,\n  rangeUtil,\n  StandardVariableQuery,\n  StandardVariableSupport,\n} from '@grafana/data';\nimport { getTemplateSrv, TemplateSrv } from '@grafana/runtime';\n\nimport { PrometheusDatasource } from './datasource';\nimport { PromQuery } from './types';\nimport PrometheusMetricFindQuery from './metric_find_query';\nimport { getTimeSrv, TimeSrv } from '../../../features/dashboard/services/TimeSrv';\n\nexport class PrometheusVariableSupport extends StandardVariableSupport<PrometheusDatasource> {\n  constructor(\n    private readonly datasource: PrometheusDatasource,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super();\n    this.query = this.query.bind(this);\n  }\n\n  query(request: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\n    const query = request.targets[0].expr;\n    if (!query) {\n      return of({ data: [] });\n    }\n\n    const scopedVars = {\n      ...request.scopedVars,\n      __interval: { text: this.datasource.interval, value: this.datasource.interval },\n      __interval_ms: {\n        text: rangeUtil.intervalToMs(this.datasource.interval),\n        value: rangeUtil.intervalToMs(this.datasource.interval),\n      },\n      ...this.datasource.getRangeScopedVars(this.timeSrv.timeRange()),\n    };\n\n    const interpolated = this.templateSrv.replace(query, scopedVars, this.datasource.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this.datasource, interpolated);\n    const metricFindStream = from(metricFindQuery.process());\n\n    return metricFindStream.pipe(map((results) => ({ data: results })));\n  }\n\n  toDataQuery(query: StandardVariableQuery): PromQuery {\n    return {\n      refId: 'PrometheusDatasource-VariableQuery',\n      expr: query.query,\n    };\n  }\n}\n","import {\n  AnnotationEvent,\n  CoreApp,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  LoadingState,\n  rangeUtil,\n  ScopedVars,\n  TimeRange,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchError, getBackendSrv } from '@grafana/runtime';\nimport { safeStringifyValue } from 'app/core/utils/explore';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport cloneDeep from 'lodash/cloneDeep';\nimport defaults from 'lodash/defaults';\nimport LRU from 'lru-cache';\nimport { forkJoin, merge, Observable, of, pipe, throwError } from 'rxjs';\nimport { catchError, filter, map, tap } from 'rxjs/operators';\nimport addLabelToQuery from './add_label_to_query';\nimport PrometheusLanguageProvider from './language_provider';\nimport { expandRecordingRules } from './language_utils';\nimport { getQueryHints } from './query_hints';\nimport { getOriginalMetricName, renderTemplate, transform } from './result_transformer';\nimport {\n  ExemplarTraceIdDestination,\n  isFetchErrorResponse,\n  PromDataErrorResponse,\n  PromDataSuccessResponse,\n  PromExemplarData,\n  PromMatrixData,\n  PromOptions,\n  PromQuery,\n  PromQueryRequest,\n  PromScalarData,\n  PromVectorData,\n} from './types';\nimport { PrometheusVariableSupport } from './variables';\nimport PrometheusMetricFindQuery from './metric_find_query';\n\nexport const ANNOTATION_QUERY_STEP_DEFAULT = '60s';\n\nexport class PrometheusDatasource extends DataSourceApi<PromQuery, PromOptions> {\n  type: string;\n  editorSrc: string;\n  ruleMappings: { [index: string]: string };\n  url: string;\n  directUrl: string;\n  basicAuth: any;\n  withCredentials: any;\n  metricsNameCache = new LRU<string, string[]>(10);\n  interval: string;\n  queryTimeout: string;\n  httpMethod: string;\n  languageProvider: PrometheusLanguageProvider;\n  exemplarTraceIdDestinations: ExemplarTraceIdDestination[] | undefined;\n  lookupsDisabled: boolean;\n  customQueryParameters: any;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<PromOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.type = 'prometheus';\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\n    this.url = instanceSettings.url!;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n    this.directUrl = instanceSettings.jsonData.directUrl;\n    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n    this.ruleMappings = {};\n    this.languageProvider = new PrometheusLanguageProvider(this);\n    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n\n    this.variables = new PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);\n  }\n\n  init = () => {\n    this.loadRules();\n  };\n\n  getQueryDisplayText(query: PromQuery) {\n    return query.expr;\n  }\n\n  _addTracingHeaders(httpOptions: PromQueryRequest, options: DataQueryRequest<PromQuery>) {\n    httpOptions.headers = {};\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n\n  _request<T = any>(url: string, data: Record<string, string> | null, overrides: Partial<BackendSrvRequest> = {}) {\n    const options: BackendSrvRequest = defaults(overrides, {\n      url: this.url + url,\n      method: this.httpMethod,\n      headers: {},\n    });\n\n    if (options.method === 'GET') {\n      if (data && Object.keys(data).length) {\n        options.url =\n          options.url +\n          (options.url.search(/\\?/) >= 0 ? '&' : '?') +\n          Object.entries(data)\n            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n            .join('&');\n      }\n    } else {\n      options.headers!['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.data = data;\n    }\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers!.Authorization = this.basicAuth;\n    }\n\n    return getBackendSrv().fetch<T>(options);\n  }\n\n  // Use this for tab completion features, wont publish response to other components\n  metadataRequest<T = any>(url: string) {\n    const data: any = {};\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n    return this._request<T>(url, data, { method: 'GET', hideFromInspector: true }).toPromise(); // toPromise until we change getTagValues, getTagKeys to Observable\n  }\n\n  interpolateQueryExpr(value: string | string[] = [], variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return prometheusRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return prometheusSpecialRegexEscape(value);\n    }\n\n    const escapedValues = value.map((val) => prometheusSpecialRegexEscape(val));\n\n    if (escapedValues.length === 1) {\n      return escapedValues[0];\n    }\n\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  targetContainsTemplate(target: PromQuery) {\n    return this.templateSrv.variableExists(target.expr);\n  }\n\n  prepareTargets = (options: DataQueryRequest<PromQuery>, start: number, end: number) => {\n    const queries: PromQueryRequest[] = [];\n    const activeTargets: PromQuery[] = [];\n\n    for (const target of options.targets) {\n      if (!target.expr || target.hide) {\n        continue;\n      }\n\n      target.requestId = options.panelId + target.refId;\n\n      // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)\n      if (options.app === CoreApp.Explore && target.range === target.instant) {\n        // Create instant target\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        instantTarget.instant = true;\n        instantTarget.range = false;\n        instantTarget.valueWithRefId = true;\n        delete instantTarget.maxDataPoints;\n        instantTarget.requestId += '_instant';\n\n        // Create range target\n        const rangeTarget: any = cloneDeep(target);\n        rangeTarget.format = 'time_series';\n        rangeTarget.instant = false;\n        instantTarget.range = true;\n\n        // Create exemplar query\n        if (target.exemplar) {\n          const exemplarTarget = cloneDeep(target);\n          exemplarTarget.instant = false;\n          exemplarTarget.requestId += '_exemplar';\n          instantTarget.exemplar = false;\n          rangeTarget.exemplar = false;\n          queries.push(this.createQuery(exemplarTarget, options, start, end));\n          activeTargets.push(exemplarTarget);\n        }\n\n        // Add both targets to activeTargets and queries arrays\n        activeTargets.push(instantTarget, rangeTarget);\n        queries.push(\n          this.createQuery(instantTarget, options, start, end),\n          this.createQuery(rangeTarget, options, start, end)\n        );\n        // If running only instant query in Explore, format as table\n      } else if (target.instant && options.app === CoreApp.Explore) {\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        queries.push(this.createQuery(instantTarget, options, start, end));\n        activeTargets.push(instantTarget);\n      } else {\n        if (target.exemplar) {\n          const exemplarTarget = cloneDeep(target);\n          exemplarTarget.requestId += '_exemplar';\n          target.exemplar = false;\n          queries.push(this.createQuery(exemplarTarget, options, start, end));\n          activeTargets.push(exemplarTarget);\n        }\n        queries.push(this.createQuery(target, options, start, end));\n        activeTargets.push(target);\n      }\n    }\n\n    return {\n      queries,\n      activeTargets,\n    };\n  };\n\n  query(options: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const { queries, activeTargets } = this.prepareTargets(options, start, end);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (!queries || !queries.length) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    if (options.app === CoreApp.Explore) {\n      return this.exploreQuery(queries, activeTargets, end);\n    }\n\n    return this.panelsQuery(queries, activeTargets, end, options.requestId, options.scopedVars);\n  }\n\n  private exploreQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number) {\n    let runningQueriesCount = queries.length;\n    const mixedQueries = activeTargets.some((t) => t.range) && activeTargets.some((t) => t.instant);\n\n    const subQueries = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      const filterAndMapResponse = pipe(\n        // Decrease the counter here. We assume that each request returns only single value and then completes\n        // (should hold until there is some streaming requests involved).\n        tap(() => runningQueriesCount--),\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = transform(response, {\n            query,\n            target,\n            responseListLength: queries.length,\n            mixedQueries,\n            exemplarTraceIdDestinations: this.exemplarTraceIdDestinations,\n          });\n          return {\n            data,\n            key: query.requestId,\n            state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading,\n          } as DataQueryResponse;\n        })\n      );\n\n      if (query.instant) {\n        return this.performInstantQuery(query, end).pipe(filterAndMapResponse);\n      }\n\n      if (query.exemplar) {\n        return this.getExemplars(query).pipe(filterAndMapResponse);\n      }\n\n      return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filterAndMapResponse);\n    });\n\n    return merge(...subQueries);\n  }\n\n  private panelsQuery(\n    queries: PromQueryRequest[],\n    activeTargets: PromQuery[],\n    end: number,\n    requestId: string,\n    scopedVars: ScopedVars\n  ) {\n    const observables = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      const filterAndMapResponse = pipe(\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = transform(response, {\n            query,\n            target,\n            responseListLength: queries.length,\n            scopedVars,\n            exemplarTraceIdDestinations: this.exemplarTraceIdDestinations,\n          });\n          return data;\n        })\n      );\n\n      if (query.instant) {\n        return this.performInstantQuery(query, end).pipe(filterAndMapResponse);\n      }\n\n      if (query.exemplar) {\n        return this.getExemplars(query).pipe(filterAndMapResponse);\n      }\n\n      return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filterAndMapResponse);\n    });\n\n    return forkJoin(observables).pipe(\n      map((results) => {\n        const data = results.reduce((result, current) => {\n          return [...result, ...current];\n        }, []);\n        return {\n          data,\n          key: requestId,\n          state: LoadingState.Done,\n        };\n      })\n    );\n  }\n\n  createQuery(target: PromQuery, options: DataQueryRequest<PromQuery>, start: number, end: number) {\n    const query: PromQueryRequest = {\n      hinting: target.hinting,\n      instant: target.instant,\n      exemplar: target.exemplar,\n      step: 0,\n      expr: '',\n      requestId: target.requestId,\n      refId: target.refId,\n      start: 0,\n      end: 0,\n    };\n    const range = Math.ceil(end - start);\n\n    // options.interval is the dynamically calculated interval\n    let interval: number = rangeUtil.intervalToSeconds(options.interval);\n    // Minimum interval (\"Min step\"), if specified for the query, or same as interval otherwise.\n    const minInterval = rangeUtil.intervalToSeconds(\n      this.templateSrv.replace(target.interval || options.interval, options.scopedVars)\n    );\n    // Scrape interval as specified for the query (\"Min step\") or otherwise taken from the datasource.\n    // Min step field can have template variables in it, make sure to replace it.\n    const scrapeInterval = target.interval\n      ? rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars))\n      : rangeUtil.intervalToSeconds(this.interval);\n\n    const intervalFactor = target.intervalFactor || 1;\n    // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\n    let scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n      ...this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval),\n    };\n    // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\n    if (interval !== adjustedInterval) {\n      interval = adjustedInterval;\n      scopedVars = Object.assign({}, options.scopedVars, {\n        __interval: { text: interval + 's', value: interval + 's' },\n        __interval_ms: { text: interval * 1000, value: interval * 1000 },\n        ...this.getRateIntervalScopedVariable(interval, scrapeInterval),\n        ...this.getRangeScopedVars(options.range),\n      });\n    }\n    query.step = interval;\n\n    let expr = target.expr;\n\n    // Apply adhoc filters\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = prometheusRegularEscape(value);\n      }\n      return addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    // Only replace vars in expression after having (possibly) updated interval vars\n    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr);\n\n    // Align query interval with step to allow query caching and to ensure\n    // that about-same-time query results look the same.\n    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);\n    query.start = adjusted.start;\n    query.end = adjusted.end;\n    this._addTracingHeaders(query, options);\n\n    return query;\n  }\n\n  getRateIntervalScopedVariable(interval: number, scrapeInterval: number) {\n    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.\n    if (scrapeInterval === 0) {\n      scrapeInterval = 15;\n    }\n    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);\n    return { __rate_interval: { text: rateInterval + 's', value: rateInterval + 's' } };\n  }\n\n  adjustInterval(interval: number, minInterval: number, range: number, intervalFactor: number) {\n    // Prometheus will drop queries that might return more than 11000 data points.\n    // Calculate a safe interval as an additional minimum to take into account.\n    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1\n    // If this is the case take the ceil of the value.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n    return Math.max(interval * intervalFactor, minInterval, safeInterval);\n  }\n\n  performTimeSeriesQuery(query: PromQueryRequest, start: number, end: number) {\n    if (start > end) {\n      throw { message: 'Invalid time range' };\n    }\n\n    const url = '/api/v1/query_range';\n    const data: any = {\n      query: query.expr,\n      start,\n      end,\n      step: query.step,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request<PromDataSuccessResponse<PromMatrixData>>(url, data, {\n      requestId: query.requestId,\n      headers: query.headers,\n    }).pipe(\n      catchError((err: FetchError<PromDataErrorResponse<PromMatrixData>>) => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  performInstantQuery(query: PromQueryRequest, time: number) {\n    const url = '/api/v1/query';\n    const data: any = {\n      query: query.expr,\n      time,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request<PromDataSuccessResponse<PromVectorData | PromScalarData>>(url, data, {\n      requestId: query.requestId,\n      headers: query.headers,\n    }).pipe(\n      catchError((err: FetchError<PromDataErrorResponse<PromVectorData | PromScalarData>>) => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  handleErrors = (err: any, target: PromQuery) => {\n    const error: DataQueryError = {\n      message: (err && err.statusText) || 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const scopedVars = {\n      __interval: { text: this.interval, value: this.interval },\n      __interval_ms: { text: rangeUtil.intervalToMs(this.interval), value: rangeUtil.intervalToMs(this.interval) },\n      ...this.getRangeScopedVars(this.timeSrv.timeRange()),\n    };\n    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\n    return metricFindQuery.process();\n  }\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  createAnnotationQueryOptions = (options: any): DataQueryRequest<PromQuery> => {\n    const annotation = options.annotation;\n    const interval =\n      annotation && annotation.step && typeof annotation.step === 'string'\n        ? annotation.step\n        : ANNOTATION_QUERY_STEP_DEFAULT;\n    return {\n      ...options,\n      interval,\n    };\n  };\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const annotation = options.annotation;\n    const { expr = '', tagKeys = '', titleFormat = '', textFormat = '' } = annotation;\n\n    if (!expr) {\n      return Promise.resolve([]);\n    }\n\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const queryOptions = this.createAnnotationQueryOptions(options);\n\n    // Unsetting min interval for accurate event resolution\n    const minStep = '1s';\n    const queryModel = {\n      expr,\n      interval: minStep,\n      refId: 'X',\n      requestId: `prom-query-${annotation.name}`,\n    };\n\n    const query = this.createQuery(queryModel, queryOptions, start, end);\n    const response = await this.performTimeSeriesQuery(query, query.start, query.end).toPromise();\n    const eventList: AnnotationEvent[] = [];\n    const splitKeys = tagKeys.split(',');\n\n    if (isFetchErrorResponse(response) && response.cancelled) {\n      return [];\n    }\n\n    const step = Math.floor(query.step ?? 15) * 1000;\n\n    response?.data?.data?.result?.forEach((series) => {\n      const tags = Object.entries(series.metric)\n        .filter(([k]) => splitKeys.includes(k))\n        .map(([_k, v]: [string, string]) => v);\n\n      series.values.forEach((value: any[]) => {\n        let timestampValue;\n        // rewrite timeseries to a common format\n        if (annotation.useValueForTime) {\n          timestampValue = Math.floor(parseFloat(value[1]));\n          value[1] = 1;\n        } else {\n          timestampValue = Math.floor(parseFloat(value[0])) * 1000;\n        }\n        value[0] = timestampValue;\n      });\n\n      const activeValues = series.values.filter((value) => parseFloat(value[1]) >= 1);\n      const activeValuesTimestamps = activeValues.map((value) => value[0]);\n\n      // Instead of creating singular annotation for each active event we group events into region if they are less\n      // then `step` apart.\n      let latestEvent: AnnotationEvent | null = null;\n\n      for (const timestamp of activeValuesTimestamps) {\n        // We already have event `open` and we have new event that is inside the `step` so we just update the end.\n        if (latestEvent && (latestEvent.timeEnd ?? 0) + step >= timestamp) {\n          latestEvent.timeEnd = timestamp;\n          continue;\n        }\n\n        // Event exists but new one is outside of the `step` so we \"finish\" the current region.\n        if (latestEvent) {\n          eventList.push(latestEvent);\n        }\n\n        // We start a new region.\n        latestEvent = {\n          time: timestamp,\n          timeEnd: timestamp,\n          annotation,\n          title: renderTemplate(titleFormat, series.metric),\n          tags,\n          text: renderTemplate(textFormat, series.metric),\n        };\n      }\n\n      if (latestEvent) {\n        // finish up last point if we have one\n        latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];\n        eventList.push(latestEvent);\n      }\n    });\n\n    return eventList;\n  }\n\n  getExemplars(query: PromQueryRequest) {\n    const url = '/api/v1/query_exemplars';\n    return this._request<PromDataSuccessResponse<PromExemplarData>>(\n      url,\n      { query: query.expr, start: query.start.toString(), end: query.end.toString() },\n      { requestId: query.requestId, headers: query.headers }\n    );\n  }\n\n  async getTagKeys() {\n    const result = await this.metadataRequest('/api/v1/labels');\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async getTagValues(options: any = {}) {\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async testDatasource() {\n    const now = new Date().getTime();\n    const query = { expr: '1+1' } as PromQueryRequest;\n    const response = await this.performInstantQuery(query, now / 1000).toPromise();\n    return response.data.status === 'success'\n      ? { status: 'success', message: 'Data source is working' }\n      : { status: 'error', message: response.data.error };\n  }\n\n  interpolateVariablesInQueries(queries: PromQuery[], scopedVars: ScopedVars): PromQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  getQueryHints(query: PromQuery, result: any[]) {\n    return getQueryHints(query.expr ?? '', result, this);\n  }\n\n  async loadRules() {\n    try {\n      const res = await this.metadataRequest('/api/v1/rules');\n      const groups = res.data?.data?.groups;\n\n      if (groups) {\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\n      }\n    } catch (e) {\n      console.log('Rules API is experimental. Ignore next error.');\n      console.error(e);\n    }\n  }\n\n  modifyQuery(query: PromQuery, action: any): PromQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = addLabelToQuery(expression, action.key, action.value);\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      case 'ADD_HISTOGRAM_QUANTILE': {\n        expression = `histogram_quantile(0.95, sum(rate(${expression}[5m])) by (le))`;\n        break;\n      }\n      case 'ADD_RATE': {\n        expression = `rate(${expression}[5m])`;\n        break;\n      }\n      case 'ADD_SUM': {\n        expression = `sum(${expression.trim()}) by ($1)`;\n        break;\n      }\n      case 'EXPAND_RULES': {\n        if (action.mapping) {\n          expression = expandRecordingRules(expression, action.mapping);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getPrometheusTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() / 1000);\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: this.getPrometheusTime(range.from, false),\n      end: this.getPrometheusTime(range.to, true),\n    };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    return getOriginalMetricName(labelData);\n  }\n}\n\n/**\n * Align query range to step.\n * Rounds start and end down to a multiple of step.\n * @param start Timestamp marking the beginning of the range.\n * @param end Timestamp marking the end of the range.\n * @param step Interval to align start and end with.\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\n */\nexport function alignRange(\n  start: number,\n  end: number,\n  step: number,\n  utcOffsetSec: number\n): { end: number; start: number } {\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  return {\n    end: alignedEnd,\n    start: alignedStart,\n  };\n}\n\nexport function extractRuleMappingFromGroups(groups: any[]) {\n  return groups.reduce(\n    (mapping, group) =>\n      group.rules\n        .filter((rule: any) => rule.type === 'recording')\n        .reduce(\n          (acc: { [key: string]: string }, rule: any) => ({\n            ...acc,\n            [rule.name]: rule.query,\n          }),\n          mapping\n        ),\n    {}\n  );\n}\n\nexport function prometheusRegularEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\\\\\'\") : value;\n}\n\nexport function prometheusSpecialRegexEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]\\'+?.()|]/g, '\\\\\\\\$&') : value;\n}\n","import _ from 'lodash';\nimport React, { ReactNode } from 'react';\n\nimport { Plugin } from 'slate';\nimport {\n  ButtonCascader,\n  CascaderOption,\n  SlatePrism,\n  TypeaheadInput,\n  TypeaheadOutput,\n  QueryField,\n  BracesPlugin,\n} from '@grafana/ui';\n\nimport { LanguageMap, languages as prismLanguages } from 'prismjs';\n\n// dom also includes Element polyfills\nimport { PromQuery, PromOptions, PromMetricsMetadata } from '../types';\nimport { roundMsToMin } from '../language_utils';\nimport { CancelablePromise, makePromiseCancelable } from 'app/core/utils/CancelablePromise';\nimport {\n  ExploreQueryFieldProps,\n  QueryHint,\n  isDataFrame,\n  toLegacyResponseData,\n  HistoryItem,\n  TimeRange,\n} from '@grafana/data';\nimport { DOMUtil, SuggestionsState } from '@grafana/ui';\nimport { PrometheusDatasource } from '../datasource';\n\nconst HISTOGRAM_GROUP = '__histograms__';\nexport const RECORDING_RULES_GROUP = '__recording_rules__';\n\nfunction getChooserText(metricsLookupDisabled: boolean, hasSyntax: boolean, metrics: string[]) {\n  if (metricsLookupDisabled) {\n    return '(Disabled)';\n  }\n\n  if (!hasSyntax) {\n    return 'Loading metrics...';\n  }\n\n  if (metrics && metrics.length === 0) {\n    return '(No metrics found)';\n  }\n\n  return 'Metrics';\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CascaderOption {\n  const option: CascaderOption = { label: metric, value: metric };\n  if (metadata && metadata[metric]) {\n    const { type = '', help } = metadata[metric][0];\n    option.title = [metric, type.toUpperCase(), help].join('\\n');\n  }\n  return option;\n}\n\nexport function groupMetricsByPrefix(metrics: string[], metadata?: PromMetricsMetadata): CascaderOption[] {\n  // Filter out recording rules and insert as first option\n  const ruleRegex = /:\\w+:/;\n  const ruleNames = metrics.filter((metric) => ruleRegex.test(metric));\n  const rulesOption = {\n    label: 'Recording rules',\n    value: RECORDING_RULES_GROUP,\n    children: ruleNames\n      .slice()\n      .sort()\n      .map((name) => ({ label: name, value: name })),\n  };\n\n  const options = ruleNames.length > 0 ? [rulesOption] : [];\n\n  const delimiter = '_';\n  const metricsOptions = _.chain(metrics)\n    .filter((metric: string) => !ruleRegex.test(metric))\n    .groupBy((metric: string) => metric.split(delimiter)[0])\n    .map(\n      (metricsForPrefix: string[], prefix: string): CascaderOption => {\n        const prefixIsMetric = metricsForPrefix.length === 1 && metricsForPrefix[0] === prefix;\n        const children = prefixIsMetric ? [] : metricsForPrefix.sort().map((m) => addMetricsMetadata(m, metadata));\n        return {\n          children,\n          label: prefix,\n          value: prefix,\n        };\n      }\n    )\n    .sortBy('label')\n    .value();\n\n  return [...options, ...metricsOptions];\n}\n\nexport function willApplySuggestion(suggestion: string, { typeaheadContext, typeaheadText }: SuggestionsState): string {\n  // Modify suggestion based on context\n  switch (typeaheadContext) {\n    case 'context-labels': {\n      const nextChar = DOMUtil.getNextCharacter();\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\n        suggestion += '=';\n      }\n      break;\n    }\n\n    case 'context-label-values': {\n      // Always add quotes and remove existing ones instead\n      if (!typeaheadText.match(/^(!?=~?\"|\")/)) {\n        suggestion = `\"${suggestion}`;\n      }\n      if (DOMUtil.getNextCharacter() !== '\"') {\n        suggestion = `${suggestion}\"`;\n      }\n      break;\n    }\n\n    default:\n  }\n  return suggestion;\n}\n\ninterface PromQueryFieldProps extends ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions> {\n  history: Array<HistoryItem<PromQuery>>;\n  ExtraFieldElement?: ReactNode;\n}\n\ninterface PromQueryFieldState {\n  metricsOptions: any[];\n  syntaxLoaded: boolean;\n  hint: QueryHint | null;\n}\n\nclass PromQueryField extends React.PureComponent<PromQueryFieldProps, PromQueryFieldState> {\n  plugins: Plugin[];\n  languageProviderInitializationPromise: CancelablePromise<any>;\n\n  constructor(props: PromQueryFieldProps, context: React.Context<any>) {\n    super(props, context);\n\n    this.plugins = [\n      BracesPlugin(),\n      SlatePrism(\n        {\n          onlyIn: (node: any) => node.type === 'code_block',\n          getSyntax: (node: any) => 'promql',\n        },\n        { ...(prismLanguages as LanguageMap), promql: this.props.datasource.languageProvider.syntax }\n      ),\n    ];\n\n    this.state = {\n      metricsOptions: [],\n      syntaxLoaded: false,\n      hint: null,\n    };\n  }\n\n  componentDidMount() {\n    if (this.props.datasource.languageProvider) {\n      this.refreshMetrics();\n    }\n    this.refreshHint();\n  }\n\n  componentWillUnmount() {\n    if (this.languageProviderInitializationPromise) {\n      this.languageProviderInitializationPromise.cancel();\n    }\n  }\n\n  componentDidUpdate(prevProps: PromQueryFieldProps) {\n    const {\n      data,\n      datasource: { languageProvider },\n      range,\n    } = this.props;\n\n    if (languageProvider !== prevProps.datasource.languageProvider) {\n      // We reset this only on DS change so we do not flesh loading state on every rangeChange which happens on every\n      // query run if using relative range.\n      this.setState({\n        metricsOptions: [],\n        syntaxLoaded: false,\n      });\n    }\n\n    const changedRangeToRefresh = this.rangeChangedToRefresh(range, prevProps.range);\n    // We want to refresh metrics when language provider changes and/or when range changes (we round up intervals to a minute)\n    if (languageProvider !== prevProps.datasource.languageProvider || changedRangeToRefresh) {\n      this.refreshMetrics();\n    }\n\n    if (data && prevProps.data && prevProps.data.series !== data.series) {\n      this.refreshHint();\n    }\n  }\n\n  refreshHint = () => {\n    const { datasource, query, data } = this.props;\n\n    if (!data || data.series.length === 0) {\n      this.setState({ hint: null });\n      return;\n    }\n\n    const result = isDataFrame(data.series[0]) ? data.series.map(toLegacyResponseData) : data.series;\n    const hints = datasource.getQueryHints(query, result);\n    let hint = hints.length > 0 ? hints[0] : null;\n\n    // Hint for big disabled lookups\n    if (!hint && datasource.lookupsDisabled) {\n      hint = {\n        label: `Labels and metrics lookup was disabled in data source settings.`,\n        type: 'INFO',\n      };\n    }\n    this.setState({ hint });\n  };\n\n  refreshMetrics = async () => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    this.languageProviderInitializationPromise = makePromiseCancelable(languageProvider.start());\n\n    try {\n      const remainingTasks = await this.languageProviderInitializationPromise.promise;\n      await Promise.all(remainingTasks);\n      this.onUpdateLanguage();\n    } catch (err) {\n      if (!err.isCanceled) {\n        throw err;\n      }\n    }\n  };\n\n  rangeChangedToRefresh(range?: TimeRange, prevRange?: TimeRange): boolean {\n    if (range && prevRange) {\n      const sameMinuteFrom = roundMsToMin(range.from.valueOf()) === roundMsToMin(prevRange.from.valueOf());\n      const sameMinuteTo = roundMsToMin(range.to.valueOf()) === roundMsToMin(prevRange.to.valueOf());\n      // If both are same, don't need to refresh.\n      return !(sameMinuteFrom && sameMinuteTo);\n    }\n    return false;\n  }\n\n  onChangeMetrics = (values: string[], selectedOptions: CascaderOption[]) => {\n    let query;\n    if (selectedOptions.length === 1) {\n      const selectedOption = selectedOptions[0];\n      if (!selectedOption.children || selectedOption.children.length === 0) {\n        query = selectedOption.value;\n      } else {\n        // Ignore click on group\n        return;\n      }\n    } else {\n      const prefix = selectedOptions[0].value;\n      const metric = selectedOptions[1].value;\n      if (prefix === HISTOGRAM_GROUP) {\n        query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;\n      } else {\n        query = metric;\n      }\n    }\n    this.onChangeQuery(query, true);\n  };\n\n  onChangeQuery = (value: string, override?: boolean) => {\n    // Send text change to parent\n    const { query, onChange, onRunQuery } = this.props;\n    if (onChange) {\n      const nextQuery: PromQuery = { ...query, expr: value };\n      onChange(nextQuery);\n\n      if (override && onRunQuery) {\n        onRunQuery();\n      }\n    }\n  };\n\n  onClickHintFix = () => {\n    const { datasource, query, onChange, onRunQuery } = this.props;\n    const { hint } = this.state;\n\n    onChange(datasource.modifyQuery(query, hint!.fix!.action));\n    onRunQuery();\n  };\n\n  onUpdateLanguage = () => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n    const { histogramMetrics, metrics, metricsMetadata } = languageProvider;\n\n    if (!metrics) {\n      return;\n    }\n\n    // Build metrics tree\n    const metricsByPrefix = groupMetricsByPrefix(metrics, metricsMetadata);\n    const histogramOptions = histogramMetrics.map((hm: any) => ({ label: hm, value: hm }));\n    const metricsOptions =\n      histogramMetrics.length > 0\n        ? [\n            { label: 'Histograms', value: HISTOGRAM_GROUP, children: histogramOptions, isLeaf: false },\n            ...metricsByPrefix,\n          ]\n        : metricsByPrefix;\n\n    this.setState({ metricsOptions, syntaxLoaded: true });\n  };\n\n  onTypeahead = async (typeahead: TypeaheadInput): Promise<TypeaheadOutput> => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    if (!languageProvider) {\n      return { suggestions: [] };\n    }\n\n    const { history } = this.props;\n    const { prefix, text, value, wrapperClasses, labelKey } = typeahead;\n\n    const result = await languageProvider.provideCompletionItems(\n      { text, value, prefix, wrapperClasses, labelKey },\n      { history }\n    );\n\n    return result;\n  };\n\n  render() {\n    const {\n      datasource,\n      datasource: { languageProvider },\n      query,\n      ExtraFieldElement,\n    } = this.props;\n    const { metricsOptions, syntaxLoaded, hint } = this.state;\n    const cleanText = languageProvider ? languageProvider.cleanText : undefined;\n    const chooserText = getChooserText(datasource.lookupsDisabled, syntaxLoaded, metricsOptions);\n    const buttonDisabled = !(syntaxLoaded && metricsOptions && metricsOptions.length > 0);\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1\">\n          <div className=\"gf-form flex-shrink-0 min-width-5\">\n            <ButtonCascader options={metricsOptions} disabled={buttonDisabled} onChange={this.onChangeMetrics}>\n              {chooserText}\n            </ButtonCascader>\n          </div>\n          <div className=\"gf-form gf-form--grow flex-shrink-1 min-width-15\">\n            <QueryField\n              additionalPlugins={this.plugins}\n              cleanText={cleanText}\n              query={query.expr}\n              onTypeahead={this.onTypeahead}\n              onWillApplySuggestion={willApplySuggestion}\n              onBlur={this.props.onBlur}\n              onChange={this.onChangeQuery}\n              onRunQuery={this.props.onRunQuery}\n              placeholder=\"Enter a PromQL query (run with Shift+Enter)\"\n              portalOrigin=\"prometheus\"\n              syntaxLoaded={syntaxLoaded}\n            />\n          </div>\n        </div>\n        {ExtraFieldElement}\n        {hint ? (\n          <div className=\"query-row-break\">\n            <div className=\"prom-query-field-info text-warning\">\n              {hint.label}{' '}\n              {hint.fix ? (\n                <a className=\"text-link muted\" onClick={this.onClickHintFix}>\n                  {hint.fix.label}\n                </a>\n              ) : null}\n            </div>\n          </div>\n        ) : null}\n      </>\n    );\n  }\n}\n\nexport default PromQueryField;\n","import _ from 'lodash';\nimport React, { FC, useEffect, useState, memo } from 'react';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery } from '../types';\nimport { DataQueryRequest, PanelData } from '@grafana/data';\n\ninterface Props {\n  datasource: PrometheusDatasource;\n  query: PromQuery;\n  panelData?: PanelData;\n}\n\nconst PromLink: FC<Props> = ({ panelData, query, datasource }) => {\n  const [href, setHref] = useState('');\n\n  useEffect(() => {\n    if (panelData) {\n      const getExternalLink = () => {\n        if (!panelData.request) {\n          return '';\n        }\n\n        const {\n          request: { range, interval },\n        } = panelData;\n\n        const start = datasource.getPrometheusTime(range.from, false);\n        const end = datasource.getPrometheusTime(range.to, true);\n        const rangeDiff = Math.ceil(end - start);\n        const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');\n\n        const options = {\n          interval,\n        } as DataQueryRequest<PromQuery>;\n\n        const queryOptions = datasource.createQuery(query, options, start, end);\n        const expr = {\n          'g0.expr': queryOptions.expr,\n          'g0.range_input': rangeDiff + 's',\n          'g0.end_input': endTime,\n          'g0.step_input': queryOptions.step,\n          'g0.tab': 0,\n        };\n\n        const args = _.map(expr, (v: string, k: string) => {\n          return k + '=' + encodeURIComponent(v);\n        }).join('&');\n        return `${datasource.directUrl}/graph?${args}`;\n      };\n\n      setHref(getExternalLink());\n    }\n  }, [panelData]);\n\n  return (\n    <a href={href} target=\"_blank\" rel=\"noopener noreferrer\">\n      Prometheus\n    </a>\n  );\n};\n\nexport default memo(PromLink);\n","import { InlineField, InlineSwitch } from '@grafana/ui';\nimport React from 'react';\nimport { PromQuery } from '../types';\n\ninterface Props {\n  query: PromQuery;\n  onChange: (value: PromQuery) => void;\n}\n\nconst onExemplarsChange = ({ query, onChange }: Props) => (e: React.ChangeEvent<HTMLInputElement>) => {\n  const exemplar = e.target.checked;\n  onChange({ ...query, exemplar });\n};\n\nexport function PromExemplarField(props: Props) {\n  return (\n    <InlineField label=\"Exemplars\" labelWidth=\"auto\">\n      <InlineSwitch label=\"Exemplars\" value={!!props.query.exemplar} onChange={onExemplarsChange(props)} />\n    </InlineField>\n  );\n}\n","import _ from 'lodash';\nimport React, { PureComponent } from 'react';\n\n// Types\nimport { InlineFormLabel, LegacyForms, Select } from '@grafana/ui';\nimport { QueryEditorProps, SelectableValue } from '@grafana/data';\nimport { PrometheusDatasource } from '../datasource';\nimport { PromOptions, PromQuery } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport PromLink from './PromLink';\nimport { PromExemplarField } from './PromExemplarField';\n\nconst { Switch } = LegacyForms;\n\nexport type Props = QueryEditorProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nconst FORMAT_OPTIONS: Array<SelectableValue<string>> = [\n  { label: 'Time series', value: 'time_series' },\n  { label: 'Table', value: 'table' },\n  { label: 'Heatmap', value: 'heatmap' },\n];\n\nconst INTERVAL_FACTOR_OPTIONS: Array<SelectableValue<number>> = _.map([1, 2, 3, 4, 5, 10], (value: number) => ({\n  value,\n  label: '1/' + value,\n}));\n\ninterface State {\n  legendFormat?: string;\n  formatOption: SelectableValue<string>;\n  interval?: string;\n  intervalFactorOption: SelectableValue<number>;\n  instant: boolean;\n}\n\nexport class PromQueryEditor extends PureComponent<Props, State> {\n  // Query target to be modified and used for queries\n  query: PromQuery;\n\n  constructor(props: Props) {\n    super(props);\n    // Use default query to prevent undefined input values\n    const defaultQuery: Partial<PromQuery> = { expr: '', legendFormat: '', interval: '' };\n    const query = Object.assign({}, defaultQuery, props.query);\n    this.query = query;\n    // Query target properties that are fully controlled inputs\n    this.state = {\n      // Fully controlled text inputs\n      interval: query.interval,\n      legendFormat: query.legendFormat,\n      // Select options\n      formatOption: FORMAT_OPTIONS.find((option) => option.value === query.format) || FORMAT_OPTIONS[0],\n      intervalFactorOption:\n        INTERVAL_FACTOR_OPTIONS.find((option) => option.value === query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],\n      // Switch options\n      instant: Boolean(query.instant),\n    };\n  }\n\n  onFieldChange = (query: PromQuery, override?: any) => {\n    this.query.expr = query.expr;\n  };\n\n  onFormatChange = (option: SelectableValue<string>) => {\n    this.query.format = option.value;\n    this.setState({ formatOption: option }, this.onRunQuery);\n  };\n\n  onInstantChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const instant = e.target.checked;\n    this.query.instant = instant;\n    this.setState({ instant }, this.onRunQuery);\n  };\n\n  onIntervalChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const interval = e.currentTarget.value;\n    this.query.interval = interval;\n    this.setState({ interval });\n  };\n\n  onIntervalFactorChange = (option: SelectableValue<number>) => {\n    this.query.intervalFactor = option.value;\n    this.setState({ intervalFactorOption: option }, this.onRunQuery);\n  };\n\n  onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const legendFormat = e.currentTarget.value;\n    this.query.legendFormat = legendFormat;\n    this.setState({ legendFormat });\n  };\n\n  onRunQuery = () => {\n    const { query } = this;\n    // Change of query.hide happens outside of this component and is just passed as prop. We have to update it when running queries.\n    const { hide } = this.props.query;\n    this.props.onChange({ ...query, hide });\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { datasource, query, range, data, onChange } = this.props;\n    const { formatOption, instant, interval, intervalFactorOption, legendFormat } = this.state;\n\n    return (\n      <div>\n        <PromQueryField\n          datasource={datasource}\n          query={query}\n          range={range}\n          onRunQuery={this.onRunQuery}\n          onChange={this.onFieldChange}\n          history={[]}\n          data={data}\n        />\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname.\"\n            >\n              Legend\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input\"\n              placeholder=\"legend format\"\n              value={legendFormat}\n              onChange={this.onLegendChange}\n              onBlur={this.onRunQuery}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip={\n                <>\n                  An additional lower limit for the step parameter of the Prometheus query and for the{' '}\n                  <code>$__interval</code> and <code>$__rate_interval</code> variables. The limit is absolute and not\n                  modified by the &quot;Resolution&quot; setting.\n                </>\n              }\n            >\n              Min step\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input width-8\"\n              placeholder={interval}\n              onChange={this.onIntervalChange}\n              onBlur={this.onRunQuery}\n              value={interval}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label\">Resolution</div>\n            <Select\n              isSearchable={false}\n              options={INTERVAL_FACTOR_OPTIONS}\n              onChange={this.onIntervalFactorChange}\n              value={intervalFactorOption}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label width-7\">Format</div>\n            <Select\n              width={16}\n              isSearchable={false}\n              options={FORMAT_OPTIONS}\n              onChange={this.onFormatChange}\n              value={formatOption}\n            />\n            <Switch label=\"Instant\" checked={instant} onChange={this.onInstantChange} />\n\n            <InlineFormLabel width={10} tooltip=\"Link to Graph in Prometheus\">\n              <PromLink\n                datasource={datasource}\n                query={this.query} // Use modified query\n                panelData={data}\n              />\n            </InlineFormLabel>\n          </div>\n\n          <PromExemplarField query={query} onChange={onChange} />\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport { QueryEditorHelpProps, DataQuery } from '@grafana/data';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Request Rate',\n    expression: 'rate(http_request_total[5m])',\n    label:\n      'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.',\n  },\n  {\n    title: '95th Percentile of Request Latencies',\n    expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',\n    label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.',\n  },\n  {\n    title: 'Alerts Firing',\n    expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate=\"firing\"}[24h])) by (alertname))',\n    label: 'Sums up the alerts that have been firing over the last 24 hours.',\n  },\n  {\n    title: 'Step',\n    label:\n      'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.',\n  },\n];\n\nconst PromCheatSheet = (props: QueryEditorHelpProps) => (\n  <div>\n    <h2>PromQL Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item, index) => (\n      <div className=\"cheat-sheet-item\" key={index}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        {item.expression ? (\n          <div\n            className=\"cheat-sheet-item__example\"\n            onClick={(e) => props.onClickExample({ refId: 'A', expr: item.expression } as DataQuery)}\n          >\n            <code>{item.expression}</code>\n          </div>\n        ) : null}\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n\nexport default PromCheatSheet;\n","// Libraries\nimport React, { memo } from 'react';\nimport { css, cx } from 'emotion';\n\n// Types\nimport { InlineFormLabel, RadioButtonGroup } from '@grafana/ui';\nimport { PromQuery } from '../types';\nimport { PromExemplarField } from './PromExemplarField';\n\nexport interface PromExploreExtraFieldProps {\n  queryType: string;\n  stepValue: string;\n  query: PromQuery;\n  onStepChange: (e: React.SyntheticEvent<HTMLInputElement>) => void;\n  onKeyDownFunc: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n  onQueryTypeChange: (value: string) => void;\n  onChange: (value: PromQuery) => void;\n}\n\nexport const PromExploreExtraField: React.FC<PromExploreExtraFieldProps> = memo(\n  ({ queryType, stepValue, query, onChange, onStepChange, onQueryTypeChange, onKeyDownFunc }) => {\n    const rangeOptions = [\n      { value: 'range', label: 'Range' },\n      { value: 'instant', label: 'Instant' },\n      { value: 'both', label: 'Both' },\n    ];\n\n    return (\n      <div aria-label=\"Prometheus extra field\" className=\"gf-form-inline\">\n        {/*Query type field*/}\n        <div\n          data-testid=\"queryTypeField\"\n          className={cx(\n            'gf-form explore-input-margin',\n            css`\n              flex-wrap: nowrap;\n            `\n          )}\n          aria-label=\"Query type field\"\n        >\n          <InlineFormLabel\n            width=\"auto\"\n            tooltip=\"Choose the type of query you would like to run. An instant query queries against a single point in time. A range query queries over a range of time. With both, you'll run two queries - one instant and one range. \"\n          >\n            Query type\n          </InlineFormLabel>\n\n          <RadioButtonGroup options={rangeOptions} value={queryType} onChange={onQueryTypeChange} />\n        </div>\n        {/*Step field*/}\n        <div\n          data-testid=\"stepField\"\n          className={cx(\n            'gf-form',\n            css`\n              flex-wrap: nowrap;\n            `\n          )}\n          aria-label=\"Step field\"\n        >\n          <InlineFormLabel\n            width={5}\n            tooltip={\n              'Time units can be used here, for example: 5s, 1m, 3h, 1d, 1y (Default if no unit is specified: s)'\n            }\n          >\n            Step\n          </InlineFormLabel>\n          <input\n            type={'text'}\n            className=\"gf-form-input width-4\"\n            placeholder={'auto'}\n            onChange={onStepChange}\n            onKeyDown={onKeyDownFunc}\n            value={stepValue}\n          />\n        </div>\n\n        <PromExemplarField query={query} onChange={onChange} />\n      </div>\n    );\n  }\n);\n","import React, { memo, FC } from 'react';\n\n// Types\nimport { ExploreQueryFieldProps } from '@grafana/data';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport { PromExploreExtraField } from './PromExploreExtraField';\n\nexport type Props = ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nexport const PromExploreQueryEditor: FC<Props> = (props: Props) => {\n  const { range, query, data, datasource, history, onChange, onRunQuery } = props;\n\n  function onChangeQueryStep(value: string) {\n    const { query, onChange } = props;\n    const nextQuery = { ...query, interval: value };\n    onChange(nextQuery);\n  }\n\n  function onStepChange(e: React.SyntheticEvent<HTMLInputElement>) {\n    if (e.currentTarget.value !== query.interval) {\n      onChangeQueryStep(e.currentTarget.value);\n    }\n  }\n\n  function onReturnKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter' && (e.shiftKey || e.ctrlKey)) {\n      onRunQuery();\n    }\n  }\n\n  function onQueryTypeChange(value: string) {\n    const { query, onChange } = props;\n    let nextQuery;\n    if (value === 'instant') {\n      nextQuery = { ...query, instant: true, range: false };\n    } else if (value === 'range') {\n      nextQuery = { ...query, instant: false, range: true };\n    } else {\n      nextQuery = { ...query, instant: true, range: true };\n    }\n    onChange(nextQuery);\n  }\n\n  return (\n    <PromQueryField\n      datasource={datasource}\n      query={query}\n      range={range}\n      onRunQuery={onRunQuery}\n      onChange={onChange}\n      onBlur={() => {}}\n      history={history}\n      data={data}\n      ExtraFieldElement={\n        <PromExploreExtraField\n          // Select \"both\" as default option when Explore is opened. In legacy requests, range and instant can be undefined. In this case, we want to run queries with \"both\".\n          queryType={query.range === query.instant ? 'both' : query.instant ? 'instant' : 'range'}\n          stepValue={query.interval || ''}\n          onQueryTypeChange={onQueryTypeChange}\n          onStepChange={onStepChange}\n          onKeyDownFunc={onReturnKeyDown}\n          query={query}\n          onChange={onChange}\n        />\n      }\n    />\n  );\n};\n\nexport default memo(PromExploreQueryEditor);\n","import { Button, InlineField, InlineSwitch, Input } from '@grafana/ui';\nimport { DataSourcePicker } from 'app/core/components/Select/DataSourcePicker';\nimport { css } from 'emotion';\nimport React, { useState } from 'react';\nimport { ExemplarTraceIdDestination } from '../types';\n\ntype Props = {\n  value: ExemplarTraceIdDestination;\n  onChange: (value: ExemplarTraceIdDestination) => void;\n  onDelete: () => void;\n};\n\nexport default function ExemplarSetting({ value, onChange, onDelete }: Props) {\n  const [isInternalLink, setIsInternalLink] = useState(Boolean(value.datasourceUid));\n\n  return (\n    <div className=\"gf-form-group\">\n      <InlineField label=\"Internal link\" labelWidth={24}>\n        <>\n          <InlineSwitch value={isInternalLink} onChange={(ev) => setIsInternalLink(ev.currentTarget.checked)} />\n          <Button\n            variant=\"destructive\"\n            title=\"Remove link\"\n            icon=\"times\"\n            onClick={(event) => {\n              event.preventDefault();\n              onDelete();\n            }}\n            className={css`\n              margin-left: 8px;\n            `}\n          />\n        </>\n      </InlineField>\n\n      {isInternalLink ? (\n        <InlineField\n          label=\"Data source\"\n          labelWidth={24}\n          tooltip=\"The data source the exemplar is going to navigate to.\"\n        >\n          <DataSourcePicker\n            tracing={true}\n            current={value.datasourceUid}\n            noDefault={true}\n            onChange={(ds) =>\n              onChange({\n                datasourceUid: ds.uid,\n                name: value.name,\n                url: undefined,\n              })\n            }\n          />\n        </InlineField>\n      ) : (\n        <InlineField\n          label=\"URL\"\n          labelWidth={24}\n          tooltip=\"The URL of the trace backend the user would go to see its trace.\"\n        >\n          <Input\n            placeholder=\"https://example.com/${__value.raw}\"\n            spellCheck={false}\n            width={40}\n            value={value.url}\n            onChange={(event) =>\n              onChange({\n                datasourceUid: undefined,\n                name: value.name,\n                url: event.currentTarget.value,\n              })\n            }\n          />\n        </InlineField>\n      )}\n\n      <InlineField\n        label=\"Label name\"\n        labelWidth={24}\n        tooltip=\"The name of the field in the labels object that should be used to get the traceID.\"\n      >\n        <Input\n          placeholder=\"traceID\"\n          spellCheck={false}\n          width={40}\n          value={value.name}\n          onChange={(event) =>\n            onChange({\n              ...value,\n              name: event.currentTarget.value,\n            })\n          }\n        />\n      </InlineField>\n    </div>\n  );\n}\n","import { Button } from '@grafana/ui';\nimport { css } from 'emotion';\nimport React from 'react';\nimport { ExemplarTraceIdDestination } from '../types';\nimport ExemplarSetting from './ExemplarSetting';\n\ntype Props = {\n  options?: ExemplarTraceIdDestination[];\n  onChange: (value: ExemplarTraceIdDestination[]) => void;\n};\n\nexport function ExemplarsSettings({ options, onChange }: Props) {\n  return (\n    <>\n      <h3 className=\"page-heading\">Exemplars</h3>\n\n      {options &&\n        options.map((option, index) => {\n          return (\n            <ExemplarSetting\n              key={index}\n              value={option}\n              onChange={(newField) => {\n                const newOptions = [...options];\n                newOptions.splice(index, 1, newField);\n                onChange(newOptions);\n              }}\n              onDelete={() => {\n                const newOptions = [...options];\n                newOptions.splice(index, 1);\n                onChange(newOptions);\n              }}\n            />\n          );\n        })}\n\n      <Button\n        variant=\"secondary\"\n        className={css`\n          margin-bottom: 10px;\n        `}\n        icon=\"plus\"\n        onClick={(event) => {\n          event.preventDefault();\n          const newOptions = [...(options || []), { name: 'traceID' }];\n          onChange(newOptions);\n        }}\n      >\n        Add\n      </Button>\n    </>\n  );\n}\n","import {\n  DataSourcePluginOptionsEditorProps,\n  onUpdateDatasourceJsonDataOptionChecked,\n  SelectableValue,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { EventsWithValidation, InlineFormLabel, LegacyForms, regexValidation } from '@grafana/ui';\nimport React, { SyntheticEvent } from 'react';\nimport { PromOptions } from '../types';\nimport { ExemplarsSettings } from './ExemplarsSettings';\nconst { Select, Input, FormField, Switch } = LegacyForms;\n\nconst httpOptions = [\n  { value: 'GET', label: 'GET' },\n  { value: 'POST', label: 'POST' },\n];\n\ntype Props = Pick<DataSourcePluginOptionsEditorProps<PromOptions>, 'options' | 'onOptionsChange'>;\n\nexport const PromSettings = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Scrape interval\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.timeInterval}\n                  spellCheck={false}\n                  placeholder=\"15s\"\n                  onChange={onChangeHandler('timeInterval', options, onOptionsChange)}\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Query timeout\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.queryTimeout}\n                  onChange={onChangeHandler('queryTimeout', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"60s\"\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set the Prometheus query timeout.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form\">\n          <InlineFormLabel\n            width={13}\n            tooltip=\"Specify the HTTP Method to query Prometheus. (POST is only available in Prometheus >= v2.1.0)\"\n          >\n            HTTP Method\n          </InlineFormLabel>\n          <Select\n            options={httpOptions}\n            value={httpOptions.find((o) => o.value === options.jsonData.httpMethod)}\n            onChange={onChangeHandler('httpMethod', options, onOptionsChange)}\n            width={7}\n          />\n        </div>\n      </div>\n      <h3 className=\"page-heading\">Misc</h3>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form\">\n          <Switch\n            checked={options.jsonData.disableMetricsLookup ?? false}\n            label=\"Disable metrics lookup\"\n            labelClass=\"width-14\"\n            onChange={onUpdateDatasourceJsonDataOptionChecked(props, 'disableMetricsLookup')}\n            tooltip=\"Checking this option will disable the metrics chooser and metric/label support in the query field's autocomplete. This helps if you have performance issues with bigger Prometheus instances.\"\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <FormField\n              label=\"Custom query parameters\"\n              labelWidth={14}\n              tooltip=\"Add Custom parameters to all Prometheus or Thanos queries.\"\n              inputEl={\n                <Input\n                  className=\"width-25\"\n                  value={options.jsonData.customQueryParameters}\n                  onChange={onChangeHandler('customQueryParameters', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"Example: max_source_resolution=5m&timeout=10\"\n                />\n              }\n            />\n          </div>\n        </div>\n      </div>\n      <ExemplarsSettings\n        options={options.jsonData.exemplarTraceIdDestinations}\n        onChange={(exemplarOptions) =>\n          updateDatasourcePluginJsonDataOption(\n            { onOptionsChange, options },\n            'exemplarTraceIdDestinations',\n            exemplarOptions\n          )\n        }\n      />\n    </>\n  );\n};\n\nexport const promSettingsValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    regexValidation(\n      /^$|^\\d+(ms|[Mwdhmsy])$/,\n      'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\n    ),\n  ],\n};\n\nexport const getValueFromEventItem = (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  if (!eventItem) {\n    return '';\n  }\n\n  if (eventItem.hasOwnProperty('currentTarget')) {\n    return eventItem.currentTarget.value;\n  }\n\n  return (eventItem as SelectableValue<string>).value;\n};\n\nconst onChangeHandler = (\n  key: keyof PromOptions,\n  options: Props['options'],\n  onOptionsChange: Props['onOptionsChange']\n) => (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  onOptionsChange({\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [key]: getValueFromEventItem(eventItem),\n    },\n  });\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ANNOTATION_QUERY_STEP_DEFAULT, PrometheusDatasource } from './datasource';\n\nimport { PromQueryEditor } from './components/PromQueryEditor';\nimport PromCheatSheet from './components/PromCheatSheet';\nimport PromExploreQueryEditor from './components/PromExploreQueryEditor';\n\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nclass PrometheusAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  stepDefaultValuePlaceholder = ANNOTATION_QUERY_STEP_DEFAULT;\n}\n\nexport const plugin = new DataSourcePlugin(PrometheusDatasource)\n  .setQueryEditor(PromQueryEditor)\n  .setConfigEditor(ConfigEditor)\n  .setExploreMetricsQueryField(PromExploreQueryEditor)\n  .setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl)\n  .setQueryEditorHelp(PromCheatSheet);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { PromSettings } from './PromSettings';\nimport { PromOptions } from '../types';\nimport { config } from 'app/core/config';\n\nexport type Props = DataSourcePluginOptionsEditorProps<PromOptions>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9090\"\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n        sigV4AuthToggleEnabled={config.sigV4AuthEnabled}\n      />\n\n      <PromSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","// https://github.com/facebook/react/issues/5465\n\nexport interface CancelablePromise<T> {\n  promise: Promise<T>;\n  cancel: () => void;\n}\n\nexport const makePromiseCancelable = <T>(promise: Promise<T>): CancelablePromise<T> => {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    promise.then((val) => (hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)));\n    promise.catch((error) => (hasCanceled_ ? reject({ isCanceled: true }) : reject(error)));\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};\n"],"sourceRoot":""}