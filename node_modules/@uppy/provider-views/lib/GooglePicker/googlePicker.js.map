{"version":3,"names":["getAuthHeader","token","authorization","injectedScripts","Set","driveApiLoaded","injectScript","src","has","Promise","resolve","reject","script","document","createElement","addEventListener","e","error","head","appendChild","add","ensureScriptsInjected","pickerType","all","gapi","load","client","isTokenValid","accessToken","signal","response","fetch","encodeURIComponent","ok","authorize","_ref","clientId","scopes","tokenClient","google","accounts","oauth2","initTokenClient","client_id","scope","join","callback","error_callback","requestAccessToken","prompt","Error","access_token","logout","revoke","InvalidTokenError","constructor","name","showDrivePicker","_ref2","apiKey","appId","onFilesPicked","onPicked","picked","action","picker","Action","PICKED","map","doc","platform","id","mimeType","PickerBuilder","enableFeature","Feature","NAV_HIDDEN","MULTISELECT_ENABLED","setDeveloperKey","setAppId","setOAuthToken","addView","DocsView","ViewId","DOCS","setIncludeFolders","setSelectFolderEnabled","setMode","DocsViewMode","LIST","setCallback","build","setVisible","dispose","showPhotosPicker","_ref3","pickingSession","onPickingSessionChange","headers","newPickingSession","createSessionResponse","method","status","_resp$error","resp","json","w","window","open","pickerUri","close","resolvePickedPhotos","_ref4","pageToken","mediaItems","pageSize","URLSearchParams","sessionId","String","toString","batchMediaItems","nextPageToken","push","flatMap","i","type","mediaFile","mediaFileMetadata","videoMetadata","processingStatus","_ref5","filename","baseUrl","url","pollPickingSession","_ref6","pickingSessionRef","accessTokenRef","onError","interval","current","parseFloat","pollingConfig","pollInterval","race","setTimeout","_resolve","throwIfAborted","mediaItemsSet","resolvedPhotos","undefined","timeoutIn","err"],"sources":["googlePicker.ts"],"sourcesContent":["import { type MutableRef } from 'preact/hooks'\n\n// https://developers.google.com/photos/picker/reference/rest/v1/mediaItems\nexport interface MediaItemBase {\n  id: string\n  createTime: string\n}\n\ninterface MediaFileMetadataBase {\n  width: number\n  height: number\n  cameraMake: string\n  cameraModel: string\n}\n\ninterface MediaFileBase {\n  baseUrl: string\n  mimeType: string\n  filename: string\n}\n\nexport interface VideoMediaItem extends MediaItemBase {\n  type: 'VIDEO'\n  mediaFile: MediaFileBase & {\n    mediaFileMetadata: MediaFileMetadataBase & {\n      videoMetadata: {\n        fps: number\n        processingStatus: 'UNSPECIFIED' | 'PROCESSING' | 'READY' | 'FAILED'\n      }\n    }\n  }\n}\n\nexport interface PhotoMediaItem extends MediaItemBase {\n  type: 'PHOTO'\n  mediaFile: MediaFileBase & {\n    mediaFileMetadata: MediaFileMetadataBase & {\n      photoMetadata: {\n        focalLength: number\n        apertureFNumber: number\n        isoEquivalent: number\n        exposureTime: string\n      }\n    }\n  }\n}\n\nexport interface UnspecifiedMediaItem extends MediaItemBase {\n  type: 'TYPE_UNSPECIFIED'\n  mediaFile: MediaFileBase\n}\n\nexport type MediaItem = VideoMediaItem | PhotoMediaItem | UnspecifiedMediaItem\n\n// https://developers.google.com/photos/picker/reference/rest/v1/sessions\nexport interface PickingSession {\n  id: string\n  pickerUri: string\n  pollingConfig: {\n    pollInterval: string\n    timeoutIn: string\n  }\n  expireTime: string\n  mediaItemsSet: boolean\n}\n\nexport interface PickedItemBase {\n  id: string\n  mimeType: string\n  name: string\n}\n\nexport interface PickedDriveItem extends PickedItemBase {\n  platform: 'drive'\n}\n\nexport interface PickedPhotosItem extends PickedItemBase {\n  platform: 'photos'\n  url: string\n}\n\nexport type PickedItem = PickedPhotosItem | PickedDriveItem\n\ntype PickerType = 'drive' | 'photos'\n\nconst getAuthHeader = (token: string) => ({\n  authorization: `Bearer ${token}`,\n})\n\nconst injectedScripts = new Set<string>()\nlet driveApiLoaded = false\n\n// https://stackoverflow.com/a/39008859/6519037\nasync function injectScript(src: string) {\n  if (injectedScripts.has(src)) return\n\n  await new Promise<void>((resolve, reject) => {\n    const script = document.createElement('script')\n    script.src = src\n    script.addEventListener('load', () => resolve())\n    script.addEventListener('error', (e) => reject(e.error))\n    document.head.appendChild(script)\n  })\n  injectedScripts.add(src)\n}\n\nexport async function ensureScriptsInjected(\n  pickerType: PickerType,\n): Promise<void> {\n  await Promise.all([\n    injectScript('https://accounts.google.com/gsi/client'), // Google Identity Services\n    (async () => {\n      await injectScript('https://apis.google.com/js/api.js')\n\n      if (pickerType === 'drive' && !driveApiLoaded) {\n        await new Promise<void>((resolve) =>\n          gapi.load('client:picker', () => resolve()),\n        )\n        await gapi.client.load(\n          'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest',\n        )\n        driveApiLoaded = true\n      }\n    })(),\n  ])\n}\n\nasync function isTokenValid(\n  accessToken: string,\n  signal: AbortSignal | undefined,\n) {\n  const response = await fetch(\n    `https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=${encodeURIComponent(accessToken)}`,\n    { signal },\n  )\n  if (response.ok) {\n    return true\n  }\n  // console.warn('Token is invalid or expired:', response.status, await response.text());\n  // Token is invalid or expired\n  return false\n}\n\nexport async function authorize({\n  pickerType,\n  clientId,\n  accessToken,\n}: {\n  pickerType: PickerType\n  clientId: string\n  accessToken?: string | null | undefined\n}): Promise<string> {\n  const response = await new Promise<google.accounts.oauth2.TokenResponse>(\n    (resolve, reject) => {\n      const scopes =\n        pickerType === 'drive' ?\n          ['https://www.googleapis.com/auth/drive.file']\n        : ['https://www.googleapis.com/auth/photospicker.mediaitems.readonly']\n\n      const tokenClient = google.accounts.oauth2.initTokenClient({\n        client_id: clientId,\n        // Authorization scopes required by the API; multiple scopes can be included, separated by spaces.\n        scope: scopes.join(' '),\n        callback: resolve,\n        error_callback: reject,\n      })\n\n      if (accessToken === null) {\n        // Prompt the user to select a Google Account and ask for consent to share their data\n        // when establishing a new session.\n        tokenClient.requestAccessToken({ prompt: 'consent' })\n      } else {\n        // Skip display of account chooser and consent dialog for an existing session.\n        tokenClient.requestAccessToken({ prompt: '' })\n      }\n    },\n  )\n\n  if (response.error) {\n    throw new Error(`OAuth2 error: ${response.error}`)\n  }\n  return response.access_token\n}\n\nexport async function logout(accessToken: string): Promise<void> {\n  await new Promise<void>((resolve) =>\n    google.accounts.oauth2.revoke(accessToken, resolve),\n  )\n}\n\nexport class InvalidTokenError extends Error {\n  constructor() {\n    super('Invalid or expired token')\n    this.name = 'InvalidTokenError'\n  }\n}\n\nexport async function showDrivePicker({\n  token,\n  apiKey,\n  appId,\n  onFilesPicked,\n  signal,\n}: {\n  token: string\n  apiKey: string\n  appId: string\n  onFilesPicked: (files: PickedItem[], accessToken: string) => void\n  signal: AbortSignal | undefined\n}): Promise<void> {\n  // google drive picker will crash hard if given an invalid token, so we need to check it first\n  // https://github.com/transloadit/uppy/pull/5443#pullrequestreview-2452439265\n  if (!(await isTokenValid(token, signal))) {\n    throw new InvalidTokenError()\n  }\n\n  const onPicked = (picked: google.picker.ResponseObject) => {\n    if (picked.action === google.picker.Action.PICKED) {\n      // console.log('Picker response', JSON.stringify(picked, null, 2));\n      onFilesPicked(\n        picked['docs'].map((doc) => ({\n          platform: 'drive',\n          id: doc['id'],\n          name: doc['name'],\n          mimeType: doc['mimeType'],\n        })),\n        token,\n      )\n    }\n  }\n\n  const picker = new google.picker.PickerBuilder()\n    .enableFeature(google.picker.Feature.NAV_HIDDEN)\n    .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)\n    .setDeveloperKey(apiKey)\n    .setAppId(appId)\n    .setOAuthToken(token)\n    .addView(\n      new google.picker.DocsView(google.picker.ViewId.DOCS)\n        .setIncludeFolders(true)\n        // Note: setEnableDrives doesn't seem to work\n        // .setEnableDrives(true)\n        .setSelectFolderEnabled(false)\n        .setMode(google.picker.DocsViewMode.LIST),\n    )\n    // NOTE: photos is broken and results in an error being returned from Google\n    // I think it's the old Picasa photos\n    // .addView(google.picker.ViewId.PHOTOS)\n    .setCallback(onPicked)\n    .build()\n\n  picker.setVisible(true)\n  signal?.addEventListener('abort', () => picker.dispose())\n}\n\nexport async function showPhotosPicker({\n  token,\n  pickingSession,\n  onPickingSessionChange,\n  signal,\n}: {\n  token: string\n  pickingSession: PickingSession | undefined\n  onPickingSessionChange: (ps: PickingSession) => void\n  signal: AbortSignal | undefined\n}): Promise<void> {\n  // https://developers.google.com/photos/picker/guides/get-started-picker\n  const headers = getAuthHeader(token)\n\n  let newPickingSession = pickingSession\n  if (newPickingSession == null) {\n    const createSessionResponse = await fetch(\n      'https://photospicker.googleapis.com/v1/sessions',\n      { method: 'post', headers, signal },\n    )\n\n    if (createSessionResponse.status === 401) {\n      const resp = await createSessionResponse.json()\n      if (resp.error?.status === 'UNAUTHENTICATED') {\n        throw new InvalidTokenError()\n      }\n    }\n\n    if (!createSessionResponse.ok) {\n      throw new Error('Failed to create a session')\n    }\n    newPickingSession = (await createSessionResponse.json()) as PickingSession\n\n    onPickingSessionChange(newPickingSession)\n  }\n\n  const w = window.open(newPickingSession.pickerUri)\n  signal?.addEventListener('abort', () => w?.close())\n}\n\nasync function resolvePickedPhotos({\n  accessToken,\n  pickingSession,\n  signal,\n}: {\n  accessToken: string\n  pickingSession: PickingSession\n  signal: AbortSignal\n}) {\n  const headers = getAuthHeader(accessToken)\n\n  let pageToken: string | undefined\n  let mediaItems: MediaItem[] = []\n  do {\n    const pageSize = 100\n    const response = await fetch(\n      `https://photospicker.googleapis.com/v1/mediaItems?${new URLSearchParams({ sessionId: pickingSession.id, pageSize: String(pageSize) }).toString()}`,\n      { headers, signal },\n    )\n    if (!response.ok) throw new Error('Failed to get a media items')\n    const {\n      mediaItems: batchMediaItems,\n      nextPageToken,\n    }: { mediaItems: MediaItem[]; nextPageToken?: string } =\n      await response.json()\n    pageToken = nextPageToken\n    mediaItems.push(...batchMediaItems)\n  } while (pageToken)\n\n  // todo show alert instead about invalid picked files?\n  mediaItems = mediaItems.flatMap((i) =>\n    (\n      i.type === 'PHOTO' ||\n      (i.type === 'VIDEO' &&\n        i.mediaFile.mediaFileMetadata.videoMetadata.processingStatus ===\n          'READY')\n    ) ?\n      [i]\n    : [],\n  )\n\n  return mediaItems.map(\n    ({\n      id,\n      // we want the original resolution, so we don't append any parameter to the baseUrl\n      // https://developers.google.com/photos/library/guides/access-media-items#base-urls\n      mediaFile: { mimeType, filename, baseUrl },\n    }) => ({\n      platform: 'photos' as const,\n      id,\n      mimeType,\n      url: baseUrl,\n      name: filename,\n    }),\n  )\n}\n\nexport async function pollPickingSession({\n  pickingSessionRef,\n  accessTokenRef,\n  signal,\n  onFilesPicked,\n  onError,\n}: {\n  pickingSessionRef: MutableRef<PickingSession | undefined>\n  accessTokenRef: MutableRef<string | null | undefined>\n  signal: AbortSignal\n  onFilesPicked: (files: PickedItem[], accessToken: string) => void\n  onError: (err: unknown) => void\n}): Promise<void> {\n  // if we have an active session, poll it until it either times out, or the user selects some photos.\n  // Note that the user can also just close the page, but we get no indication of that from Google when polling,\n  // so we just have to continue polling in the background, so we can react to it\n  // in case the user opens the photo selector again. Hence the infinite for loop\n  for (let interval = 1; ; ) {\n    try {\n      if (pickingSessionRef.current != null) {\n        interval = parseFloat(\n          pickingSessionRef.current.pollingConfig.pollInterval,\n        )\n      } else {\n        interval = 1\n      }\n\n      await Promise.race([\n        new Promise((resolve) => setTimeout(resolve, interval * 1000)),\n        new Promise((_resolve, reject) => {\n          signal.addEventListener('abort', reject)\n        }),\n      ])\n\n      signal.throwIfAborted()\n\n      const accessToken = accessTokenRef.current\n      const pickingSession = pickingSessionRef.current\n\n      if (pickingSession != null && accessToken != null) {\n        const headers = getAuthHeader(accessToken)\n\n        // https://developers.google.com/photos/picker/reference/rest/v1/sessions\n        const response = await fetch(\n          `https://photospicker.googleapis.com/v1/sessions/${encodeURIComponent(pickingSession.id)}`,\n          { headers, signal },\n        )\n        if (!response.ok) throw new Error('Failed to get session')\n        const json: PickingSession = await response.json()\n        if (json.mediaItemsSet) {\n          // console.log('User picked!', json)\n          const resolvedPhotos = await resolvePickedPhotos({\n            accessToken,\n            pickingSession,\n            signal,\n          })\n          // eslint-disable-next-line no-param-reassign\n          pickingSessionRef.current = undefined\n          onFilesPicked(resolvedPhotos, accessToken)\n        }\n        if (pickingSession.pollingConfig.timeoutIn === '0s') {\n          // eslint-disable-next-line no-param-reassign\n          pickingSessionRef.current = undefined\n        }\n      }\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        return\n      }\n      // just report the error and continue polling\n      onError(err)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}