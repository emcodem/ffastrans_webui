{"version":3,"names":["escapeRegex","string","replace","wrapInRegex","value","RegExp","undefined","getAllowedHosts","companionAllowedHosts","companionUrl","validate","TypeError","Array","isArray","every","ret","test","URL","origin","isOriginAllowed","allowedOrigin","patterns","map","some","pattern"],"sources":["getAllowedHosts.ts"],"sourcesContent":["// https://stackoverflow.com/a/3561711/6519037\nfunction escapeRegex(string: string) {\n  return string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n\nfunction wrapInRegex(value?: string | RegExp): RegExp | undefined {\n  if (typeof value === 'string') {\n    // TODO in the next major we should change this to `new RegExp(value)` so that the user can control start/end characters\n    return new RegExp(`^${value}$`) // throws if invalid regex\n  }\n  if (value instanceof RegExp) {\n    return value\n  }\n  return undefined\n}\n\nexport default function getAllowedHosts(\n  companionAllowedHosts: string | RegExp | Array<string | RegExp> | undefined,\n  companionUrl: string,\n): string | RegExp | Array<string | RegExp> {\n  if (companionAllowedHosts) {\n    const validate = (value: string | RegExp) => {\n      if (\n        !(typeof value === 'string' && wrapInRegex(value)) && // wrapInRegex throws if invalid regex\n        !(value instanceof RegExp)\n      ) {\n        throw new TypeError(\n          `The option \"companionAllowedHosts\" must be one of string, Array, RegExp`,\n        )\n      }\n    }\n\n    if (Array.isArray(companionAllowedHosts)) {\n      companionAllowedHosts.every(validate)\n    } else {\n      validate(companionAllowedHosts)\n    }\n    return companionAllowedHosts\n  }\n\n  // if it does not start with https://, prefix it (and remove any leading slashes)\n  let ret = companionUrl\n  if (/^(?!https?:\\/\\/).*$/i.test(ret)) {\n    ret = `https://${companionUrl.replace(/^\\/\\//, '')}`\n  }\n  ret = new URL(ret).origin\n\n  ret = escapeRegex(ret)\n  return ret\n}\n\nexport function isOriginAllowed(\n  origin: string,\n  allowedOrigin: string | RegExp | Array<string | RegExp> | undefined,\n): boolean {\n  const patterns =\n    Array.isArray(allowedOrigin) ?\n      allowedOrigin.map(wrapInRegex)\n    : [wrapInRegex(allowedOrigin)]\n  return patterns.some(\n    (pattern) => pattern?.test(origin) || pattern?.test(`${origin}/`),\n  ) // allowing for trailing '/'\n}\n"],"mappings":"AAAA;AACA,SAASA,WAAWA,CAACC,MAAc,EAAE;EACnC,OAAOA,MAAM,CAACC,OAAO,CAAC,wBAAwB,EAAE,MAAM,CAAC;AACzD;AAEA,SAASC,WAAWA,CAACC,KAAuB,EAAsB;EAChE,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B;IACA,OAAO,IAAIC,MAAM,CAAC,IAAID,KAAK,GAAG,CAAC,EAAC;EAClC;EACA,IAAIA,KAAK,YAAYC,MAAM,EAAE;IAC3B,OAAOD,KAAK;EACd;EACA,OAAOE,SAAS;AAClB;AAEA,eAAe,SAASC,eAAeA,CACrCC,qBAA2E,EAC3EC,YAAoB,EACsB;EAC1C,IAAID,qBAAqB,EAAE;IACzB,MAAME,QAAQ,GAAIN,KAAsB,IAAK;MAC3C,IACE,EAAE,OAAOA,KAAK,KAAK,QAAQ,IAAID,WAAW,CAACC,KAAK,CAAC,CAAC;MAAI;MACtD,EAAEA,KAAK,YAAYC,MAAM,CAAC,EAC1B;QACA,MAAM,IAAIM,SAAS,CACjB,yEACF,CAAC;MACH;IACF,CAAC;IAED,IAAIC,KAAK,CAACC,OAAO,CAACL,qBAAqB,CAAC,EAAE;MACxCA,qBAAqB,CAACM,KAAK,CAACJ,QAAQ,CAAC;IACvC,CAAC,MAAM;MACLA,QAAQ,CAACF,qBAAqB,CAAC;IACjC;IACA,OAAOA,qBAAqB;EAC9B;;EAEA;EACA,IAAIO,GAAG,GAAGN,YAAY;EACtB,IAAI,sBAAsB,CAACO,IAAI,CAACD,GAAG,CAAC,EAAE;IACpCA,GAAG,GAAG,WAAWN,YAAY,CAACP,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,EAAE;EACtD;EACAa,GAAG,GAAG,IAAIE,GAAG,CAACF,GAAG,CAAC,CAACG,MAAM;EAEzBH,GAAG,GAAGf,WAAW,CAACe,GAAG,CAAC;EACtB,OAAOA,GAAG;AACZ;AAEA,OAAO,SAASI,eAAeA,CAC7BD,MAAc,EACdE,aAAmE,EAC1D;EACT,MAAMC,QAAQ,GACZT,KAAK,CAACC,OAAO,CAACO,aAAa,CAAC,GAC1BA,aAAa,CAACE,GAAG,CAACnB,WAAW,CAAC,GAC9B,CAACA,WAAW,CAACiB,aAAa,CAAC,CAAC;EAChC,OAAOC,QAAQ,CAACE,IAAI,CACjBC,OAAO,IAAK,CAAAA,OAAO,oBAAPA,OAAO,CAAER,IAAI,CAACE,MAAM,CAAC,MAAIM,OAAO,oBAAPA,OAAO,CAAER,IAAI,CAAC,GAAGE,MAAM,GAAG,CAAC,CACnE,CAAC,EAAC;AACJ","ignoreList":[]}