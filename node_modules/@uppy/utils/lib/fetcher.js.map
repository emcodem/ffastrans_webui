{"version":3,"names":["NetworkError","ProgressTimeout","noop","fetcher","url","options","body","headers","method","onBeforeRequest","onUploadProgress","shouldRetry","onAfterResponse","onTimeout","responseType","retries","signal","timeout","withCredentials","delay","attempt","timer","requestWithRetry","retryCount","Promise","resolve","reject","xhr","XMLHttpRequest","open","addEventListener","abort","DOMException","onload","status","done","setTimeout","then","statusText","onerror","upload","onprogress","event","progress","Object","keys","forEach","key","setRequestHeader","send"],"sources":["fetcher.ts"],"sourcesContent":["import NetworkError from './NetworkError.ts'\nimport ProgressTimeout from './ProgressTimeout.ts'\n\nconst noop = (): void => {}\n\nexport type FetcherOptions = {\n  /** The HTTP method to use for the request. Default is 'GET'. */\n  method?: string\n\n  /** The request payload, if any. Default is null. */\n  body?: Document | XMLHttpRequestBodyInit | null\n\n  /** Milliseconds between XMLHttpRequest upload progress events before the request is aborted. Default is 30000 ms. */\n  timeout?: number\n\n  /** Sets the withCredentials property of the XMLHttpRequest object. Default is false. */\n  withCredentials?: boolean\n\n  /** Sets the responseType property of the XMLHttpRequest object. Default is an empty string. */\n  responseType?: XMLHttpRequestResponseType\n\n  /** An object representing any headers to send with the request. */\n  headers?: Record<string, string>\n\n  /** The number of retry attempts to make if the request fails. Default is 3. */\n  retries?: number\n\n  /** Called before the request is made. */\n  onBeforeRequest?: (\n    xhr: XMLHttpRequest,\n    retryCount: number,\n  ) => void | Promise<void>\n\n  /** Function for tracking upload progress. */\n  onUploadProgress?: (event: ProgressEvent) => void\n\n  /** A function to determine whether to retry the request. */\n  shouldRetry?: (xhr: XMLHttpRequest) => boolean\n\n  /** Called after the response has succeeded or failed but before the promise is resolved. */\n  onAfterResponse?: (\n    xhr: XMLHttpRequest,\n    retryCount: number,\n  ) => void | Promise<void>\n\n  /** Called when no XMLHttpRequest upload progress events have been received for `timeout` ms. */\n  onTimeout?: (timeout: number) => void\n\n  /** Signal to abort the upload. */\n  signal?: AbortSignal\n}\n\n/**\n * Fetches data from a specified URL using XMLHttpRequest, with optional retry functionality and progress tracking.\n *\n * @param url The URL to send the request to.\n * @param options Optional settings for the fetch operation.\n */\nexport function fetcher(\n  url: string,\n  options: FetcherOptions = {},\n): Promise<XMLHttpRequest> {\n  const {\n    body = null,\n    headers = {},\n    method = 'GET',\n    onBeforeRequest = noop,\n    onUploadProgress = noop,\n    shouldRetry = () => true,\n    onAfterResponse = noop,\n    onTimeout = noop,\n    responseType,\n    retries = 3,\n    signal = null,\n    timeout = 30_000,\n    withCredentials = false,\n  } = options\n\n  // 300 ms, 600 ms, 1200 ms, 2400 ms, 4800 ms\n  const delay = (attempt: number): number => 0.3 * 2 ** (attempt - 1) * 1000\n  const timer = new ProgressTimeout(timeout, onTimeout)\n\n  function requestWithRetry(retryCount = 0): Promise<XMLHttpRequest> {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      const xhr = new XMLHttpRequest()\n\n      xhr.open(method, url, true)\n      xhr.withCredentials = withCredentials\n      if (responseType) {\n        xhr.responseType = responseType\n      }\n\n      signal?.addEventListener('abort', () => {\n        xhr.abort()\n        // Using DOMException for abort errors aligns with\n        // the convention established by the Fetch API.\n        reject(new DOMException('Aborted', 'AbortError'))\n      })\n\n      xhr.onload = async () => {\n        await onAfterResponse(xhr, retryCount)\n\n        if (xhr.status >= 200 && xhr.status < 300) {\n          timer.done()\n          resolve(xhr)\n        } else if (shouldRetry(xhr) && retryCount < retries) {\n          setTimeout(() => {\n            requestWithRetry(retryCount + 1).then(resolve, reject)\n          }, delay(retryCount))\n        } else {\n          timer.done()\n          reject(new NetworkError(xhr.statusText, xhr))\n        }\n      }\n\n      xhr.onerror = () => {\n        if (shouldRetry(xhr) && retryCount < retries) {\n          setTimeout(() => {\n            requestWithRetry(retryCount + 1).then(resolve, reject)\n          }, delay(retryCount))\n        } else {\n          timer.done()\n          reject(new NetworkError(xhr.statusText, xhr))\n        }\n      }\n\n      xhr.upload.onprogress = (event: ProgressEvent) => {\n        timer.progress()\n        onUploadProgress(event)\n      }\n\n      if (headers) {\n        Object.keys(headers).forEach((key) => {\n          xhr.setRequestHeader(key, headers[key])\n        })\n      }\n\n      await onBeforeRequest(xhr, retryCount)\n      xhr.send(body)\n    })\n  }\n\n  return requestWithRetry()\n}\n"],"mappings":"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","ignoreList":[]}