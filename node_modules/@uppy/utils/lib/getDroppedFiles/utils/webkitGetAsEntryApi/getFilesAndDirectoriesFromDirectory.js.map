{"version":3,"names":["getFilesAndDirectoriesFromDirectory","directoryReader","oldEntries","logDropError","_ref","onSuccess","readEntries","entries","newEntries","length","queueMicrotask","error"],"sources":["getFilesAndDirectoriesFromDirectory.ts"],"sourcesContent":["/**\n * Recursive function, calls the original callback() when the directory is entirely parsed.\n */\nexport default function getFilesAndDirectoriesFromDirectory(\n  directoryReader: FileSystemDirectoryReader,\n  oldEntries: FileSystemEntry[],\n  logDropError: (error?: unknown) => void,\n  { onSuccess }: { onSuccess: (newEntries: FileSystemEntry[]) => void },\n): void {\n  directoryReader.readEntries(\n    (entries) => {\n      const newEntries = [...oldEntries, ...entries]\n      // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory()\n      // must be called until it calls the onSuccess with an empty array.\n      if (entries.length) {\n        queueMicrotask(() => {\n          getFilesAndDirectoriesFromDirectory(\n            directoryReader,\n            newEntries,\n            logDropError,\n            { onSuccess },\n          )\n        })\n        // Done iterating this particular directory\n      } else {\n        onSuccess(newEntries)\n      }\n    },\n    // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!\n    (error) => {\n      logDropError(error)\n      onSuccess(oldEntries)\n    },\n  )\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,eAAe,SAASA,mCAAmCA,CACzDC,eAA0C,EAC1CC,UAA6B,EAC7BC,YAAuC,EAAAC,IAAA,EAEjC;EAAA,IADN;IAAEC;EAAkE,CAAC,GAAAD,IAAA;EAErEH,eAAe,CAACK,WAAW,CACxBC,OAAO,IAAK;IACX,MAAMC,UAAU,GAAG,CAAC,GAAGN,UAAU,EAAE,GAAGK,OAAO,CAAC;IAC9C;IACA;IACA,IAAIA,OAAO,CAACE,MAAM,EAAE;MAClBC,cAAc,CAAC,MAAM;QACnBV,mCAAmC,CACjCC,eAAe,EACfO,UAAU,EACVL,YAAY,EACZ;UAAEE;QAAU,CACd,CAAC;MACH,CAAC,CAAC;MACF;IACF,CAAC,MAAM;MACLA,SAAS,CAACG,UAAU,CAAC;IACvB;EACF,CAAC;EACD;EACCG,KAAK,IAAK;IACTR,YAAY,CAACQ,KAAK,CAAC;IACnBN,SAAS,CAACH,UAAU,CAAC;EACvB,CACF,CAAC;AACH","ignoreList":[]}