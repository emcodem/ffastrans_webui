{"version":3,"names":["insertReplacement","source","rx","replacement","newParts","forEach","chunk","push","Symbol","split","raw","i","list","length","interpolate","phrase","options","dollarRegex","dollarBillsYall","interpolated","arg","Object","keys","replace","RegExp","defaultOnMissingKey","key","Error","_onMissingKey","_classPrivateFieldLooseKey","_apply","Translator","constructor","locales","_temp","onMissingKey","defineProperty","value","_apply2","writable","locale","strings","pluralize","n","Array","isArray","_classPrivateFieldLooseBase","translate","translateArray","join","string","hasPluralForms","smart_count","plural","prevLocale","assign"],"sources":["Translator.ts"],"sourcesContent":["import type { h } from 'preact'\n\n// We're using a generic because languages have different plural rules.\nexport interface Locale<T extends number = number> {\n  strings: Record<string, string | Record<T, string>>\n  pluralize: (n: number) => T\n}\n\nexport type OptionalPluralizeLocale<T extends number = number> =\n  | (Omit<Locale<T>, 'pluralize'> & Partial<Pick<Locale<T>, 'pluralize'>>)\n  | undefined\n\n// eslint-disable-next-line no-use-before-define\nexport type I18n = Translator['translate']\n\ntype Options = {\n  smart_count?: number\n} & {\n  [key: string]: string | number | h.JSX.Element\n}\n\nfunction insertReplacement(\n  source: Array<string | unknown>,\n  rx: RegExp,\n  replacement: string,\n): Array<string | unknown> {\n  const newParts: Array<string | unknown> = []\n  source.forEach((chunk) => {\n    // When the source contains multiple placeholders for interpolation,\n    // we should ignore chunks that are not strings, because those\n    // can be JSX objects and will be otherwise incorrectly turned into strings.\n    // Without this condition weâ€™d get this: [object Object] hello [object Object] my <button>\n    if (typeof chunk !== 'string') {\n      return newParts.push(chunk)\n    }\n\n    return rx[Symbol.split](chunk).forEach((raw, i, list) => {\n      if (raw !== '') {\n        newParts.push(raw)\n      }\n\n      // Interlace with the `replacement` value\n      if (i < list.length - 1) {\n        newParts.push(replacement)\n      }\n    })\n  })\n  return newParts\n}\n\n/**\n * Takes a string with placeholder variables like `%{smart_count} file selected`\n * and replaces it with values from options `{smart_count: 5}`\n *\n * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n *\n * @param phrase that needs interpolation, with placeholders\n * @param options with values that will be used to replace placeholders\n */\nfunction interpolate(\n  phrase: string,\n  options?: Options,\n): Array<string | unknown> {\n  const dollarRegex = /\\$/g\n  const dollarBillsYall = '$$$$'\n  let interpolated: Array<string | unknown> = [phrase]\n\n  if (options == null) return interpolated\n\n  for (const arg of Object.keys(options)) {\n    if (arg !== '_') {\n      // Ensure replacement value is escaped to prevent special $-prefixed\n      // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n      // be escaped with \"$\" itself, and we need two in the resulting output.\n      let replacement = options[arg]\n      if (typeof replacement === 'string') {\n        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall)\n      }\n      // We create a new `RegExp` each time instead of using a more-efficient\n      // string replace so that the same argument can be replaced multiple times\n      // in the same phrase.\n      interpolated = insertReplacement(\n        interpolated,\n        new RegExp(`%\\\\{${arg}\\\\}`, 'g'),\n        replacement as string,\n      )\n    }\n  }\n\n  return interpolated\n}\n\nconst defaultOnMissingKey = (key: string): void => {\n  throw new Error(`missing string: ${key}`)\n}\n\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\nexport default class Translator {\n  readonly locale: Locale\n\n  constructor(\n    locales: Locale | Array<OptionalPluralizeLocale | undefined>,\n    { onMissingKey = defaultOnMissingKey } = {},\n  ) {\n    this.locale = {\n      strings: {},\n      pluralize(n: number): 0 | 1 {\n        if (n === 1) {\n          return 0\n        }\n        return 1\n      },\n    }\n\n    if (Array.isArray(locales)) {\n      locales.forEach(this.#apply, this)\n    } else {\n      this.#apply(locales)\n    }\n\n    this.#onMissingKey = onMissingKey\n  }\n\n  #onMissingKey\n\n  #apply(locale?: OptionalPluralizeLocale): void {\n    if (!locale?.strings) {\n      return\n    }\n\n    const prevLocale = this.locale\n    Object.assign(this.locale, {\n      strings: { ...prevLocale.strings, ...locale.strings },\n      pluralize: locale.pluralize || prevLocale.pluralize,\n    })\n  }\n\n  /**\n   * Public translate method\n   *\n   * @param key\n   * @param options with values that will be used later to replace placeholders in string\n   * @returns string translated (and interpolated)\n   */\n  translate(key: string, options?: Options): string {\n    return this.translateArray(key, options).join('')\n  }\n\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @returns The translated and interpolated parts, in order.\n   */\n  translateArray(key: string, options?: Options): Array<string | unknown> {\n    let string = this.locale.strings[key]\n    if (string == null) {\n      this.#onMissingKey(key)\n      string = key\n    }\n    const hasPluralForms = typeof string === 'object'\n\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        const plural = this.locale.pluralize(options.smart_count)\n        return interpolate(string[plural], options)\n      }\n      throw new Error(\n        'Attempted to use a string with plural forms, but no value was given for %{smart_count}',\n      )\n    }\n\n    if (typeof string !== 'string') {\n      throw new Error(`string was not a string`)\n    }\n\n    return interpolate(string, options)\n  }\n}\n"],"mappings":"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","ignoreList":[]}