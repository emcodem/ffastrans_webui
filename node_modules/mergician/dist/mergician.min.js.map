{
  "version": 3,
  "sources": ["../src/util.cjs", "../src/index.cjs"],
  "sourcesContent": ["/**\n * Returns a map of array values and their occurrence count\n *\n * @example\n * countOccurrences([1, 2], [2, 3]); // { 1: 1, 2: 2, 3: 1 }\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {object} Array values and their occurrence count\n */\nfunction countOccurrences(...arrays) {\n    const countObj = {};\n\n    arrays.forEach(array => {\n        array.forEach(v => {\n            countObj[v] = v in countObj ? ++countObj[v] : 1;\n        });\n    });\n\n    return countObj;\n}\n\n/**\n * Returns values found in multiple (possibly all) arrays\n *\n * @example\n * getInMultiple([1, 2], [2, 3]); // [2]\n * getInMultiple([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [2, 3, 4]\n * getInMultiple([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [2, 3, 4, 'x']\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getInMultiple(...arrays) {\n    const countObj = countOccurrences(...arrays);\n\n    return Object.keys(countObj).filter((v) => countObj[v] > 1);\n}\n\n/**\n * Returns values found in all arrays\n *\n * @example\n * getInAll([1, 2], [2, 3]); // [2]\n * getInAll([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [3]\n * getInAll([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [3]\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getInAll(...arrays) {\n    return arrays.reduce((acc, curr) =>\n        acc.filter(Set.prototype.has, new Set(curr))\n    );\n}\n\n/**\n * Returns values found in one array only (i.e. not multiple)\n *\n * @example\n * getNotInMultiple([1, 2], [2, 3]); // [1, 3]\n * getNotInMultiple([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [1, 5]\n * getNotInMultiple([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [1, 5]\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getNotInMultiple(...arrays) {\n    const countObj = countOccurrences(...arrays);\n\n    return Object.keys(countObj).filter((v) => countObj[v] === 1);\n}\n\n/**\n * Returns values not found in all arrays\n *\n * @example\n * getNotInAll([1, 2], [2, 3]); // [1, 3]\n * getNotInAll([1, 2, 3], [2, 3, 4], [3, 4, 5]); // [1, 2, 4, 5]\n * getNotInAll([1, 2, 3, 'x'], [2, 3, 4, 'x'], [3, 4, 5]); // [1, 2, 4, 5, 'x']\n *\n * @param {...array} arrays - Arrays to be compared\n * @return {array} List of values\n */\nfunction getNotInAll(...arrays) {\n    const countObj = countOccurrences(...arrays);\n\n    return Object.keys(countObj).filter((v) => countObj[v] < arrays.length);\n}\n\n/**\n * Returns array of an object's own keys and (optionally) those from the\n * object's prototype chain.\n *\n * @example\n * getObjectKeys({ a: 1 }); // ['a']\n * getObjectKeys({ a: 1 }, true); // ['a', 'b', 'c', ...]\n *\n * @param {object} obj - Object to parse\n * @param {boolean} includeProto include key/values from prototype\n * @return {array} List of keys\n */\nfunction getObjectKeys(obj, includeProto = false) {\n    if (includeProto) {\n        const keys = [];\n\n        for (const key in obj) {\n            keys.push(key);\n        }\n\n        return keys;\n    }\n    else {\n        return Object.keys(obj);\n    }\n}\n\n/**\n * Determines if the value passed was created using the Object constructor\n *\n * @param {*} obj - Value to test\n * @return {boolean}\n */\nfunction isObject(value) {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        !Array.isArray(value)\n    );\n}\n\n/**\n * Determines if the value passed is a property descriptor\n *\n * @param {*} obj - Value to test\n * @return {boolean}\n */\nfunction isPropDescriptor(obj) {\n    if (!isObject(obj)) {\n        return false;\n    }\n\n    const hasFlagKey = ['writable', 'enumerable', 'configurable'].some(key => key in obj);\n    const hasMethod = ['get', 'set'].some(key => typeof obj[key] === 'function');\n    const hasMethodKeys = ['get', 'set'].every(key => key in obj);\n\n    let isDescriptor = (\n        ('value' in obj && hasFlagKey) ||\n        (hasMethod && (hasMethodKeys || hasFlagKey))\n    );\n\n    // Test for invalid key(s)\n    if (isDescriptor) {\n        const validKeys = [\n            'configurable',\n            'get',\n            'set',\n            'enumerable',\n            'value',\n            'writable'\n        ];\n\n        isDescriptor = Object.keys(obj).some(key => !(key in validKeys));\n    }\n\n    return isDescriptor;\n}\n\nmodule.exports = {\n    countOccurrences,\n    getInMultiple,\n    getInAll,\n    getNotInMultiple,\n    getNotInAll,\n    getObjectKeys,\n    isObject,\n    isPropDescriptor\n};\n", "const {\n    getInMultiple,\n    getInAll,\n    getNotInMultiple,\n    getNotInAll,\n    getObjectKeys,\n    isObject,\n    isPropDescriptor\n} = require('./util.cjs');\n\nconst defaults = {\n    // Keys\n    onlyKeys: [],\n    skipKeys: [],\n    onlyCommonKeys: false,\n    onlyUniversalKeys: false,\n    skipCommonKeys: false,\n    skipUniversalKeys: false,\n    // Values\n    invokeGetters: false,\n    skipSetters: false,\n    // Arrays\n    appendArrays: false,\n    prependArrays: false,\n    dedupArrays: false,\n    sortArrays: false,\n    // Prototype\n    hoistProto: false,\n    // Callbacks\n    filter: Function.prototype,\n    beforeEach: Function.prototype,\n    afterEach: Function.prototype,\n    onCircular: Function.prototype,\n};\n\n/**\n * Deep recursive object merging with options to inspect, modify, and filter\n * keys/values, merge arrays (append/prepend), and remove duplicate values from\n * merged arrays. Returns new object without modifying sources (immutable).\n *\n * @preserve\n *\n * @example\n * // Without options (use default option values)\n * mergician(obj1, obj2, obj3, ...);\n *\n * @example\n * // With options (defaults shown)\n * mergician({\n *   // Keys\n *   onlyKeys: [],\n *   skipKeys: [],\n *   onlyCommonKeys: false,\n *   onlyUniversalKeys: false,\n *   skipCommonKeys: false,\n *   skipUniversalKeys: false,\n *   // Values\n *   invokeGetters: false,\n *   skipSetters: false,\n *   // Arrays\n *   appendArrays: false,\n *   prependArrays: false,\n *   dedupArrays: false,\n *   sortArrays: false,\n *   // Prototype\n *   hoistProto: false,\n *   // Callbacks\n *   filter({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n *   beforeEach({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n *   afterEach({ depth, key, mergeVal, srcObj, targetObj }) {},\n *   onCircular({ depth, key, srcObj, srcVal, targetObj, targetVal }) {}\n * })(obj1, obj2, obj3, ...)\n *\n * @param {...object} optionsOrObjects - Options or objects to merge\n * @param {array} [options.onlyKeys] - Exclusive array of keys to be merged\n * (others are skipped)\n * @param {array} [options.skipKeys] - Array of keys to skip (others are merged)\n * @param {boolean} [options.onlyCommonKeys = false] - Merge only keys found in\n * multiple objects (ignore single occurrence keys)\n * @param {boolean} [options.onlyUniversalKeys = false] - Merge only keys found\n * in all objects\n * @param {boolean} [options.skipCommonKeys = false] - Skip keys found in\n * multiple objects (merge only single occurrence keys)\n * @param {boolean} [options.skipUniversalKeys = false] - Skip keys found in all\n * objects (merge only common keys)\n * @param {boolean} [options.invokeGetters = false] - Invoke \"getter\" methods\n * and merge returned values\n * @param {boolean} [options.skipSetters = false] - Skip \"setter\" methods during\n * merge\n * @param {boolean} [options.appendArrays = false] - Merge array values at the\n * end of existing arrays\n * @param {boolean} [options.prependArrays = false] - Merge array values at the\n * beginning of existing arrays\n * @param {boolean} [options.dedupArrays = false] - Remove duplicate array\n * values in new merged object\n * @param {boolean|function} [options.sortArrays = false] - Sort array values in\n * new merged object\n * @param {boolean} [options.hoistProto = false] - Clone prototype properties as\n * direct properties of merged/cloned object\n * @param {function} [options.filter] - Callback used to conditionally merge or\n * skip a property. Return a \"truthy\" value to merge or a \"falsy\" value to skip.\n * Return no value to proceed according to other option values.\n * @param {function} [options.beforeEach] - Callback used for\n * inspecting/modifying properties before merge. Return value is used as value\n * to merge.\n * @param {function} [options.afterEach] - Callback used for\n * inspecting/modifying properties after merge. Return value is used as merged\n * value.\n * @param {function} [options.onCircular] - Callback used for handling circular\n * object references during merge\n * @returns {function|object} Merge function with options applied or new merged\n * object\n * @param {...object} [objects] - Objects to merge\n * @returns {object} New merged object\n */\nfunction mergician(...optionsOrObjects) {\n    const options = arguments.length === 1 ? arguments[0] : {};\n    const settings = { ...defaults, ...options };\n    const dedupArrayMap = new Map();\n    const sortArrayMap = new Map();\n    const sortArrayFn = typeof settings.sortArrays === 'function' ? settings.sortArrays : undefined;\n\n    // Store circular references from source and reassign to target\n    // Key = original source reference\n    // Value = cloned/merged target reference\n    const circularRefs = new WeakMap();\n\n    let mergeDepth = 0;\n\n    function _getObjectKeys(obj) {\n        return getObjectKeys(obj, settings.hoistProto);\n    }\n\n    function _mergician(...objects) {\n        let mergeKeyList;\n\n        if (objects.length > 1) {\n            if (settings.onlyCommonKeys) {\n                mergeKeyList = getInMultiple(...objects.map(obj => _getObjectKeys(obj)));\n            }\n            else if (settings.onlyUniversalKeys) {\n                mergeKeyList = getInAll(...objects.map(obj => _getObjectKeys(obj)));\n            }\n            else if (settings.skipCommonKeys) {\n                mergeKeyList = getNotInMultiple(...objects.map(obj => _getObjectKeys(obj)));\n            }\n            else if (settings.skipUniversalKeys) {\n                mergeKeyList = getNotInAll(...objects.map(obj => _getObjectKeys(obj)));\n            }\n        }\n\n        if (!mergeKeyList && settings.onlyKeys.length) {\n            mergeKeyList = settings.onlyKeys;\n        }\n\n        if (mergeKeyList && mergeKeyList !== settings.onlyKeys && settings.onlyKeys.length) {\n            mergeKeyList = mergeKeyList.filter(key => settings.onlyKeys.includes(key));\n        }\n\n        const newObj = objects.reduce((targetObj, srcObj) => {\n            circularRefs.set(srcObj, targetObj);\n\n            let keys = mergeKeyList || _getObjectKeys(srcObj);\n\n            if (settings.skipKeys.length) {\n                keys = keys.filter(key => settings.skipKeys.indexOf(key) === -1);\n            }\n\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                const targetVal = targetObj[key];\n\n                let isReturnVal = false;\n                let mergeVal;\n\n                if (key in srcObj === false) {\n                    continue;\n                }\n\n                try {\n                    mergeVal = srcObj[key];\n                }\n                catch(err) {\n                    console.error(err);\n                    continue;\n                }\n\n                const srcDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);\n                const isSetterOnly = srcDescriptor && typeof srcDescriptor.set === 'function' && typeof srcDescriptor.get !== 'function';\n\n                if (isSetterOnly) {\n                    if (!settings.skipSetters) {\n                        srcDescriptor.configurable = true;\n                        Object.defineProperty(targetObj, key, srcDescriptor);\n                    }\n\n                    continue;\n                }\n\n                if (settings.filter !== defaults.filter) {\n                    const returnVal = settings.filter({\n                        depth: mergeDepth,\n                        key,\n                        srcObj,\n                        srcVal: mergeVal,\n                        targetObj,\n                        targetVal\n                    });\n\n                    if (returnVal !== undefined && !returnVal) {\n                        continue;\n                    }\n                }\n\n                if (settings.beforeEach !== defaults.beforeEach) {\n                    const returnVal = settings.beforeEach({\n                        depth: mergeDepth,\n                        key,\n                        srcObj,\n                        srcVal: mergeVal,\n                        targetObj,\n                        targetVal\n                    });\n\n                    if (returnVal !== undefined) {\n                        isReturnVal = true;\n                        mergeVal = returnVal;\n                    }\n                }\n\n                // Circular references\n                if (typeof mergeVal === 'object' && mergeVal !== null) {\n                    if (circularRefs.has(srcObj[key])) {\n                        const returnVal = settings.onCircular({\n                            depth: mergeDepth,\n                            key,\n                            srcObj,\n                            srcVal: srcObj[key],\n                            targetObj,\n                            targetVal\n                        });\n\n                        if (returnVal === undefined) {\n                            mergeVal = circularRefs.get(srcObj[key]);\n                            targetObj[key] = mergeVal;\n                            continue;\n                        }\n\n                        isReturnVal = true;\n                        mergeVal = returnVal;\n                    }\n                }\n\n                if (Array.isArray(mergeVal)) {\n                    mergeVal = [...mergeVal];\n\n                    if (Array.isArray(targetVal)) {\n                        if (settings.appendArrays) {\n                            mergeVal = [...targetVal, ...mergeVal];\n                        }\n                        else if (settings.prependArrays) {\n                            mergeVal = [...mergeVal, ...targetVal];\n                        }\n                    }\n\n                    if (settings.dedupArrays) {\n                        // If a user-defined afterEach callback exists, remove\n                        // duplicates so the expected value is returned (slower)\n                        if (settings.afterEach !== defaults.afterEach) {\n                            mergeVal = [...new Set(mergeVal)];\n                        }\n                        // If not, store a reference to the array so duplicates\n                        // can be removed after merge is complete (faster)\n                        else {\n                            const keyArray = dedupArrayMap.get(targetObj);\n\n                            if (keyArray && !keyArray.includes(key)) {\n                                keyArray.push(key);\n                            }\n                            else {\n                                dedupArrayMap.set(targetObj, [key]);\n                            }\n                        }\n                    }\n\n                    if (settings.sortArrays) {\n                        // If a user-defined afterEach callback exists, sort the\n                        // array so the expected value is returned (slower)\n                        if (settings.afterEach !== defaults.afterEach) {\n                            mergeVal = mergeVal.sort(sortArrayFn);\n                        }\n                        // If not, store a reference to the array so duplicates\n                        // can be removed after merge is complete (faster)\n                        else {\n                            const keyArray = sortArrayMap.get(targetObj);\n\n                            if (keyArray && !keyArray.includes(key)) {\n                                keyArray.push(key);\n                            }\n                            else {\n                                sortArrayMap.set(targetObj, [key]);\n                            }\n                        }\n                    }\n                }\n                else if (isObject(mergeVal) && (!isReturnVal || !isPropDescriptor(mergeVal))) {\n                    mergeDepth++;\n\n                    if (isObject(targetVal)) {\n                        mergeVal = _mergician(targetVal, mergeVal);\n                    }\n                    else {\n                        mergeVal = _mergician(mergeVal);\n                    }\n\n                    mergeDepth--;\n                }\n\n                if (settings.afterEach !== defaults.afterEach) {\n                    const returnVal = settings.afterEach({\n                        depth: mergeDepth,\n                        key,\n                        mergeVal,\n                        srcObj,\n                        targetObj\n                    });\n\n                    if (returnVal !== undefined) {\n                        isReturnVal = true;\n                        mergeVal = returnVal;\n                    }\n                }\n\n                if (isReturnVal) {\n                    if (isPropDescriptor(mergeVal)) {\n                        // Descriptor properties 'configurable', 'enumerable',\n                        // and 'writable' default to 'false' when using\n                        // Object.defineProperty() but to 'true' when using the\n                        // assignment operator (obj.a = 1). It is therefore\n                        // necessary to set 'configurable' and 'writable'\n                        // properties to 'true' to ensure subsequent merge tasks\n                        // complete successfully.\n                        mergeVal.configurable = true;\n                        mergeVal.enumerable = !('enumerable' in mergeVal) ? true : mergeVal.enumerable;\n\n                        if ('value' in mergeVal && !('writable' in mergeVal)) {\n                            mergeVal.writable = true;\n                        }\n\n                        Object.defineProperty(targetObj, key, mergeVal);\n                    }\n                    else {\n                        targetObj[key] = mergeVal;\n                    }\n                }\n                else {\n                    const mergeDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);\n\n                    if (mergeDescriptor && typeof mergeDescriptor.get === 'function' && !settings.invokeGetters) {\n                        if (settings.skipSetters) {\n                            mergeDescriptor.set = undefined;\n                        }\n\n                        // Set as configurable for subsequent merges\n                        mergeDescriptor.configurable = true;\n                        Object.defineProperty(targetObj, key, mergeDescriptor);\n                    }\n                    else {\n                        targetObj[key] = mergeVal;\n                    }\n                }\n            }\n\n            return targetObj;\n        }, {});\n\n        // Remove duplicate\n        for (const [obj, keyArray] of dedupArrayMap.entries()) {\n            for (const key of keyArray) {\n                obj[key] = [...new Set(obj[key])];\n            }\n        }\n\n        // Sort arrays\n        for (const [obj, keyArray] of sortArrayMap.entries()) {\n            for (const key of keyArray) {\n                obj[key].sort(sortArrayFn);\n            }\n        }\n\n        return newObj;\n    }\n\n    // With options\n    // Ex: mergician({...})\n    if (arguments.length === 1) {\n        return function (...objects) {\n            // Options passed to custom merge function\n            if (arguments.length === 1) {\n                return mergician({ ...settings, ...objects[0] });\n            }\n            else {\n                return _mergician(...objects);\n            }\n        };\n    }\n    // Without options\n    // Ex: mergician(obj1, obj2);\n    else {\n        return _mergician(...arguments);\n    }\n}\n\nmodule.exports = mergician;\n"],
  "mappings": "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",
  "names": ["require_util", "__commonJSMin", "exports", "module", "countOccurrences", "arrays", "countObj", "array", "v", "getInMultiple", "getInAll", "acc", "curr", "getNotInMultiple", "getNotInAll", "getObjectKeys", "obj", "includeProto", "keys", "key", "isObject", "value", "isPropDescriptor", "hasFlagKey", "hasMethod", "hasMethodKeys", "isDescriptor", "validKeys", "require_src", "__commonJSMin", "exports", "module", "getInMultiple", "getInAll", "getNotInMultiple", "getNotInAll", "getObjectKeys", "isObject", "isPropDescriptor", "defaults", "mergician", "optionsOrObjects", "options", "settings", "dedupArrayMap", "sortArrayMap", "sortArrayFn", "circularRefs", "mergeDepth", "_getObjectKeys", "obj", "_mergician", "objects", "mergeKeyList", "key", "newObj", "targetObj", "srcObj", "keys", "i", "targetVal", "isReturnVal", "mergeVal", "err", "srcDescriptor", "returnVal", "keyArray", "mergeDescriptor"]
}
