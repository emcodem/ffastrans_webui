/*!
 * mergician
 * v1.1.0
 * https://jhildenbiddle.github.io/mergician/
 * (c) 2022-2023 John Hildenbiddle
 * MIT license
 */
var mergician = (() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // src/util.cjs
  var require_util = __commonJS({
    "src/util.cjs"(exports, module) {
      function countOccurrences(...arrays) {
        const countObj = {};
        arrays.forEach((array) => {
          array.forEach((v) => {
            countObj[v] = v in countObj ? ++countObj[v] : 1;
          });
        });
        return countObj;
      }
      function getInMultiple(...arrays) {
        const countObj = countOccurrences(...arrays);
        return Object.keys(countObj).filter((v) => countObj[v] > 1);
      }
      function getInAll(...arrays) {
        return arrays.reduce(
          (acc, curr) => acc.filter(Set.prototype.has, new Set(curr))
        );
      }
      function getNotInMultiple(...arrays) {
        const countObj = countOccurrences(...arrays);
        return Object.keys(countObj).filter((v) => countObj[v] === 1);
      }
      function getNotInAll(...arrays) {
        const countObj = countOccurrences(...arrays);
        return Object.keys(countObj).filter((v) => countObj[v] < arrays.length);
      }
      function getObjectKeys(obj, includeProto = false) {
        if (includeProto) {
          const keys = [];
          for (const key in obj) {
            keys.push(key);
          }
          return keys;
        } else {
          return Object.keys(obj);
        }
      }
      function isObject(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
      }
      function isPropDescriptor(obj) {
        if (!isObject(obj)) {
          return false;
        }
        const hasFlagKey = ["writable", "enumerable", "configurable"].some((key) => key in obj);
        const hasMethod = ["get", "set"].some((key) => typeof obj[key] === "function");
        const hasMethodKeys = ["get", "set"].every((key) => key in obj);
        let isDescriptor = "value" in obj && hasFlagKey || hasMethod && (hasMethodKeys || hasFlagKey);
        if (isDescriptor) {
          const validKeys = [
            "configurable",
            "get",
            "set",
            "enumerable",
            "value",
            "writable"
          ];
          isDescriptor = Object.keys(obj).some((key) => !(key in validKeys));
        }
        return isDescriptor;
      }
      module.exports = {
        countOccurrences,
        getInMultiple,
        getInAll,
        getNotInMultiple,
        getNotInAll,
        getObjectKeys,
        isObject,
        isPropDescriptor
      };
    }
  });

  // src/index.cjs
  var require_src = __commonJS({
    "src/index.cjs"(exports, module) {
      var {
        getInMultiple,
        getInAll,
        getNotInMultiple,
        getNotInAll,
        getObjectKeys,
        isObject,
        isPropDescriptor
      } = require_util();
      var defaults = {
        // Keys
        onlyKeys: [],
        skipKeys: [],
        onlyCommonKeys: false,
        onlyUniversalKeys: false,
        skipCommonKeys: false,
        skipUniversalKeys: false,
        // Values
        invokeGetters: false,
        skipSetters: false,
        // Arrays
        appendArrays: false,
        prependArrays: false,
        dedupArrays: false,
        sortArrays: false,
        // Prototype
        hoistProto: false,
        // Callbacks
        filter: Function.prototype,
        beforeEach: Function.prototype,
        afterEach: Function.prototype,
        onCircular: Function.prototype
      };
      /**
       * Deep recursive object merging with options to inspect, modify, and filter
       * keys/values, merge arrays (append/prepend), and remove duplicate values from
       * merged arrays. Returns new object without modifying sources (immutable).
       *
       * @preserve
       *
       * @example
       * // Without options (use default option values)
       * mergician(obj1, obj2, obj3, ...);
       *
       * @example
       * // With options (defaults shown)
       * mergician({
       *   // Keys
       *   onlyKeys: [],
       *   skipKeys: [],
       *   onlyCommonKeys: false,
       *   onlyUniversalKeys: false,
       *   skipCommonKeys: false,
       *   skipUniversalKeys: false,
       *   // Values
       *   invokeGetters: false,
       *   skipSetters: false,
       *   // Arrays
       *   appendArrays: false,
       *   prependArrays: false,
       *   dedupArrays: false,
       *   sortArrays: false,
       *   // Prototype
       *   hoistProto: false,
       *   // Callbacks
       *   filter({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},
       *   beforeEach({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},
       *   afterEach({ depth, key, mergeVal, srcObj, targetObj }) {},
       *   onCircular({ depth, key, srcObj, srcVal, targetObj, targetVal }) {}
       * })(obj1, obj2, obj3, ...)
       *
       * @param {...object} optionsOrObjects - Options or objects to merge
       * @param {array} [options.onlyKeys] - Exclusive array of keys to be merged
       * (others are skipped)
       * @param {array} [options.skipKeys] - Array of keys to skip (others are merged)
       * @param {boolean} [options.onlyCommonKeys = false] - Merge only keys found in
       * multiple objects (ignore single occurrence keys)
       * @param {boolean} [options.onlyUniversalKeys = false] - Merge only keys found
       * in all objects
       * @param {boolean} [options.skipCommonKeys = false] - Skip keys found in
       * multiple objects (merge only single occurrence keys)
       * @param {boolean} [options.skipUniversalKeys = false] - Skip keys found in all
       * objects (merge only common keys)
       * @param {boolean} [options.invokeGetters = false] - Invoke "getter" methods
       * and merge returned values
       * @param {boolean} [options.skipSetters = false] - Skip "setter" methods during
       * merge
       * @param {boolean} [options.appendArrays = false] - Merge array values at the
       * end of existing arrays
       * @param {boolean} [options.prependArrays = false] - Merge array values at the
       * beginning of existing arrays
       * @param {boolean} [options.dedupArrays = false] - Remove duplicate array
       * values in new merged object
       * @param {boolean|function} [options.sortArrays = false] - Sort array values in
       * new merged object
       * @param {boolean} [options.hoistProto = false] - Clone prototype properties as
       * direct properties of merged/cloned object
       * @param {function} [options.filter] - Callback used to conditionally merge or
       * skip a property. Return a "truthy" value to merge or a "falsy" value to skip.
       * Return no value to proceed according to other option values.
       * @param {function} [options.beforeEach] - Callback used for
       * inspecting/modifying properties before merge. Return value is used as value
       * to merge.
       * @param {function} [options.afterEach] - Callback used for
       * inspecting/modifying properties after merge. Return value is used as merged
       * value.
       * @param {function} [options.onCircular] - Callback used for handling circular
       * object references during merge
       * @returns {function|object} Merge function with options applied or new merged
       * object
       * @param {...object} [objects] - Objects to merge
       * @returns {object} New merged object
       */
      function mergician(...optionsOrObjects) {
        const options = arguments.length === 1 ? arguments[0] : {};
        const settings = { ...defaults, ...options };
        const dedupArrayMap = /* @__PURE__ */ new Map();
        const sortArrayMap = /* @__PURE__ */ new Map();
        const sortArrayFn = typeof settings.sortArrays === "function" ? settings.sortArrays : void 0;
        const circularRefs = /* @__PURE__ */ new WeakMap();
        let mergeDepth = 0;
        function _getObjectKeys(obj) {
          return getObjectKeys(obj, settings.hoistProto);
        }
        function _mergician(...objects) {
          let mergeKeyList;
          if (objects.length > 1) {
            if (settings.onlyCommonKeys) {
              mergeKeyList = getInMultiple(...objects.map((obj) => _getObjectKeys(obj)));
            } else if (settings.onlyUniversalKeys) {
              mergeKeyList = getInAll(...objects.map((obj) => _getObjectKeys(obj)));
            } else if (settings.skipCommonKeys) {
              mergeKeyList = getNotInMultiple(...objects.map((obj) => _getObjectKeys(obj)));
            } else if (settings.skipUniversalKeys) {
              mergeKeyList = getNotInAll(...objects.map((obj) => _getObjectKeys(obj)));
            }
          }
          if (!mergeKeyList && settings.onlyKeys.length) {
            mergeKeyList = settings.onlyKeys;
          }
          if (mergeKeyList && mergeKeyList !== settings.onlyKeys && settings.onlyKeys.length) {
            mergeKeyList = mergeKeyList.filter((key) => settings.onlyKeys.includes(key));
          }
          const newObj = objects.reduce((targetObj, srcObj) => {
            circularRefs.set(srcObj, targetObj);
            let keys = mergeKeyList || _getObjectKeys(srcObj);
            if (settings.skipKeys.length) {
              keys = keys.filter((key) => settings.skipKeys.indexOf(key) === -1);
            }
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const targetVal = targetObj[key];
              let isReturnVal = false;
              let mergeVal;
              if (key in srcObj === false) {
                continue;
              }
              try {
                mergeVal = srcObj[key];
              } catch (err) {
                console.error(err);
                continue;
              }
              const srcDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);
              const isSetterOnly = srcDescriptor && typeof srcDescriptor.set === "function" && typeof srcDescriptor.get !== "function";
              if (isSetterOnly) {
                if (!settings.skipSetters) {
                  srcDescriptor.configurable = true;
                  Object.defineProperty(targetObj, key, srcDescriptor);
                }
                continue;
              }
              if (settings.filter !== defaults.filter) {
                const returnVal = settings.filter({
                  depth: mergeDepth,
                  key,
                  srcObj,
                  srcVal: mergeVal,
                  targetObj,
                  targetVal
                });
                if (returnVal !== void 0 && !returnVal) {
                  continue;
                }
              }
              if (settings.beforeEach !== defaults.beforeEach) {
                const returnVal = settings.beforeEach({
                  depth: mergeDepth,
                  key,
                  srcObj,
                  srcVal: mergeVal,
                  targetObj,
                  targetVal
                });
                if (returnVal !== void 0) {
                  isReturnVal = true;
                  mergeVal = returnVal;
                }
              }
              if (typeof mergeVal === "object" && mergeVal !== null) {
                if (circularRefs.has(srcObj[key])) {
                  const returnVal = settings.onCircular({
                    depth: mergeDepth,
                    key,
                    srcObj,
                    srcVal: srcObj[key],
                    targetObj,
                    targetVal
                  });
                  if (returnVal === void 0) {
                    mergeVal = circularRefs.get(srcObj[key]);
                    targetObj[key] = mergeVal;
                    continue;
                  }
                  isReturnVal = true;
                  mergeVal = returnVal;
                }
              }
              if (Array.isArray(mergeVal)) {
                mergeVal = [...mergeVal];
                if (Array.isArray(targetVal)) {
                  if (settings.appendArrays) {
                    mergeVal = [...targetVal, ...mergeVal];
                  } else if (settings.prependArrays) {
                    mergeVal = [...mergeVal, ...targetVal];
                  }
                }
                if (settings.dedupArrays) {
                  if (settings.afterEach !== defaults.afterEach) {
                    mergeVal = [...new Set(mergeVal)];
                  } else {
                    const keyArray = dedupArrayMap.get(targetObj);
                    if (keyArray && !keyArray.includes(key)) {
                      keyArray.push(key);
                    } else {
                      dedupArrayMap.set(targetObj, [key]);
                    }
                  }
                }
                if (settings.sortArrays) {
                  if (settings.afterEach !== defaults.afterEach) {
                    mergeVal = mergeVal.sort(sortArrayFn);
                  } else {
                    const keyArray = sortArrayMap.get(targetObj);
                    if (keyArray && !keyArray.includes(key)) {
                      keyArray.push(key);
                    } else {
                      sortArrayMap.set(targetObj, [key]);
                    }
                  }
                }
              } else if (isObject(mergeVal) && (!isReturnVal || !isPropDescriptor(mergeVal))) {
                mergeDepth++;
                if (isObject(targetVal)) {
                  mergeVal = _mergician(targetVal, mergeVal);
                } else {
                  mergeVal = _mergician(mergeVal);
                }
                mergeDepth--;
              }
              if (settings.afterEach !== defaults.afterEach) {
                const returnVal = settings.afterEach({
                  depth: mergeDepth,
                  key,
                  mergeVal,
                  srcObj,
                  targetObj
                });
                if (returnVal !== void 0) {
                  isReturnVal = true;
                  mergeVal = returnVal;
                }
              }
              if (isReturnVal) {
                if (isPropDescriptor(mergeVal)) {
                  mergeVal.configurable = true;
                  mergeVal.enumerable = !("enumerable" in mergeVal) ? true : mergeVal.enumerable;
                  if ("value" in mergeVal && !("writable" in mergeVal)) {
                    mergeVal.writable = true;
                  }
                  Object.defineProperty(targetObj, key, mergeVal);
                } else {
                  targetObj[key] = mergeVal;
                }
              } else {
                const mergeDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);
                if (mergeDescriptor && typeof mergeDescriptor.get === "function" && !settings.invokeGetters) {
                  if (settings.skipSetters) {
                    mergeDescriptor.set = void 0;
                  }
                  mergeDescriptor.configurable = true;
                  Object.defineProperty(targetObj, key, mergeDescriptor);
                } else {
                  targetObj[key] = mergeVal;
                }
              }
            }
            return targetObj;
          }, {});
          for (const [obj, keyArray] of dedupArrayMap.entries()) {
            for (const key of keyArray) {
              obj[key] = [...new Set(obj[key])];
            }
          }
          for (const [obj, keyArray] of sortArrayMap.entries()) {
            for (const key of keyArray) {
              obj[key].sort(sortArrayFn);
            }
          }
          return newObj;
        }
        if (arguments.length === 1) {
          return function(...objects) {
            if (arguments.length === 1) {
              return mergician({ ...settings, ...objects[0] });
            } else {
              return _mergician(...objects);
            }
          };
        } else {
          return _mergician(...arguments);
        }
      }
      module.exports = mergician;
    }
  });
  return require_src();
})();
