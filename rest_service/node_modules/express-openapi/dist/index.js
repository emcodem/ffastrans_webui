"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
exports.__esModule = true;
var openapi_framework_1 = require("openapi-framework");
var CASE_SENSITIVE_PARAM_PROPERTY = 'x-express-openapi-case-sensitive';
var normalizeQueryParamsMiddleware = require('express-normalize-query-params-middleware');
var loggingPrefix = 'express-openapi';
function initialize(args) {
    if (!args) {
        throw new Error(loggingPrefix + ": args must be an object");
    }
    if (!args.app) {
        throw new Error(loggingPrefix + ": args.app must be an express app");
    }
    var exposeApiDocs = 'exposeApiDocs' in args ? !!args.exposeApiDocs : true;
    if (args.docsPath && typeof args.docsPath !== 'string') {
        throw new Error(loggingPrefix + ": args.docsPath must be a string when given");
    }
    if ('securityFilter' in args && typeof args.securityFilter !== 'function') {
        throw new Error(loggingPrefix + ": args.securityFilter must be a function when given");
    }
    var app = args.app;
    var docsPath = args.docsPath || '/api-docs';
    var consumesMiddleware = args.consumesMiddleware;
    var errorMiddleware = typeof args.errorMiddleware === 'function' &&
        args.errorMiddleware.length === 4
        ? args.errorMiddleware
        : null;
    var promiseMode = !!args.promiseMode;
    var securityFilter = args.securityFilter
        ? args.promiseMode
            ? toPromiseCompatibleMiddleware(args.securityFilter)
            : args.securityFilter
        : function defaultSecurityFilter(req, res, next) {
            res.status(200).json(req.apiDoc);
        };
    var frameworkArgs = __assign({ featureType: 'middleware', name: loggingPrefix }, args);
    var framework = new openapi_framework_1["default"](frameworkArgs);
    framework.initialize({
        visitApi: function (ctx) {
            if (exposeApiDocs || errorMiddleware) {
                var basePaths = [];
                basePaths.push.apply(basePaths, ctx.basePaths.map(toExpressBasePath));
                var _loop_1 = function (basePath) {
                    // Swagger UI support
                    if (exposeApiDocs) {
                        app.get(basePath + docsPath, function (req, res, next) {
                            // @ts-ignore
                            req.apiDoc = ctx.getApiDoc();
                            // @ts-ignore
                            if (req.apiDoc.swagger) {
                                // @ts-ignore
                                req.apiDoc.host = req.headers.host;
                                var apiBasePath = req.baseUrl + basePath;
                                // @ts-ignore
                                req.apiDoc.basePath =
                                    apiBasePath.length === 0 ? '/' : apiBasePath;
                            }
                            securityFilter(req, res, next);
                        });
                    }
                    // register custom error middleware to api's basePath
                    if (errorMiddleware) {
                        app.use(basePath, errorMiddleware);
                    }
                };
                for (var _i = 0, basePaths_1 = basePaths; _i < basePaths_1.length; _i++) {
                    var basePath = basePaths_1[_i];
                    _loop_1(basePath);
                }
            }
        },
        visitOperation: function (ctx) {
            var apiDoc = ctx.apiDoc;
            var methodName = ctx.methodName;
            var operationDoc = ctx.operationDoc;
            var operationHandler = ctx.operationHandler;
            var middleware = [].concat(ctx.additionalFeatures);
            if (operationDoc && ctx.allowsFeatures) {
                if (ctx.features.requestValidator) {
                    middleware.unshift(function requestValidatorMiddleware(req, res, next) {
                        next(ctx.features.requestValidator.validateRequest(req));
                    });
                }
                if (ctx.features.responseValidator) {
                    // add response validation middleware
                    // it's invalid for a method doc to not have responses, but the post
                    // validation will pick it up, so this is almost always going to be added.
                    middleware.unshift(function responseValidatorMiddleware(req, res, next) {
                        res.validateResponse = function (statusCode, response) {
                            return ctx.features.responseValidator.validateResponse(statusCode, response);
                        };
                        next();
                    });
                }
                if (ctx.features.coercer) {
                    middleware.unshift(function coercerMiddleware(req, res, next) {
                        ctx.features.coercer.coerce(req);
                        next();
                    });
                }
                if (ctx.features.defaultSetter) {
                    middleware.unshift(function defaultMiddleware(req, res, next) {
                        ctx.features.defaultSetter.handle(req);
                        next();
                    });
                }
                if (ctx.features.securityHandler) {
                    middleware.unshift(function (req, res, next) {
                        ctx.features.securityHandler
                            .handle(req)
                            .then(next)["catch"](next);
                    });
                }
                if (consumesMiddleware && ctx.consumes) {
                    addConsumesMiddleware(middleware, consumesMiddleware, ctx.consumes);
                }
                middleware.unshift(createAssignApiDocMiddleware(apiDoc, operationDoc));
            }
            middleware.push(operationHandler);
            optionallyAddQueryNormalizationMiddleware(middleware, ctx.methodParameters);
            if (promiseMode) {
                middleware = [].concat
                    .apply([], middleware)
                    .map(toPromiseCompatibleMiddleware);
            }
            var basePaths = [];
            basePaths.push.apply(basePaths, ctx.basePaths.map(toExpressBasePath));
            for (var _i = 0, basePaths_2 = basePaths; _i < basePaths_2.length; _i++) {
                var basePath = basePaths_2[_i];
                var expressPath = basePath +
                    '/' +
                    ctx.path
                        .substring(1)
                        .split('/')
                        .map(toExpressParams)
                        .join('/');
                app[methodName].apply(app, [expressPath].concat(middleware));
            }
        }
    });
    return framework;
}
exports.initialize = initialize;
function addConsumesMiddleware(middleware, consumesMiddleware, consumes) {
    for (var i = consumes.length - 1; i >= 0; --i) {
        var mimeType = consumes[i];
        if (mimeType in consumesMiddleware) {
            var middlewareToAdd = consumesMiddleware[mimeType];
            middleware.unshift(middlewareToAdd);
        }
    }
}
function createAssignApiDocMiddleware(apiDoc, operationDoc) {
    return function assignApiDocMiddleware(req, res, next) {
        req.apiDoc = apiDoc;
        req.operationDoc = operationDoc;
        next();
    };
}
function optionallyAddQueryNormalizationMiddleware(middleware, methodParameters) {
    if (!methodParameters) {
        return;
    }
    var queryParamsNeedingNormalization = methodParameters
        .filter(function (param) {
        return (param["in"] === 'query' && param[CASE_SENSITIVE_PARAM_PROPERTY] === false);
    })
        .map(function (param) {
        return param.name;
    });
    if (queryParamsNeedingNormalization.length) {
        middleware.unshift(normalizeQueryParamsMiddleware(queryParamsNeedingNormalization));
    }
}
function toExpressParams(part) {
    return part.replace(/\{([^}]+)}/g, ':$1');
}
function toPromiseCompatibleMiddleware(fn) {
    if (typeof fn === 'function' &&
        fn.name !== 'expressOpenapiPromiseMiddleware') {
        return function expressOpenapiPromiseMiddleware(req, res, next) {
            var potentialPromise = fn(req, res, next);
            if (potentialPromise && typeof potentialPromise["catch"] === 'function') {
                potentialPromise["catch"](next);
            }
        };
    }
    return fn;
}
function toExpressBasePath(basePath) {
    var path = basePath.path;
    if (basePath.hasVariables()) {
        path = path.replace(/:(\w+)/g, function (substring, p1) {
            if (basePath.variables[p1]["enum"]) {
                var validationRegex = "((" + basePath.variables[p1]["enum"].join('|') + "))";
                return ":" + p1 + validationRegex;
            }
            else {
                return ":" + p1;
            }
        });
    }
    return path;
}
//# sourceMappingURL=index.js.map