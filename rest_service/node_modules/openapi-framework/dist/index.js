"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
exports.__esModule = true;
var fs_routes_1 = require("fs-routes");
var openapi_default_setter_1 = require("openapi-default-setter");
var openapi_request_coercer_1 = require("openapi-request-coercer");
var openapi_request_validator_1 = require("openapi-request-validator");
var openapi_response_validator_1 = require("openapi-response-validator");
var openapi_schema_validator_1 = require("openapi-schema-validator");
var openapi_security_handler_1 = require("openapi-security-handler");
var BasePath_1 = require("./src/BasePath");
exports.BasePath = BasePath_1["default"];
var types_1 = require("./src/types");
var util_1 = require("./src/util");
var OpenAPIFramework = /** @class */ (function () {
    function OpenAPIFramework(args) {
        if (args === void 0) { args = {}; }
        var _this = this;
        this.args = args;
        this.name = args.name;
        this.featureType = args.featureType;
        this.loggingPrefix = args.name ? this.name + ": " : '';
        this.logger = args.logger ? args.logger : new types_1.ConsoleDebugAdapterLogger();
        // monkey patch for node v6:
        if (!this.logger.debug) {
            this.logger.debug = this.logger.info;
        }
        [
            { name: 'apiDoc', required: true },
            { name: 'errorTransformer', type: 'function' },
            { name: 'externalSchemas', type: 'object' },
            { name: 'featureType', required: true },
            { name: 'name', required: true },
            { name: 'pathSecurity', "class": Array, className: 'Array' },
            { name: 'securityHandlers', type: 'object' }
        ].forEach(function (arg) {
            if (arg.required && !(arg.name in args)) {
                throw new Error(_this.loggingPrefix + "args." + arg.name + " is required");
            }
            if (arg.type && arg.name in args && typeof args[arg.name] !== arg.type) {
                throw new Error(_this.loggingPrefix + "args." + arg.name + " must be a " + arg.type + " when given");
            }
            if (arg["class"] &&
                arg.name in args &&
                !(args[arg.name] instanceof arg["class"])) {
                throw new Error(_this.loggingPrefix + "args." + arg.name + " must be an instance of " + arg.className + " when given");
            }
        });
        if (!args.paths && !args.operations) {
            throw new Error(this.loggingPrefix + "args.paths and args.operations must not both be empty");
        }
        this.enableObjectCoercion = !!args.enableObjectCoercion;
        this.originalApiDoc = util_1.handleYaml(util_1.handleFilePath(args.apiDoc));
        this.apiDoc = util_1.copy(this.originalApiDoc);
        this.basePaths = this.apiDoc.openapi
            ? util_1.getBasePathsFromServers(this.apiDoc.servers)
            : [
                new BasePath_1["default"]({ url: (this.apiDoc.basePath || '').replace(/\/$/, '') })
            ];
        this.validateApiDoc =
            'validateApiDoc' in args ? !!args.validateApiDoc : true;
        this.validator = new openapi_schema_validator_1["default"]({
            version: this.apiDoc.openapi ||
                this.apiDoc.swagger,
            extensions: this.apiDoc["x-" + this.name + "-schema-extension"]
        });
        this.customFormats = args.customFormats;
        this.dependencies = args.dependencies;
        this.errorTransformer = args.errorTransformer;
        this.externalSchemas = args.externalSchemas;
        this.operations = args.operations;
        this.paths = args.paths;
        this.pathsIgnore = args.pathsIgnore;
        this.pathSecurity = Array.isArray(args.pathSecurity)
            ? args.pathSecurity
            : [];
        this.routesGlob = args.routesGlob;
        this.routesIndexFileRegExp = args.routesIndexFileRegExp;
        this.securityHandlers = args.securityHandlers;
        this.pathSecurity.forEach(util_1.assertRegExpAndSecurity.bind(null, this));
        if (this.validateApiDoc) {
            var apiDocValidation = this.validator.validate(this.apiDoc);
            if (apiDocValidation.errors.length) {
                this.logger.error(this.loggingPrefix + "Validating schema before populating paths");
                this.logger.error(this.loggingPrefix + "validation errors", JSON.stringify(apiDocValidation.errors, null, '  '));
                throw new Error(this.loggingPrefix + "args.apiDoc was invalid.  See the output.");
            }
        }
    }
    OpenAPIFramework.prototype.initialize = function (visitor) {
        var _this = this;
        var securitySchemes = this.apiDoc.openapi
            ? (this.apiDoc.components || {}).securitySchemes
            : this.apiDoc.securityDefinitions;
        var apiSecurityMiddleware = this.securityHandlers && this.apiDoc.security && securitySchemes
            ? new openapi_security_handler_1["default"]({
                securityDefinitions: securitySchemes,
                securityHandlers: this.securityHandlers,
                operationSecurity: this.apiDoc.security,
                loggingKey: this.name + "-security"
            })
            : null;
        var paths = [];
        var routes = [];
        var routesCheckMap = {};
        if (this.paths) {
            paths = [].concat(this.paths);
            this.logger.debug(this.loggingPrefix + "paths=", paths);
            paths.forEach(function (pathItem) {
                if (util_1.byString(pathItem)) {
                    pathItem = util_1.toAbsolutePath(pathItem);
                    if (!util_1.byDirectory(pathItem)) {
                        throw new Error(_this.loggingPrefix + "args.paths contained a value that was not a path to a directory");
                    }
                    routes = routes.concat(fs_routes_1["default"](pathItem, {
                        glob: _this.routesGlob,
                        indexFileRegExp: _this.routesIndexFileRegExp
                    })
                        .filter(function (fsRoutesItem) {
                        return _this.pathsIgnore
                            ? !_this.pathsIgnore.test(fsRoutesItem.route)
                            : true;
                    })
                        .map(function (fsRoutesItem) {
                        routesCheckMap[fsRoutesItem.route] = true;
                        return {
                            path: fsRoutesItem.route,
                            module: require(fsRoutesItem.path)
                        };
                    }));
                }
                else {
                    if (!pathItem.path || !pathItem.module) {
                        throw new Error(_this.loggingPrefix + "args.paths must consist of strings or valid route specifications");
                    }
                    routes.push(pathItem);
                }
            });
            routes = routes.sort(util_1.byRoute);
        }
        if (this.operations) {
            var apiDocPaths_1 = this.apiDoc.paths;
            Object.keys(apiDocPaths_1).forEach(function (apiDocPathUrl) {
                var pathDoc = apiDocPaths_1[apiDocPathUrl];
                var route = {
                    path: apiDocPathUrl,
                    module: Object.keys(pathDoc)
                        .filter(util_1.byMethods)
                        .reduce(function (acc, method) {
                        var methodDoc = pathDoc[util_1.METHOD_ALIASES[method]];
                        var operationId = methodDoc.operationId;
                        if (operationId && operationId in _this.operations) {
                            var operation_1 = _this.operations[operationId];
                            acc[util_1.METHOD_ALIASES[method]] = (function () {
                                var innerFunction = operation_1;
                                innerFunction.apiDoc = methodDoc;
                                // Operations get dependencies injected in `this`
                                return innerFunction.bind({
                                    dependencies: __assign({}, _this.dependencies)
                                });
                            })();
                        }
                        else if (operationId === undefined) {
                            _this.logger.warn(_this.loggingPrefix + "path " + apiDocPathUrl + ", operation " + method + " is missing an operationId");
                        }
                        else {
                            _this.logger.warn(_this.loggingPrefix + "Operation " + operationId + " not found in the operations parameter");
                        }
                        return acc;
                    }, {})
                };
                if (routesCheckMap[route.path]) {
                    _this.logger.warn(_this.loggingPrefix + "Overriding path " + route.path + " with handlers from operations");
                    var routeIndex = routes.findIndex(function (r) { return r.path === route.path; });
                    routes[routeIndex] = __assign({}, routes[routeIndex], route, { module: __assign({}, ((routes[routeIndex] || {}).module || {}), (route.module || {})) });
                }
                else {
                    routes.push(route);
                }
            });
        }
        this.logger.debug(this.loggingPrefix + "routes=", routes);
        // Check for duplicate routes
        var dups = routes.filter(function (v, i, o) {
            if (i > 0 && v.path === o[i - 1].path) {
                return v.path;
            }
        });
        if (dups.length > 0) {
            throw new Error(this.loggingPrefix + "args.paths produced duplicate urls for \"" + dups[0].path + "\"");
        }
        var getApiDoc = function () {
            return util_1.copy(_this.apiDoc);
        };
        routes.forEach(function (routeItem) {
            var route = routeItem.path;
            _this.logger.debug(_this.loggingPrefix + "setting up", route);
            var pathModule = util_1.injectDependencies(routeItem.module["default"] || routeItem.module, _this.dependencies);
            // express path params start with :paramName
            // openapi path params use {paramName}
            var openapiPath = route;
            // Do not make modifications to this.
            var originalPathItem = _this.originalApiDoc.paths[openapiPath] || {};
            var pathDoc = _this.apiDoc.paths[openapiPath] || {};
            var pathParameters = pathDoc.parameters || [];
            // push all parameters defined in the path module to the path parameter list
            if (Array.isArray(pathModule.parameters)) {
                [].push.apply(pathParameters, pathModule.parameters);
            }
            pathDoc.parameters = pathParameters;
            _this.apiDoc.paths[openapiPath] = pathDoc;
            var methodsProcessed = {};
            new Set(Object.keys(pathModule)
                .concat(Object.keys(pathDoc))
                .filter(util_1.byMethods)).forEach(function (methodAlias) {
                var methodName = util_1.METHOD_ALIASES[methodAlias];
                if (methodName in methodsProcessed) {
                    _this.logger.warn("" + _this.loggingPrefix + openapiPath + "." + methodAlias + " has already been defined as " + openapiPath + "." + methodsProcessed[methodName] + ". Ignoring the 2nd definition...");
                    return;
                }
                methodsProcessed[methodName] = methodAlias;
                // operationHandler may be an array or a function.
                var operationHandler = pathModule[methodAlias] ||
                    routeItem.operations[(pathDoc[methodAlias] || {}).operationId];
                var operationDoc = util_1.handleYaml(util_1.getMethodDoc(operationHandler)) || pathDoc[methodName];
                // consumes is defined as property of each operation or entire document
                // in Swagger 2.0. For OpenAPI 3.0 consumes mime types are defined as the
                // key value(s) for each operation requestBody.content object.
                var consumes = operationDoc && Array.isArray(operationDoc.consumes)
                    ? operationDoc.consumes
                    : operationDoc &&
                        operationDoc.requestBody &&
                        (operationDoc.requestBody.content ||
                            operationDoc.requestBody.$ref)
                        ? Object.keys(util_1.resolveRequestBodyRefs(_this, operationDoc.requestBody, _this.apiDoc).content)
                        : Array.isArray(_this.apiDoc.consumes)
                            ? _this.apiDoc.consumes
                            : [];
                var operationContext = {
                    additionalFeatures: util_1.getAdditionalFeatures(_this, _this.logger, _this.originalApiDoc, originalPathItem, pathModule, operationDoc),
                    allowsFeatures: util_1.allowsFeatures(_this, _this.apiDoc, pathModule, pathDoc, operationDoc),
                    apiDoc: _this.apiDoc,
                    basePaths: _this.basePaths,
                    consumes: consumes,
                    features: {},
                    methodName: methodName,
                    methodParameters: [],
                    operationDoc: operationDoc,
                    operationHandler: operationHandler,
                    path: openapiPath
                };
                if (operationDoc) {
                    pathDoc[methodName] = operationDoc;
                    if (operationDoc.tags) {
                        util_1.sortOperationDocTags(operationDoc);
                        operationDoc.tags.forEach(util_1.addOperationTagToApiDoc.bind(null, _this.apiDoc));
                    }
                    if (operationContext.allowsFeatures) {
                        // add features
                        if (operationDoc.responses &&
                            util_1.allowsResponseValidationFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                            // add response validation feature
                            // it's invalid for a method doc to not have responses, but the post
                            // validation will pick it up, so this is almost always going to be added.
                            var responseValidator = new openapi_response_validator_1["default"]({
                                loggingKey: _this.name + "-response-validation",
                                components: _this.apiDoc.components,
                                definitions: _this.apiDoc.definitions,
                                externalSchemas: _this.externalSchemas,
                                errorTransformer: _this.errorTransformer,
                                responses: util_1.resolveResponseRefs(_this, operationDoc.responses, _this.apiDoc, route),
                                customFormats: _this.customFormats
                            });
                            operationContext.features.responseValidator = responseValidator;
                        }
                        var methodParameters = util_1.withNoDuplicates(util_1.resolveParameterRefs(_this, Array.isArray(operationDoc.parameters)
                            ? pathParameters.concat(operationDoc.parameters)
                            : pathParameters, _this.apiDoc));
                        operationContext.methodParameters = methodParameters;
                        if (methodParameters.length || operationDoc.requestBody) {
                            // defaults, coercion, and parameter validation middleware
                            if (util_1.allowsValidationFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                                var requestValidator = new openapi_request_validator_1["default"]({
                                    errorTransformer: _this.errorTransformer,
                                    logger: _this.logger,
                                    parameters: methodParameters,
                                    schemas: _this.apiDoc.definitions,
                                    componentSchemas: _this.apiDoc.components // v3
                                        ? _this.apiDoc.components.schemas
                                        : undefined,
                                    externalSchemas: _this.externalSchemas,
                                    customFormats: _this.customFormats,
                                    requestBody: util_1.resolveRequestBodyRefs(_this, operationDoc.requestBody, _this.apiDoc)
                                });
                                operationContext.features.requestValidator = requestValidator;
                                _this.logger.debug(_this.loggingPrefix + "request validator on for", methodName, openapiPath);
                            }
                            if (util_1.allowsCoercionFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                                var coercer = new openapi_request_coercer_1["default"]({
                                    extensionBase: "x-" + _this.name + "-coercion",
                                    loggingKey: _this.name + "-coercion",
                                    parameters: methodParameters,
                                    enableObjectCoercion: _this.enableObjectCoercion
                                });
                                operationContext.features.coercer = coercer;
                            }
                            // no point in default feature if we don't have any parameters with defaults.
                            if (methodParameters.filter(util_1.byDefault).length &&
                                util_1.allowsDefaultsFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                                var defaultSetter = new openapi_default_setter_1["default"]({
                                    parameters: methodParameters
                                });
                                operationContext.features.defaultSetter = defaultSetter;
                            }
                        }
                        var securityFeature = void 0;
                        var securityDefinition = void 0;
                        if (_this.securityHandlers && securitySchemes) {
                            if (operationDoc.security) {
                                securityDefinition = operationDoc.security;
                            }
                            else if (_this.pathSecurity.length) {
                                securityDefinition = util_1.getSecurityDefinitionByPath(openapiPath, _this.pathSecurity);
                            }
                        }
                        if (securityDefinition) {
                            pathDoc[methodName].security = securityDefinition;
                            securityFeature = new openapi_security_handler_1["default"]({
                                securityDefinitions: securitySchemes,
                                securityHandlers: _this.securityHandlers,
                                operationSecurity: securityDefinition,
                                loggingKey: _this.name + "-security"
                            });
                        }
                        else if (apiSecurityMiddleware) {
                            securityFeature = apiSecurityMiddleware;
                        }
                        if (securityFeature) {
                            operationContext.features.securityHandler = securityFeature;
                        }
                    }
                }
                if (visitor.visitOperation) {
                    visitor.visitOperation(operationContext);
                }
            });
            if (visitor.visitPath) {
                visitor.visitPath({
                    basePaths: _this.basePaths,
                    getApiDoc: getApiDoc,
                    getPathDoc: function () { return util_1.copy(pathDoc); }
                });
            }
        });
        util_1.sortApiDocTags(this.apiDoc);
        if (this.validateApiDoc) {
            var apiDocValidation = this.validator.validate(this.apiDoc);
            if (apiDocValidation.errors.length) {
                this.logger.error(this.loggingPrefix + "Validating schema after populating paths");
                this.logger.error(this.loggingPrefix + "validation errors", JSON.stringify(apiDocValidation.errors, null, '  '));
                throw new Error(this.loggingPrefix + "args.apiDoc was invalid after populating paths.  See the output.");
            }
        }
        if (visitor.visitApi) {
            visitor.visitApi({
                basePaths: this.basePaths,
                getApiDoc: getApiDoc
            });
        }
    };
    return OpenAPIFramework;
}());
exports["default"] = OpenAPIFramework;
//# sourceMappingURL=index.js.map